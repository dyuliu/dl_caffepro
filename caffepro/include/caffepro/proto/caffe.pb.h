// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: caffe.proto

#ifndef PROTOBUF_caffe_2eproto__INCLUDED
#define PROTOBUF_caffe_2eproto__INCLUDED

#ifdef _MSC_VER
#  pragma warning(push)
#  pragma warning(disable: 4127 4244 4267)
#endif

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

namespace caffepro {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_caffe_2eproto();
void protobuf_AssignDesc_caffe_2eproto();
void protobuf_ShutdownFile_caffe_2eproto();

class BlobProto;
class BlobProtoVector;
class Datum;
class FillerParameter;
class LayerParameter;
class ClusterParameter;
class OnlineKMeansParameter;
class EltwiseSumParameter;
class ReluParameter;
class LearnableLeakReluParameter;
class ExpParameter;
class BoundParameter;
class BatchNormalizationParameter;
class GPUSplitParameter;
class ConcatParameter;
class GridGeneratorParameter;
class SampleParameter;
class AnchorParameter;
class ConvolutionParameter;
class CorrelationParameter;
class WeightParameter;
class DataProcesser;
class DataParameter_BigFile;
class DataEntryParameter;
class DropoutParameter;
class PaddingParameter;
class InfogainLossParameter;
class LossParameter;
class ClsLocLossParameter;
class InnerProductParameter;
class LRNParameter;
class PoolingParameter;
class SPMParameter;
class PowerParameter;
class LayerConnection;
class NetParameter;
class SolverParameter;
class SolverState;
class ScaleBiasParameter;
class CropParameter;
class ReduceDimParameter;
class FlipParameter;
class StepGateParameter;
class HouseholderParameter;
class InstanceSampleParameter;
class MatrixMulParameter;
class MatrixMulStackParameter;
class TransposeParameter;
class ReshapeParameter;
class LearnableDropoutParameter;
class DimInnerProductParameter;
class SoftthrParameter;
class DropoutsameParameter;
class DiagOperationParameter;
class SoftMaxLossOHEMParameter;
class SoftMaxOHEMParameter;
class SoftMaxOHEMSplitParameter;

enum LayerParameter_UpdateMethod {
  LayerParameter_UpdateMethod_NORMAL = 0,
  LayerParameter_UpdateMethod_ADAGRAD = 1,
  LayerParameter_UpdateMethod_ADAGRAD_RECORD_ONLY = 2
};
bool LayerParameter_UpdateMethod_IsValid(int value);
const LayerParameter_UpdateMethod LayerParameter_UpdateMethod_UpdateMethod_MIN = LayerParameter_UpdateMethod_NORMAL;
const LayerParameter_UpdateMethod LayerParameter_UpdateMethod_UpdateMethod_MAX = LayerParameter_UpdateMethod_ADAGRAD_RECORD_ONLY;
const int LayerParameter_UpdateMethod_UpdateMethod_ARRAYSIZE = LayerParameter_UpdateMethod_UpdateMethod_MAX + 1;

const ::google::protobuf::EnumDescriptor* LayerParameter_UpdateMethod_descriptor();
inline const ::std::string& LayerParameter_UpdateMethod_Name(LayerParameter_UpdateMethod value) {
  return ::google::protobuf::internal::NameOfEnum(
    LayerParameter_UpdateMethod_descriptor(), value);
}
inline bool LayerParameter_UpdateMethod_Parse(
    const ::std::string& name, LayerParameter_UpdateMethod* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LayerParameter_UpdateMethod>(
    LayerParameter_UpdateMethod_descriptor(), name, value);
}
enum LearnableLeakReluParameter_ShareParamMethod {
  LearnableLeakReluParameter_ShareParamMethod_CHANNEL = 0,
  LearnableLeakReluParameter_ShareParamMethod_ALL = 1
};
bool LearnableLeakReluParameter_ShareParamMethod_IsValid(int value);
const LearnableLeakReluParameter_ShareParamMethod LearnableLeakReluParameter_ShareParamMethod_ShareParamMethod_MIN = LearnableLeakReluParameter_ShareParamMethod_CHANNEL;
const LearnableLeakReluParameter_ShareParamMethod LearnableLeakReluParameter_ShareParamMethod_ShareParamMethod_MAX = LearnableLeakReluParameter_ShareParamMethod_ALL;
const int LearnableLeakReluParameter_ShareParamMethod_ShareParamMethod_ARRAYSIZE = LearnableLeakReluParameter_ShareParamMethod_ShareParamMethod_MAX + 1;

const ::google::protobuf::EnumDescriptor* LearnableLeakReluParameter_ShareParamMethod_descriptor();
inline const ::std::string& LearnableLeakReluParameter_ShareParamMethod_Name(LearnableLeakReluParameter_ShareParamMethod value) {
  return ::google::protobuf::internal::NameOfEnum(
    LearnableLeakReluParameter_ShareParamMethod_descriptor(), value);
}
inline bool LearnableLeakReluParameter_ShareParamMethod_Parse(
    const ::std::string& name, LearnableLeakReluParameter_ShareParamMethod* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LearnableLeakReluParameter_ShareParamMethod>(
    LearnableLeakReluParameter_ShareParamMethod_descriptor(), name, value);
}
enum BatchNormalizationParameter_RecordOption {
  BatchNormalizationParameter_RecordOption_NOT_RECORD = 0,
  BatchNormalizationParameter_RecordOption_RECORD = 1,
  BatchNormalizationParameter_RecordOption_USE_RECORD_NORM = 2,
  BatchNormalizationParameter_RecordOption_NOT_CALC = 3
};
bool BatchNormalizationParameter_RecordOption_IsValid(int value);
const BatchNormalizationParameter_RecordOption BatchNormalizationParameter_RecordOption_RecordOption_MIN = BatchNormalizationParameter_RecordOption_NOT_RECORD;
const BatchNormalizationParameter_RecordOption BatchNormalizationParameter_RecordOption_RecordOption_MAX = BatchNormalizationParameter_RecordOption_NOT_CALC;
const int BatchNormalizationParameter_RecordOption_RecordOption_ARRAYSIZE = BatchNormalizationParameter_RecordOption_RecordOption_MAX + 1;

const ::google::protobuf::EnumDescriptor* BatchNormalizationParameter_RecordOption_descriptor();
inline const ::std::string& BatchNormalizationParameter_RecordOption_Name(BatchNormalizationParameter_RecordOption value) {
  return ::google::protobuf::internal::NameOfEnum(
    BatchNormalizationParameter_RecordOption_descriptor(), value);
}
inline bool BatchNormalizationParameter_RecordOption_Parse(
    const ::std::string& name, BatchNormalizationParameter_RecordOption* value) {
  return ::google::protobuf::internal::ParseNamedEnum<BatchNormalizationParameter_RecordOption>(
    BatchNormalizationParameter_RecordOption_descriptor(), name, value);
}
enum GridGeneratorParameter_GridSizeOption {
  GridGeneratorParameter_GridSizeOption_RELATIVE = 0,
  GridGeneratorParameter_GridSizeOption_ABSOLUTE = 1
};
bool GridGeneratorParameter_GridSizeOption_IsValid(int value);
const GridGeneratorParameter_GridSizeOption GridGeneratorParameter_GridSizeOption_GridSizeOption_MIN = GridGeneratorParameter_GridSizeOption_RELATIVE;
const GridGeneratorParameter_GridSizeOption GridGeneratorParameter_GridSizeOption_GridSizeOption_MAX = GridGeneratorParameter_GridSizeOption_ABSOLUTE;
const int GridGeneratorParameter_GridSizeOption_GridSizeOption_ARRAYSIZE = GridGeneratorParameter_GridSizeOption_GridSizeOption_MAX + 1;

const ::google::protobuf::EnumDescriptor* GridGeneratorParameter_GridSizeOption_descriptor();
inline const ::std::string& GridGeneratorParameter_GridSizeOption_Name(GridGeneratorParameter_GridSizeOption value) {
  return ::google::protobuf::internal::NameOfEnum(
    GridGeneratorParameter_GridSizeOption_descriptor(), value);
}
inline bool GridGeneratorParameter_GridSizeOption_Parse(
    const ::std::string& name, GridGeneratorParameter_GridSizeOption* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GridGeneratorParameter_GridSizeOption>(
    GridGeneratorParameter_GridSizeOption_descriptor(), name, value);
}
enum SampleParameter_ConcatOutputOption {
  SampleParameter_ConcatOutputOption_CHANNEL = 0,
  SampleParameter_ConcatOutputOption_NUM = 1
};
bool SampleParameter_ConcatOutputOption_IsValid(int value);
const SampleParameter_ConcatOutputOption SampleParameter_ConcatOutputOption_ConcatOutputOption_MIN = SampleParameter_ConcatOutputOption_CHANNEL;
const SampleParameter_ConcatOutputOption SampleParameter_ConcatOutputOption_ConcatOutputOption_MAX = SampleParameter_ConcatOutputOption_NUM;
const int SampleParameter_ConcatOutputOption_ConcatOutputOption_ARRAYSIZE = SampleParameter_ConcatOutputOption_ConcatOutputOption_MAX + 1;

const ::google::protobuf::EnumDescriptor* SampleParameter_ConcatOutputOption_descriptor();
inline const ::std::string& SampleParameter_ConcatOutputOption_Name(SampleParameter_ConcatOutputOption value) {
  return ::google::protobuf::internal::NameOfEnum(
    SampleParameter_ConcatOutputOption_descriptor(), value);
}
inline bool SampleParameter_ConcatOutputOption_Parse(
    const ::std::string& name, SampleParameter_ConcatOutputOption* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SampleParameter_ConcatOutputOption>(
    SampleParameter_ConcatOutputOption_descriptor(), name, value);
}
enum DataParameter_BigFile_InterpolationType {
  DataParameter_BigFile_InterpolationType_Bilinear = 0,
  DataParameter_BigFile_InterpolationType_Bicubic = 1,
  DataParameter_BigFile_InterpolationType_Lanczos = 2
};
bool DataParameter_BigFile_InterpolationType_IsValid(int value);
const DataParameter_BigFile_InterpolationType DataParameter_BigFile_InterpolationType_InterpolationType_MIN = DataParameter_BigFile_InterpolationType_Bilinear;
const DataParameter_BigFile_InterpolationType DataParameter_BigFile_InterpolationType_InterpolationType_MAX = DataParameter_BigFile_InterpolationType_Lanczos;
const int DataParameter_BigFile_InterpolationType_InterpolationType_ARRAYSIZE = DataParameter_BigFile_InterpolationType_InterpolationType_MAX + 1;

const ::google::protobuf::EnumDescriptor* DataParameter_BigFile_InterpolationType_descriptor();
inline const ::std::string& DataParameter_BigFile_InterpolationType_Name(DataParameter_BigFile_InterpolationType value) {
  return ::google::protobuf::internal::NameOfEnum(
    DataParameter_BigFile_InterpolationType_descriptor(), value);
}
inline bool DataParameter_BigFile_InterpolationType_Parse(
    const ::std::string& name, DataParameter_BigFile_InterpolationType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DataParameter_BigFile_InterpolationType>(
    DataParameter_BigFile_InterpolationType_descriptor(), name, value);
}
enum DataParameter_BigFile_ScaleJitterType {
  DataParameter_BigFile_ScaleJitterType_UniRatio = 0,
  DataParameter_BigFile_ScaleJitterType_UniLength = 1,
  DataParameter_BigFile_ScaleJitterType_UniArea = 2,
  DataParameter_BigFile_ScaleJitterType_UniAreaV2 = 3
};
bool DataParameter_BigFile_ScaleJitterType_IsValid(int value);
const DataParameter_BigFile_ScaleJitterType DataParameter_BigFile_ScaleJitterType_ScaleJitterType_MIN = DataParameter_BigFile_ScaleJitterType_UniRatio;
const DataParameter_BigFile_ScaleJitterType DataParameter_BigFile_ScaleJitterType_ScaleJitterType_MAX = DataParameter_BigFile_ScaleJitterType_UniAreaV2;
const int DataParameter_BigFile_ScaleJitterType_ScaleJitterType_ARRAYSIZE = DataParameter_BigFile_ScaleJitterType_ScaleJitterType_MAX + 1;

const ::google::protobuf::EnumDescriptor* DataParameter_BigFile_ScaleJitterType_descriptor();
inline const ::std::string& DataParameter_BigFile_ScaleJitterType_Name(DataParameter_BigFile_ScaleJitterType value) {
  return ::google::protobuf::internal::NameOfEnum(
    DataParameter_BigFile_ScaleJitterType_descriptor(), value);
}
inline bool DataParameter_BigFile_ScaleJitterType_Parse(
    const ::std::string& name, DataParameter_BigFile_ScaleJitterType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DataParameter_BigFile_ScaleJitterType>(
    DataParameter_BigFile_ScaleJitterType_descriptor(), name, value);
}
enum DataParameter_BigFile_CropPreference {
  DataParameter_BigFile_CropPreference_IoCThres = 0,
  DataParameter_BigFile_CropPreference_IoUMax = 1,
  DataParameter_BigFile_CropPreference_IoUThres = 2,
  DataParameter_BigFile_CropPreference_AnchorMaxThres = 3
};
bool DataParameter_BigFile_CropPreference_IsValid(int value);
const DataParameter_BigFile_CropPreference DataParameter_BigFile_CropPreference_CropPreference_MIN = DataParameter_BigFile_CropPreference_IoCThres;
const DataParameter_BigFile_CropPreference DataParameter_BigFile_CropPreference_CropPreference_MAX = DataParameter_BigFile_CropPreference_AnchorMaxThres;
const int DataParameter_BigFile_CropPreference_CropPreference_ARRAYSIZE = DataParameter_BigFile_CropPreference_CropPreference_MAX + 1;

const ::google::protobuf::EnumDescriptor* DataParameter_BigFile_CropPreference_descriptor();
inline const ::std::string& DataParameter_BigFile_CropPreference_Name(DataParameter_BigFile_CropPreference value) {
  return ::google::protobuf::internal::NameOfEnum(
    DataParameter_BigFile_CropPreference_descriptor(), value);
}
inline bool DataParameter_BigFile_CropPreference_Parse(
    const ::std::string& name, DataParameter_BigFile_CropPreference* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DataParameter_BigFile_CropPreference>(
    DataParameter_BigFile_CropPreference_descriptor(), name, value);
}
enum ClsLocLossParameter_LocType {
  ClsLocLossParameter_LocType_PCR = 0,
  ClsLocLossParameter_LocType_SCR = 1,
  ClsLocLossParameter_LocType_USER_DEFINED = 2
};
bool ClsLocLossParameter_LocType_IsValid(int value);
const ClsLocLossParameter_LocType ClsLocLossParameter_LocType_LocType_MIN = ClsLocLossParameter_LocType_PCR;
const ClsLocLossParameter_LocType ClsLocLossParameter_LocType_LocType_MAX = ClsLocLossParameter_LocType_USER_DEFINED;
const int ClsLocLossParameter_LocType_LocType_ARRAYSIZE = ClsLocLossParameter_LocType_LocType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ClsLocLossParameter_LocType_descriptor();
inline const ::std::string& ClsLocLossParameter_LocType_Name(ClsLocLossParameter_LocType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ClsLocLossParameter_LocType_descriptor(), value);
}
inline bool ClsLocLossParameter_LocType_Parse(
    const ::std::string& name, ClsLocLossParameter_LocType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ClsLocLossParameter_LocType>(
    ClsLocLossParameter_LocType_descriptor(), name, value);
}
enum ClsLocLossParameter_LossTransform {
  ClsLocLossParameter_LossTransform_LTRB = 0,
  ClsLocLossParameter_LossTransform_CX_CY_LOGW_LOGH = 1
};
bool ClsLocLossParameter_LossTransform_IsValid(int value);
const ClsLocLossParameter_LossTransform ClsLocLossParameter_LossTransform_LossTransform_MIN = ClsLocLossParameter_LossTransform_LTRB;
const ClsLocLossParameter_LossTransform ClsLocLossParameter_LossTransform_LossTransform_MAX = ClsLocLossParameter_LossTransform_CX_CY_LOGW_LOGH;
const int ClsLocLossParameter_LossTransform_LossTransform_ARRAYSIZE = ClsLocLossParameter_LossTransform_LossTransform_MAX + 1;

const ::google::protobuf::EnumDescriptor* ClsLocLossParameter_LossTransform_descriptor();
inline const ::std::string& ClsLocLossParameter_LossTransform_Name(ClsLocLossParameter_LossTransform value) {
  return ::google::protobuf::internal::NameOfEnum(
    ClsLocLossParameter_LossTransform_descriptor(), value);
}
inline bool ClsLocLossParameter_LossTransform_Parse(
    const ::std::string& name, ClsLocLossParameter_LossTransform* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ClsLocLossParameter_LossTransform>(
    ClsLocLossParameter_LossTransform_descriptor(), name, value);
}
enum LRNParameter_NormRegion {
  LRNParameter_NormRegion_ACROSS_CHANNELS = 0,
  LRNParameter_NormRegion_WITHIN_CHANNEL = 1
};
bool LRNParameter_NormRegion_IsValid(int value);
const LRNParameter_NormRegion LRNParameter_NormRegion_NormRegion_MIN = LRNParameter_NormRegion_ACROSS_CHANNELS;
const LRNParameter_NormRegion LRNParameter_NormRegion_NormRegion_MAX = LRNParameter_NormRegion_WITHIN_CHANNEL;
const int LRNParameter_NormRegion_NormRegion_ARRAYSIZE = LRNParameter_NormRegion_NormRegion_MAX + 1;

const ::google::protobuf::EnumDescriptor* LRNParameter_NormRegion_descriptor();
inline const ::std::string& LRNParameter_NormRegion_Name(LRNParameter_NormRegion value) {
  return ::google::protobuf::internal::NameOfEnum(
    LRNParameter_NormRegion_descriptor(), value);
}
inline bool LRNParameter_NormRegion_Parse(
    const ::std::string& name, LRNParameter_NormRegion* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LRNParameter_NormRegion>(
    LRNParameter_NormRegion_descriptor(), name, value);
}
enum PoolingParameter_PoolMethod {
  PoolingParameter_PoolMethod_MAX = 0,
  PoolingParameter_PoolMethod_AVE = 1,
  PoolingParameter_PoolMethod_STOCHASTIC = 2
};
bool PoolingParameter_PoolMethod_IsValid(int value);
const PoolingParameter_PoolMethod PoolingParameter_PoolMethod_PoolMethod_MIN = PoolingParameter_PoolMethod_MAX;
const PoolingParameter_PoolMethod PoolingParameter_PoolMethod_PoolMethod_MAX = PoolingParameter_PoolMethod_STOCHASTIC;
const int PoolingParameter_PoolMethod_PoolMethod_ARRAYSIZE = PoolingParameter_PoolMethod_PoolMethod_MAX + 1;

const ::google::protobuf::EnumDescriptor* PoolingParameter_PoolMethod_descriptor();
inline const ::std::string& PoolingParameter_PoolMethod_Name(PoolingParameter_PoolMethod value) {
  return ::google::protobuf::internal::NameOfEnum(
    PoolingParameter_PoolMethod_descriptor(), value);
}
inline bool PoolingParameter_PoolMethod_Parse(
    const ::std::string& name, PoolingParameter_PoolMethod* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PoolingParameter_PoolMethod>(
    PoolingParameter_PoolMethod_descriptor(), name, value);
}
enum SPMParameter_PoolMethod {
  SPMParameter_PoolMethod_MAX = 0,
  SPMParameter_PoolMethod_AVE = 1,
  SPMParameter_PoolMethod_STOCHASTIC = 2
};
bool SPMParameter_PoolMethod_IsValid(int value);
const SPMParameter_PoolMethod SPMParameter_PoolMethod_PoolMethod_MIN = SPMParameter_PoolMethod_MAX;
const SPMParameter_PoolMethod SPMParameter_PoolMethod_PoolMethod_MAX = SPMParameter_PoolMethod_STOCHASTIC;
const int SPMParameter_PoolMethod_PoolMethod_ARRAYSIZE = SPMParameter_PoolMethod_PoolMethod_MAX + 1;

const ::google::protobuf::EnumDescriptor* SPMParameter_PoolMethod_descriptor();
inline const ::std::string& SPMParameter_PoolMethod_Name(SPMParameter_PoolMethod value) {
  return ::google::protobuf::internal::NameOfEnum(
    SPMParameter_PoolMethod_descriptor(), value);
}
inline bool SPMParameter_PoolMethod_Parse(
    const ::std::string& name, SPMParameter_PoolMethod* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SPMParameter_PoolMethod>(
    SPMParameter_PoolMethod_descriptor(), name, value);
}
enum CropParameter_CropType {
  CropParameter_CropType_ViewDense = 0,
  CropParameter_CropType_View10 = 1
};
bool CropParameter_CropType_IsValid(int value);
const CropParameter_CropType CropParameter_CropType_CropType_MIN = CropParameter_CropType_ViewDense;
const CropParameter_CropType CropParameter_CropType_CropType_MAX = CropParameter_CropType_View10;
const int CropParameter_CropType_CropType_ARRAYSIZE = CropParameter_CropType_CropType_MAX + 1;

const ::google::protobuf::EnumDescriptor* CropParameter_CropType_descriptor();
inline const ::std::string& CropParameter_CropType_Name(CropParameter_CropType value) {
  return ::google::protobuf::internal::NameOfEnum(
    CropParameter_CropType_descriptor(), value);
}
inline bool CropParameter_CropType_Parse(
    const ::std::string& name, CropParameter_CropType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CropParameter_CropType>(
    CropParameter_CropType_descriptor(), name, value);
}
enum ReduceDimParameter_ReduceType {
  ReduceDimParameter_ReduceType_AVE = 0,
  ReduceDimParameter_ReduceType_SUM = 1
};
bool ReduceDimParameter_ReduceType_IsValid(int value);
const ReduceDimParameter_ReduceType ReduceDimParameter_ReduceType_ReduceType_MIN = ReduceDimParameter_ReduceType_AVE;
const ReduceDimParameter_ReduceType ReduceDimParameter_ReduceType_ReduceType_MAX = ReduceDimParameter_ReduceType_SUM;
const int ReduceDimParameter_ReduceType_ReduceType_ARRAYSIZE = ReduceDimParameter_ReduceType_ReduceType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ReduceDimParameter_ReduceType_descriptor();
inline const ::std::string& ReduceDimParameter_ReduceType_Name(ReduceDimParameter_ReduceType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ReduceDimParameter_ReduceType_descriptor(), value);
}
inline bool ReduceDimParameter_ReduceType_Parse(
    const ::std::string& name, ReduceDimParameter_ReduceType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ReduceDimParameter_ReduceType>(
    ReduceDimParameter_ReduceType_descriptor(), name, value);
}
enum InstanceSampleParameter_SampleMethod {
  InstanceSampleParameter_SampleMethod_SEQ = 0,
  InstanceSampleParameter_SampleMethod_RAND = 1
};
bool InstanceSampleParameter_SampleMethod_IsValid(int value);
const InstanceSampleParameter_SampleMethod InstanceSampleParameter_SampleMethod_SampleMethod_MIN = InstanceSampleParameter_SampleMethod_SEQ;
const InstanceSampleParameter_SampleMethod InstanceSampleParameter_SampleMethod_SampleMethod_MAX = InstanceSampleParameter_SampleMethod_RAND;
const int InstanceSampleParameter_SampleMethod_SampleMethod_ARRAYSIZE = InstanceSampleParameter_SampleMethod_SampleMethod_MAX + 1;

const ::google::protobuf::EnumDescriptor* InstanceSampleParameter_SampleMethod_descriptor();
inline const ::std::string& InstanceSampleParameter_SampleMethod_Name(InstanceSampleParameter_SampleMethod value) {
  return ::google::protobuf::internal::NameOfEnum(
    InstanceSampleParameter_SampleMethod_descriptor(), value);
}
inline bool InstanceSampleParameter_SampleMethod_Parse(
    const ::std::string& name, InstanceSampleParameter_SampleMethod* value) {
  return ::google::protobuf::internal::ParseNamedEnum<InstanceSampleParameter_SampleMethod>(
    InstanceSampleParameter_SampleMethod_descriptor(), name, value);
}
// ===================================================================

class BlobProto : public ::google::protobuf::Message {
 public:
  BlobProto();
  virtual ~BlobProto();
  
  BlobProto(const BlobProto& from);
  
  inline BlobProto& operator=(const BlobProto& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const BlobProto& default_instance();
  
  void Swap(BlobProto* other);
  
  // implements Message ----------------------------------------------
  
  BlobProto* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BlobProto& from);
  void MergeFrom(const BlobProto& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 num = 1 [default = 0];
  inline bool has_num() const;
  inline void clear_num();
  static const int kNumFieldNumber = 1;
  inline ::google::protobuf::int32 num() const;
  inline void set_num(::google::protobuf::int32 value);
  
  // optional int32 channels = 2 [default = 0];
  inline bool has_channels() const;
  inline void clear_channels();
  static const int kChannelsFieldNumber = 2;
  inline ::google::protobuf::int32 channels() const;
  inline void set_channels(::google::protobuf::int32 value);
  
  // optional int32 height = 3 [default = 0];
  inline bool has_height() const;
  inline void clear_height();
  static const int kHeightFieldNumber = 3;
  inline ::google::protobuf::int32 height() const;
  inline void set_height(::google::protobuf::int32 value);
  
  // optional int32 width = 4 [default = 0];
  inline bool has_width() const;
  inline void clear_width();
  static const int kWidthFieldNumber = 4;
  inline ::google::protobuf::int32 width() const;
  inline void set_width(::google::protobuf::int32 value);
  
  // repeated float data = 5 [packed = true];
  inline int data_size() const;
  inline void clear_data();
  static const int kDataFieldNumber = 5;
  inline float data(int index) const;
  inline void set_data(int index, float value);
  inline void add_data(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      data() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_data();
  
  // repeated float diff = 6 [packed = true];
  inline int diff_size() const;
  inline void clear_diff();
  static const int kDiffFieldNumber = 6;
  inline float diff(int index) const;
  inline void set_diff(int index, float value);
  inline void add_diff(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      diff() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_diff();
  
  // @@protoc_insertion_point(class_scope:caffepro.BlobProto)
 private:
  inline void set_has_num();
  inline void clear_has_num();
  inline void set_has_channels();
  inline void clear_has_channels();
  inline void set_has_height();
  inline void clear_has_height();
  inline void set_has_width();
  inline void clear_has_width();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 num_;
  ::google::protobuf::int32 channels_;
  ::google::protobuf::int32 height_;
  ::google::protobuf::int32 width_;
  ::google::protobuf::RepeatedField< float > data_;
  mutable int _data_cached_byte_size_;
  ::google::protobuf::RepeatedField< float > diff_;
  mutable int _diff_cached_byte_size_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_caffe_2eproto();
  friend void protobuf_AssignDesc_caffe_2eproto();
  friend void protobuf_ShutdownFile_caffe_2eproto();
  
  void InitAsDefaultInstance();
  static BlobProto* default_instance_;
};
// -------------------------------------------------------------------

class BlobProtoVector : public ::google::protobuf::Message {
 public:
  BlobProtoVector();
  virtual ~BlobProtoVector();
  
  BlobProtoVector(const BlobProtoVector& from);
  
  inline BlobProtoVector& operator=(const BlobProtoVector& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const BlobProtoVector& default_instance();
  
  void Swap(BlobProtoVector* other);
  
  // implements Message ----------------------------------------------
  
  BlobProtoVector* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BlobProtoVector& from);
  void MergeFrom(const BlobProtoVector& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .caffepro.BlobProto blobs = 1;
  inline int blobs_size() const;
  inline void clear_blobs();
  static const int kBlobsFieldNumber = 1;
  inline const ::caffepro::BlobProto& blobs(int index) const;
  inline ::caffepro::BlobProto* mutable_blobs(int index);
  inline ::caffepro::BlobProto* add_blobs();
  inline const ::google::protobuf::RepeatedPtrField< ::caffepro::BlobProto >&
      blobs() const;
  inline ::google::protobuf::RepeatedPtrField< ::caffepro::BlobProto >*
      mutable_blobs();
  
  // @@protoc_insertion_point(class_scope:caffepro.BlobProtoVector)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::caffepro::BlobProto > blobs_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_caffe_2eproto();
  friend void protobuf_AssignDesc_caffe_2eproto();
  friend void protobuf_ShutdownFile_caffe_2eproto();
  
  void InitAsDefaultInstance();
  static BlobProtoVector* default_instance_;
};
// -------------------------------------------------------------------

class Datum : public ::google::protobuf::Message {
 public:
  Datum();
  virtual ~Datum();
  
  Datum(const Datum& from);
  
  inline Datum& operator=(const Datum& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Datum& default_instance();
  
  void Swap(Datum* other);
  
  // implements Message ----------------------------------------------
  
  Datum* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Datum& from);
  void MergeFrom(const Datum& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 channels = 1;
  inline bool has_channels() const;
  inline void clear_channels();
  static const int kChannelsFieldNumber = 1;
  inline ::google::protobuf::int32 channels() const;
  inline void set_channels(::google::protobuf::int32 value);
  
  // optional int32 height = 2;
  inline bool has_height() const;
  inline void clear_height();
  static const int kHeightFieldNumber = 2;
  inline ::google::protobuf::int32 height() const;
  inline void set_height(::google::protobuf::int32 value);
  
  // optional int32 width = 3;
  inline bool has_width() const;
  inline void clear_width();
  static const int kWidthFieldNumber = 3;
  inline ::google::protobuf::int32 width() const;
  inline void set_width(::google::protobuf::int32 value);
  
  // optional bytes data = 4;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 4;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  
  // optional int32 label = 5;
  inline bool has_label() const;
  inline void clear_label();
  static const int kLabelFieldNumber = 5;
  inline ::google::protobuf::int32 label() const;
  inline void set_label(::google::protobuf::int32 value);
  
  // repeated float float_data = 6;
  inline int float_data_size() const;
  inline void clear_float_data();
  static const int kFloatDataFieldNumber = 6;
  inline float float_data(int index) const;
  inline void set_float_data(int index, float value);
  inline void add_float_data(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      float_data() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_float_data();
  
  // @@protoc_insertion_point(class_scope:caffepro.Datum)
 private:
  inline void set_has_channels();
  inline void clear_has_channels();
  inline void set_has_height();
  inline void clear_has_height();
  inline void set_has_width();
  inline void clear_has_width();
  inline void set_has_data();
  inline void clear_has_data();
  inline void set_has_label();
  inline void clear_has_label();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 channels_;
  ::google::protobuf::int32 height_;
  ::std::string* data_;
  ::google::protobuf::int32 width_;
  ::google::protobuf::int32 label_;
  ::google::protobuf::RepeatedField< float > float_data_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_caffe_2eproto();
  friend void protobuf_AssignDesc_caffe_2eproto();
  friend void protobuf_ShutdownFile_caffe_2eproto();
  
  void InitAsDefaultInstance();
  static Datum* default_instance_;
};
// -------------------------------------------------------------------

class FillerParameter : public ::google::protobuf::Message {
 public:
  FillerParameter();
  virtual ~FillerParameter();
  
  FillerParameter(const FillerParameter& from);
  
  inline FillerParameter& operator=(const FillerParameter& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const FillerParameter& default_instance();
  
  void Swap(FillerParameter* other);
  
  // implements Message ----------------------------------------------
  
  FillerParameter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FillerParameter& from);
  void MergeFrom(const FillerParameter& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string type = 1 [default = "constant"];
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const char* value, size_t size);
  inline ::std::string* mutable_type();
  inline ::std::string* release_type();
  
  // optional float value = 2 [default = 0];
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline float value() const;
  inline void set_value(float value);
  
  // optional float min = 3 [default = 0];
  inline bool has_min() const;
  inline void clear_min();
  static const int kMinFieldNumber = 3;
  inline float min() const;
  inline void set_min(float value);
  
  // optional float max = 4 [default = 1];
  inline bool has_max() const;
  inline void clear_max();
  static const int kMaxFieldNumber = 4;
  inline float max() const;
  inline void set_max(float value);
  
  // optional float mean = 5 [default = 0];
  inline bool has_mean() const;
  inline void clear_mean();
  static const int kMeanFieldNumber = 5;
  inline float mean() const;
  inline void set_mean(float value);
  
  // optional float std = 6 [default = 1];
  inline bool has_std() const;
  inline void clear_std();
  static const int kStdFieldNumber = 6;
  inline float std() const;
  inline void set_std(float value);
  
  // @@protoc_insertion_point(class_scope:caffepro.FillerParameter)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_value();
  inline void clear_has_value();
  inline void set_has_min();
  inline void clear_has_min();
  inline void set_has_max();
  inline void clear_has_max();
  inline void set_has_mean();
  inline void clear_has_mean();
  inline void set_has_std();
  inline void clear_has_std();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* type_;
  static const ::std::string _default_type_;
  float value_;
  float min_;
  float max_;
  float mean_;
  float std_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_caffe_2eproto();
  friend void protobuf_AssignDesc_caffe_2eproto();
  friend void protobuf_ShutdownFile_caffe_2eproto();
  
  void InitAsDefaultInstance();
  static FillerParameter* default_instance_;
};
// -------------------------------------------------------------------

class LayerParameter : public ::google::protobuf::Message {
 public:
  LayerParameter();
  virtual ~LayerParameter();
  
  LayerParameter(const LayerParameter& from);
  
  inline LayerParameter& operator=(const LayerParameter& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const LayerParameter& default_instance();
  
  void Swap(LayerParameter* other);
  
  // implements Message ----------------------------------------------
  
  LayerParameter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LayerParameter& from);
  void MergeFrom(const LayerParameter& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef LayerParameter_UpdateMethod UpdateMethod;
  static const UpdateMethod NORMAL = LayerParameter_UpdateMethod_NORMAL;
  static const UpdateMethod ADAGRAD = LayerParameter_UpdateMethod_ADAGRAD;
  static const UpdateMethod ADAGRAD_RECORD_ONLY = LayerParameter_UpdateMethod_ADAGRAD_RECORD_ONLY;
  static inline bool UpdateMethod_IsValid(int value) {
    return LayerParameter_UpdateMethod_IsValid(value);
  }
  static const UpdateMethod UpdateMethod_MIN =
    LayerParameter_UpdateMethod_UpdateMethod_MIN;
  static const UpdateMethod UpdateMethod_MAX =
    LayerParameter_UpdateMethod_UpdateMethod_MAX;
  static const int UpdateMethod_ARRAYSIZE =
    LayerParameter_UpdateMethod_UpdateMethod_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  UpdateMethod_descriptor() {
    return LayerParameter_UpdateMethod_descriptor();
  }
  static inline const ::std::string& UpdateMethod_Name(UpdateMethod value) {
    return LayerParameter_UpdateMethod_Name(value);
  }
  static inline bool UpdateMethod_Parse(const ::std::string& name,
      UpdateMethod* value) {
    return LayerParameter_UpdateMethod_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // optional string type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const char* value, size_t size);
  inline ::std::string* mutable_type();
  inline ::std::string* release_type();
  
  // repeated .caffepro.BlobProto blobs = 3;
  inline int blobs_size() const;
  inline void clear_blobs();
  static const int kBlobsFieldNumber = 3;
  inline const ::caffepro::BlobProto& blobs(int index) const;
  inline ::caffepro::BlobProto* mutable_blobs(int index);
  inline ::caffepro::BlobProto* add_blobs();
  inline const ::google::protobuf::RepeatedPtrField< ::caffepro::BlobProto >&
      blobs() const;
  inline ::google::protobuf::RepeatedPtrField< ::caffepro::BlobProto >*
      mutable_blobs();
  
  // repeated float blobs_lr = 4;
  inline int blobs_lr_size() const;
  inline void clear_blobs_lr();
  static const int kBlobsLrFieldNumber = 4;
  inline float blobs_lr(int index) const;
  inline void set_blobs_lr(int index, float value);
  inline void add_blobs_lr(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      blobs_lr() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_blobs_lr();
  
  // repeated float weight_decay = 5;
  inline int weight_decay_size() const;
  inline void clear_weight_decay();
  static const int kWeightDecayFieldNumber = 5;
  inline float weight_decay(int index) const;
  inline void set_weight_decay(int index, float value);
  inline void add_weight_decay(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      weight_decay() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_weight_decay();
  
  // repeated string blob_source_layer = 6;
  inline int blob_source_layer_size() const;
  inline void clear_blob_source_layer();
  static const int kBlobSourceLayerFieldNumber = 6;
  inline const ::std::string& blob_source_layer(int index) const;
  inline ::std::string* mutable_blob_source_layer(int index);
  inline void set_blob_source_layer(int index, const ::std::string& value);
  inline void set_blob_source_layer(int index, const char* value);
  inline void set_blob_source_layer(int index, const char* value, size_t size);
  inline ::std::string* add_blob_source_layer();
  inline void add_blob_source_layer(const ::std::string& value);
  inline void add_blob_source_layer(const char* value);
  inline void add_blob_source_layer(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& blob_source_layer() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_blob_source_layer();
  
  // optional .caffepro.ConcatParameter concat_param = 8;
  inline bool has_concat_param() const;
  inline void clear_concat_param();
  static const int kConcatParamFieldNumber = 8;
  inline const ::caffepro::ConcatParameter& concat_param() const;
  inline ::caffepro::ConcatParameter* mutable_concat_param();
  inline ::caffepro::ConcatParameter* release_concat_param();
  
  // optional .caffepro.ConvolutionParameter conv_param = 9;
  inline bool has_conv_param() const;
  inline void clear_conv_param();
  static const int kConvParamFieldNumber = 9;
  inline const ::caffepro::ConvolutionParameter& conv_param() const;
  inline ::caffepro::ConvolutionParameter* mutable_conv_param();
  inline ::caffepro::ConvolutionParameter* release_conv_param();
  
  // optional .caffepro.DataParameter_BigFile data_bigfile_param = 11;
  inline bool has_data_bigfile_param() const;
  inline void clear_data_bigfile_param();
  static const int kDataBigfileParamFieldNumber = 11;
  inline const ::caffepro::DataParameter_BigFile& data_bigfile_param() const;
  inline ::caffepro::DataParameter_BigFile* mutable_data_bigfile_param();
  inline ::caffepro::DataParameter_BigFile* release_data_bigfile_param();
  
  // optional .caffepro.DropoutParameter dropout_param = 12;
  inline bool has_dropout_param() const;
  inline void clear_dropout_param();
  static const int kDropoutParamFieldNumber = 12;
  inline const ::caffepro::DropoutParameter& dropout_param() const;
  inline ::caffepro::DropoutParameter* mutable_dropout_param();
  inline ::caffepro::DropoutParameter* release_dropout_param();
  
  // optional .caffepro.InfogainLossParameter infogain_loss_param = 16;
  inline bool has_infogain_loss_param() const;
  inline void clear_infogain_loss_param();
  static const int kInfogainLossParamFieldNumber = 16;
  inline const ::caffepro::InfogainLossParameter& infogain_loss_param() const;
  inline ::caffepro::InfogainLossParameter* mutable_infogain_loss_param();
  inline ::caffepro::InfogainLossParameter* release_infogain_loss_param();
  
  // optional .caffepro.InnerProductParameter inner_product_param = 17;
  inline bool has_inner_product_param() const;
  inline void clear_inner_product_param();
  static const int kInnerProductParamFieldNumber = 17;
  inline const ::caffepro::InnerProductParameter& inner_product_param() const;
  inline ::caffepro::InnerProductParameter* mutable_inner_product_param();
  inline ::caffepro::InnerProductParameter* release_inner_product_param();
  
  // optional .caffepro.LRNParameter lrn_param = 18;
  inline bool has_lrn_param() const;
  inline void clear_lrn_param();
  static const int kLrnParamFieldNumber = 18;
  inline const ::caffepro::LRNParameter& lrn_param() const;
  inline ::caffepro::LRNParameter* mutable_lrn_param();
  inline ::caffepro::LRNParameter* release_lrn_param();
  
  // optional .caffepro.PoolingParameter pool_param = 19;
  inline bool has_pool_param() const;
  inline void clear_pool_param();
  static const int kPoolParamFieldNumber = 19;
  inline const ::caffepro::PoolingParameter& pool_param() const;
  inline ::caffepro::PoolingParameter* mutable_pool_param();
  inline ::caffepro::PoolingParameter* release_pool_param();
  
  // optional .caffepro.PowerParameter power_param = 20;
  inline bool has_power_param() const;
  inline void clear_power_param();
  static const int kPowerParamFieldNumber = 20;
  inline const ::caffepro::PowerParameter& power_param() const;
  inline ::caffepro::PowerParameter* mutable_power_param();
  inline ::caffepro::PowerParameter* release_power_param();
  
  // optional .caffepro.PaddingParameter padding_param = 23;
  inline bool has_padding_param() const;
  inline void clear_padding_param();
  static const int kPaddingParamFieldNumber = 23;
  inline const ::caffepro::PaddingParameter& padding_param() const;
  inline ::caffepro::PaddingParameter* mutable_padding_param();
  inline ::caffepro::PaddingParameter* release_padding_param();
  
  // optional .caffepro.SPMParameter spm_param = 24;
  inline bool has_spm_param() const;
  inline void clear_spm_param();
  static const int kSpmParamFieldNumber = 24;
  inline const ::caffepro::SPMParameter& spm_param() const;
  inline ::caffepro::SPMParameter* mutable_spm_param();
  inline ::caffepro::SPMParameter* release_spm_param();
  
  // optional int32 gpu_id = 30 [default = -1];
  inline bool has_gpu_id() const;
  inline void clear_gpu_id();
  static const int kGpuIdFieldNumber = 30;
  inline ::google::protobuf::int32 gpu_id() const;
  inline void set_gpu_id(::google::protobuf::int32 value);
  
  // optional .caffepro.GPUSplitParameter gpu_split = 31;
  inline bool has_gpu_split() const;
  inline void clear_gpu_split();
  static const int kGpuSplitFieldNumber = 31;
  inline const ::caffepro::GPUSplitParameter& gpu_split() const;
  inline ::caffepro::GPUSplitParameter* mutable_gpu_split();
  inline ::caffepro::GPUSplitParameter* release_gpu_split();
  
  // optional .caffepro.LossParameter loss_param = 34;
  inline bool has_loss_param() const;
  inline void clear_loss_param();
  static const int kLossParamFieldNumber = 34;
  inline const ::caffepro::LossParameter& loss_param() const;
  inline ::caffepro::LossParameter* mutable_loss_param();
  inline ::caffepro::LossParameter* release_loss_param();
  
  // optional bool record = 35 [default = false];
  inline bool has_record() const;
  inline void clear_record();
  static const int kRecordFieldNumber = 35;
  inline bool record() const;
  inline void set_record(bool value);
  
  // optional .caffepro.ReluParameter relu_param = 36;
  inline bool has_relu_param() const;
  inline void clear_relu_param();
  static const int kReluParamFieldNumber = 36;
  inline const ::caffepro::ReluParameter& relu_param() const;
  inline ::caffepro::ReluParameter* mutable_relu_param();
  inline ::caffepro::ReluParameter* release_relu_param();
  
  // optional .caffepro.LearnableLeakReluParameter learnable_leak_relu_param = 37;
  inline bool has_learnable_leak_relu_param() const;
  inline void clear_learnable_leak_relu_param();
  static const int kLearnableLeakReluParamFieldNumber = 37;
  inline const ::caffepro::LearnableLeakReluParameter& learnable_leak_relu_param() const;
  inline ::caffepro::LearnableLeakReluParameter* mutable_learnable_leak_relu_param();
  inline ::caffepro::LearnableLeakReluParameter* release_learnable_leak_relu_param();
  
  // repeated .caffepro.LayerParameter.UpdateMethod update_method = 38;
  inline int update_method_size() const;
  inline void clear_update_method();
  static const int kUpdateMethodFieldNumber = 38;
  inline ::caffepro::LayerParameter_UpdateMethod update_method(int index) const;
  inline void set_update_method(int index, ::caffepro::LayerParameter_UpdateMethod value);
  inline void add_update_method(::caffepro::LayerParameter_UpdateMethod value);
  inline const ::google::protobuf::RepeatedField<int>& update_method() const;
  inline ::google::protobuf::RepeatedField<int>* mutable_update_method();
  
  // optional .caffepro.BatchNormalizationParameter batch_norm_param = 40;
  inline bool has_batch_norm_param() const;
  inline void clear_batch_norm_param();
  static const int kBatchNormParamFieldNumber = 40;
  inline const ::caffepro::BatchNormalizationParameter& batch_norm_param() const;
  inline ::caffepro::BatchNormalizationParameter* mutable_batch_norm_param();
  inline ::caffepro::BatchNormalizationParameter* release_batch_norm_param();
  
  // optional bool record_internel = 41 [default = false];
  inline bool has_record_internel() const;
  inline void clear_record_internel();
  static const int kRecordInternelFieldNumber = 41;
  inline bool record_internel() const;
  inline void set_record_internel(bool value);
  
  // optional .caffepro.EltwiseSumParameter eltwise_sum_param = 44;
  inline bool has_eltwise_sum_param() const;
  inline void clear_eltwise_sum_param();
  static const int kEltwiseSumParamFieldNumber = 44;
  inline const ::caffepro::EltwiseSumParameter& eltwise_sum_param() const;
  inline ::caffepro::EltwiseSumParameter* mutable_eltwise_sum_param();
  inline ::caffepro::EltwiseSumParameter* release_eltwise_sum_param();
  
  // optional .caffepro.ClsLocLossParameter clsloc_loss_param = 48;
  inline bool has_clsloc_loss_param() const;
  inline void clear_clsloc_loss_param();
  static const int kClslocLossParamFieldNumber = 48;
  inline const ::caffepro::ClsLocLossParameter& clsloc_loss_param() const;
  inline ::caffepro::ClsLocLossParameter* mutable_clsloc_loss_param();
  inline ::caffepro::ClsLocLossParameter* release_clsloc_loss_param();
  
  // optional .caffepro.AnchorParameter anchor_param = 49;
  inline bool has_anchor_param() const;
  inline void clear_anchor_param();
  static const int kAnchorParamFieldNumber = 49;
  inline const ::caffepro::AnchorParameter& anchor_param() const;
  inline ::caffepro::AnchorParameter* mutable_anchor_param();
  inline ::caffepro::AnchorParameter* release_anchor_param();
  
  // optional .caffepro.GridGeneratorParameter grid_generator_param = 52;
  inline bool has_grid_generator_param() const;
  inline void clear_grid_generator_param();
  static const int kGridGeneratorParamFieldNumber = 52;
  inline const ::caffepro::GridGeneratorParameter& grid_generator_param() const;
  inline ::caffepro::GridGeneratorParameter* mutable_grid_generator_param();
  inline ::caffepro::GridGeneratorParameter* release_grid_generator_param();
  
  // optional .caffepro.DataEntryParameter data_entry_param = 53;
  inline bool has_data_entry_param() const;
  inline void clear_data_entry_param();
  static const int kDataEntryParamFieldNumber = 53;
  inline const ::caffepro::DataEntryParameter& data_entry_param() const;
  inline ::caffepro::DataEntryParameter* mutable_data_entry_param();
  inline ::caffepro::DataEntryParameter* release_data_entry_param();
  
  // optional .caffepro.SampleParameter sample_param = 54;
  inline bool has_sample_param() const;
  inline void clear_sample_param();
  static const int kSampleParamFieldNumber = 54;
  inline const ::caffepro::SampleParameter& sample_param() const;
  inline ::caffepro::SampleParameter* mutable_sample_param();
  inline ::caffepro::SampleParameter* release_sample_param();
  
  // optional string share_weights = 55;
  inline bool has_share_weights() const;
  inline void clear_share_weights();
  static const int kShareWeightsFieldNumber = 55;
  inline const ::std::string& share_weights() const;
  inline void set_share_weights(const ::std::string& value);
  inline void set_share_weights(const char* value);
  inline void set_share_weights(const char* value, size_t size);
  inline ::std::string* mutable_share_weights();
  inline ::std::string* release_share_weights();
  
  // optional .caffepro.ExpParameter exp_param = 56;
  inline bool has_exp_param() const;
  inline void clear_exp_param();
  static const int kExpParamFieldNumber = 56;
  inline const ::caffepro::ExpParameter& exp_param() const;
  inline ::caffepro::ExpParameter* mutable_exp_param();
  inline ::caffepro::ExpParameter* release_exp_param();
  
  // optional .caffepro.BoundParameter bound_param = 57;
  inline bool has_bound_param() const;
  inline void clear_bound_param();
  static const int kBoundParamFieldNumber = 57;
  inline const ::caffepro::BoundParameter& bound_param() const;
  inline ::caffepro::BoundParameter* mutable_bound_param();
  inline ::caffepro::BoundParameter* release_bound_param();
  
  // optional .caffepro.ClusterParameter cluster_param = 58;
  inline bool has_cluster_param() const;
  inline void clear_cluster_param();
  static const int kClusterParamFieldNumber = 58;
  inline const ::caffepro::ClusterParameter& cluster_param() const;
  inline ::caffepro::ClusterParameter* mutable_cluster_param();
  inline ::caffepro::ClusterParameter* release_cluster_param();
  
  // optional .caffepro.OnlineKMeansParameter online_kmeans_param = 59;
  inline bool has_online_kmeans_param() const;
  inline void clear_online_kmeans_param();
  static const int kOnlineKmeansParamFieldNumber = 59;
  inline const ::caffepro::OnlineKMeansParameter& online_kmeans_param() const;
  inline ::caffepro::OnlineKMeansParameter* mutable_online_kmeans_param();
  inline ::caffepro::OnlineKMeansParameter* release_online_kmeans_param();
  
  // optional .caffepro.CorrelationParameter correlation_param = 60;
  inline bool has_correlation_param() const;
  inline void clear_correlation_param();
  static const int kCorrelationParamFieldNumber = 60;
  inline const ::caffepro::CorrelationParameter& correlation_param() const;
  inline ::caffepro::CorrelationParameter* mutable_correlation_param();
  inline ::caffepro::CorrelationParameter* release_correlation_param();
  
  // optional .caffepro.WeightParameter weight_param = 61;
  inline bool has_weight_param() const;
  inline void clear_weight_param();
  static const int kWeightParamFieldNumber = 61;
  inline const ::caffepro::WeightParameter& weight_param() const;
  inline ::caffepro::WeightParameter* mutable_weight_param();
  inline ::caffepro::WeightParameter* release_weight_param();
  
  // optional .caffepro.ScaleBiasParameter scalebias_param = 62;
  inline bool has_scalebias_param() const;
  inline void clear_scalebias_param();
  static const int kScalebiasParamFieldNumber = 62;
  inline const ::caffepro::ScaleBiasParameter& scalebias_param() const;
  inline ::caffepro::ScaleBiasParameter* mutable_scalebias_param();
  inline ::caffepro::ScaleBiasParameter* release_scalebias_param();
  
  // optional .caffepro.CropParameter crop_param = 63;
  inline bool has_crop_param() const;
  inline void clear_crop_param();
  static const int kCropParamFieldNumber = 63;
  inline const ::caffepro::CropParameter& crop_param() const;
  inline ::caffepro::CropParameter* mutable_crop_param();
  inline ::caffepro::CropParameter* release_crop_param();
  
  // optional .caffepro.ReduceDimParameter reduce_dim_param = 64;
  inline bool has_reduce_dim_param() const;
  inline void clear_reduce_dim_param();
  static const int kReduceDimParamFieldNumber = 64;
  inline const ::caffepro::ReduceDimParameter& reduce_dim_param() const;
  inline ::caffepro::ReduceDimParameter* mutable_reduce_dim_param();
  inline ::caffepro::ReduceDimParameter* release_reduce_dim_param();
  
  // optional .caffepro.FlipParameter flip_param = 65;
  inline bool has_flip_param() const;
  inline void clear_flip_param();
  static const int kFlipParamFieldNumber = 65;
  inline const ::caffepro::FlipParameter& flip_param() const;
  inline ::caffepro::FlipParameter* mutable_flip_param();
  inline ::caffepro::FlipParameter* release_flip_param();
  
  // optional .caffepro.StepGateParameter step_gate_param = 66;
  inline bool has_step_gate_param() const;
  inline void clear_step_gate_param();
  static const int kStepGateParamFieldNumber = 66;
  inline const ::caffepro::StepGateParameter& step_gate_param() const;
  inline ::caffepro::StepGateParameter* mutable_step_gate_param();
  inline ::caffepro::StepGateParameter* release_step_gate_param();
  
  // optional .caffepro.HouseholderParameter householder_param = 67;
  inline bool has_householder_param() const;
  inline void clear_householder_param();
  static const int kHouseholderParamFieldNumber = 67;
  inline const ::caffepro::HouseholderParameter& householder_param() const;
  inline ::caffepro::HouseholderParameter* mutable_householder_param();
  inline ::caffepro::HouseholderParameter* release_householder_param();
  
  // optional .caffepro.InstanceSampleParameter instance_sample_param = 68;
  inline bool has_instance_sample_param() const;
  inline void clear_instance_sample_param();
  static const int kInstanceSampleParamFieldNumber = 68;
  inline const ::caffepro::InstanceSampleParameter& instance_sample_param() const;
  inline ::caffepro::InstanceSampleParameter* mutable_instance_sample_param();
  inline ::caffepro::InstanceSampleParameter* release_instance_sample_param();
  
  // optional .caffepro.MatrixMulParameter matrix_mul_param = 69;
  inline bool has_matrix_mul_param() const;
  inline void clear_matrix_mul_param();
  static const int kMatrixMulParamFieldNumber = 69;
  inline const ::caffepro::MatrixMulParameter& matrix_mul_param() const;
  inline ::caffepro::MatrixMulParameter* mutable_matrix_mul_param();
  inline ::caffepro::MatrixMulParameter* release_matrix_mul_param();
  
  // optional .caffepro.MatrixMulStackParameter matrix_mul_stack_param = 70;
  inline bool has_matrix_mul_stack_param() const;
  inline void clear_matrix_mul_stack_param();
  static const int kMatrixMulStackParamFieldNumber = 70;
  inline const ::caffepro::MatrixMulStackParameter& matrix_mul_stack_param() const;
  inline ::caffepro::MatrixMulStackParameter* mutable_matrix_mul_stack_param();
  inline ::caffepro::MatrixMulStackParameter* release_matrix_mul_stack_param();
  
  // optional .caffepro.TransposeParameter transpose_param = 71;
  inline bool has_transpose_param() const;
  inline void clear_transpose_param();
  static const int kTransposeParamFieldNumber = 71;
  inline const ::caffepro::TransposeParameter& transpose_param() const;
  inline ::caffepro::TransposeParameter* mutable_transpose_param();
  inline ::caffepro::TransposeParameter* release_transpose_param();
  
  // optional .caffepro.ReshapeParameter reshape_param = 72;
  inline bool has_reshape_param() const;
  inline void clear_reshape_param();
  static const int kReshapeParamFieldNumber = 72;
  inline const ::caffepro::ReshapeParameter& reshape_param() const;
  inline ::caffepro::ReshapeParameter* mutable_reshape_param();
  inline ::caffepro::ReshapeParameter* release_reshape_param();
  
  // optional .caffepro.LearnableDropoutParameter learnable_dropout_param = 73;
  inline bool has_learnable_dropout_param() const;
  inline void clear_learnable_dropout_param();
  static const int kLearnableDropoutParamFieldNumber = 73;
  inline const ::caffepro::LearnableDropoutParameter& learnable_dropout_param() const;
  inline ::caffepro::LearnableDropoutParameter* mutable_learnable_dropout_param();
  inline ::caffepro::LearnableDropoutParameter* release_learnable_dropout_param();
  
  // optional .caffepro.DimInnerProductParameter dim_innerproduct_param = 74;
  inline bool has_dim_innerproduct_param() const;
  inline void clear_dim_innerproduct_param();
  static const int kDimInnerproductParamFieldNumber = 74;
  inline const ::caffepro::DimInnerProductParameter& dim_innerproduct_param() const;
  inline ::caffepro::DimInnerProductParameter* mutable_dim_innerproduct_param();
  inline ::caffepro::DimInnerProductParameter* release_dim_innerproduct_param();
  
  // optional .caffepro.SoftthrParameter softthr_param = 75;
  inline bool has_softthr_param() const;
  inline void clear_softthr_param();
  static const int kSoftthrParamFieldNumber = 75;
  inline const ::caffepro::SoftthrParameter& softthr_param() const;
  inline ::caffepro::SoftthrParameter* mutable_softthr_param();
  inline ::caffepro::SoftthrParameter* release_softthr_param();
  
  // optional .caffepro.DropoutParameter dropoutsame_param = 76;
  inline bool has_dropoutsame_param() const;
  inline void clear_dropoutsame_param();
  static const int kDropoutsameParamFieldNumber = 76;
  inline const ::caffepro::DropoutParameter& dropoutsame_param() const;
  inline ::caffepro::DropoutParameter* mutable_dropoutsame_param();
  inline ::caffepro::DropoutParameter* release_dropoutsame_param();
  
  // optional .caffepro.SoftMaxLossOHEMParameter softmaxlossohem_param = 77;
  inline bool has_softmaxlossohem_param() const;
  inline void clear_softmaxlossohem_param();
  static const int kSoftmaxlossohemParamFieldNumber = 77;
  inline const ::caffepro::SoftMaxLossOHEMParameter& softmaxlossohem_param() const;
  inline ::caffepro::SoftMaxLossOHEMParameter* mutable_softmaxlossohem_param();
  inline ::caffepro::SoftMaxLossOHEMParameter* release_softmaxlossohem_param();
  
  // optional .caffepro.SoftMaxOHEMParameter softmaxohem_param = 78;
  inline bool has_softmaxohem_param() const;
  inline void clear_softmaxohem_param();
  static const int kSoftmaxohemParamFieldNumber = 78;
  inline const ::caffepro::SoftMaxOHEMParameter& softmaxohem_param() const;
  inline ::caffepro::SoftMaxOHEMParameter* mutable_softmaxohem_param();
  inline ::caffepro::SoftMaxOHEMParameter* release_softmaxohem_param();
  
  // optional .caffepro.SoftMaxOHEMSplitParameter softmaxohemsplit_param = 79;
  inline bool has_softmaxohemsplit_param() const;
  inline void clear_softmaxohemsplit_param();
  static const int kSoftmaxohemsplitParamFieldNumber = 79;
  inline const ::caffepro::SoftMaxOHEMSplitParameter& softmaxohemsplit_param() const;
  inline ::caffepro::SoftMaxOHEMSplitParameter* mutable_softmaxohemsplit_param();
  inline ::caffepro::SoftMaxOHEMSplitParameter* release_softmaxohemsplit_param();
  
  // optional .caffepro.DiagOperationParameter diag_operation_param = 80;
  inline bool has_diag_operation_param() const;
  inline void clear_diag_operation_param();
  static const int kDiagOperationParamFieldNumber = 80;
  inline const ::caffepro::DiagOperationParameter& diag_operation_param() const;
  inline ::caffepro::DiagOperationParameter* mutable_diag_operation_param();
  inline ::caffepro::DiagOperationParameter* release_diag_operation_param();
  
  // @@protoc_insertion_point(class_scope:caffepro.LayerParameter)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_concat_param();
  inline void clear_has_concat_param();
  inline void set_has_conv_param();
  inline void clear_has_conv_param();
  inline void set_has_data_bigfile_param();
  inline void clear_has_data_bigfile_param();
  inline void set_has_dropout_param();
  inline void clear_has_dropout_param();
  inline void set_has_infogain_loss_param();
  inline void clear_has_infogain_loss_param();
  inline void set_has_inner_product_param();
  inline void clear_has_inner_product_param();
  inline void set_has_lrn_param();
  inline void clear_has_lrn_param();
  inline void set_has_pool_param();
  inline void clear_has_pool_param();
  inline void set_has_power_param();
  inline void clear_has_power_param();
  inline void set_has_padding_param();
  inline void clear_has_padding_param();
  inline void set_has_spm_param();
  inline void clear_has_spm_param();
  inline void set_has_gpu_id();
  inline void clear_has_gpu_id();
  inline void set_has_gpu_split();
  inline void clear_has_gpu_split();
  inline void set_has_loss_param();
  inline void clear_has_loss_param();
  inline void set_has_record();
  inline void clear_has_record();
  inline void set_has_relu_param();
  inline void clear_has_relu_param();
  inline void set_has_learnable_leak_relu_param();
  inline void clear_has_learnable_leak_relu_param();
  inline void set_has_batch_norm_param();
  inline void clear_has_batch_norm_param();
  inline void set_has_record_internel();
  inline void clear_has_record_internel();
  inline void set_has_eltwise_sum_param();
  inline void clear_has_eltwise_sum_param();
  inline void set_has_clsloc_loss_param();
  inline void clear_has_clsloc_loss_param();
  inline void set_has_anchor_param();
  inline void clear_has_anchor_param();
  inline void set_has_grid_generator_param();
  inline void clear_has_grid_generator_param();
  inline void set_has_data_entry_param();
  inline void clear_has_data_entry_param();
  inline void set_has_sample_param();
  inline void clear_has_sample_param();
  inline void set_has_share_weights();
  inline void clear_has_share_weights();
  inline void set_has_exp_param();
  inline void clear_has_exp_param();
  inline void set_has_bound_param();
  inline void clear_has_bound_param();
  inline void set_has_cluster_param();
  inline void clear_has_cluster_param();
  inline void set_has_online_kmeans_param();
  inline void clear_has_online_kmeans_param();
  inline void set_has_correlation_param();
  inline void clear_has_correlation_param();
  inline void set_has_weight_param();
  inline void clear_has_weight_param();
  inline void set_has_scalebias_param();
  inline void clear_has_scalebias_param();
  inline void set_has_crop_param();
  inline void clear_has_crop_param();
  inline void set_has_reduce_dim_param();
  inline void clear_has_reduce_dim_param();
  inline void set_has_flip_param();
  inline void clear_has_flip_param();
  inline void set_has_step_gate_param();
  inline void clear_has_step_gate_param();
  inline void set_has_householder_param();
  inline void clear_has_householder_param();
  inline void set_has_instance_sample_param();
  inline void clear_has_instance_sample_param();
  inline void set_has_matrix_mul_param();
  inline void clear_has_matrix_mul_param();
  inline void set_has_matrix_mul_stack_param();
  inline void clear_has_matrix_mul_stack_param();
  inline void set_has_transpose_param();
  inline void clear_has_transpose_param();
  inline void set_has_reshape_param();
  inline void clear_has_reshape_param();
  inline void set_has_learnable_dropout_param();
  inline void clear_has_learnable_dropout_param();
  inline void set_has_dim_innerproduct_param();
  inline void clear_has_dim_innerproduct_param();
  inline void set_has_softthr_param();
  inline void clear_has_softthr_param();
  inline void set_has_dropoutsame_param();
  inline void clear_has_dropoutsame_param();
  inline void set_has_softmaxlossohem_param();
  inline void clear_has_softmaxlossohem_param();
  inline void set_has_softmaxohem_param();
  inline void clear_has_softmaxohem_param();
  inline void set_has_softmaxohemsplit_param();
  inline void clear_has_softmaxohemsplit_param();
  inline void set_has_diag_operation_param();
  inline void clear_has_diag_operation_param();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* name_;
  ::std::string* type_;
  ::google::protobuf::RepeatedPtrField< ::caffepro::BlobProto > blobs_;
  ::google::protobuf::RepeatedField< float > blobs_lr_;
  ::google::protobuf::RepeatedField< float > weight_decay_;
  ::google::protobuf::RepeatedPtrField< ::std::string> blob_source_layer_;
  ::caffepro::ConcatParameter* concat_param_;
  ::caffepro::ConvolutionParameter* conv_param_;
  ::caffepro::DataParameter_BigFile* data_bigfile_param_;
  ::caffepro::DropoutParameter* dropout_param_;
  ::caffepro::InfogainLossParameter* infogain_loss_param_;
  ::caffepro::InnerProductParameter* inner_product_param_;
  ::caffepro::LRNParameter* lrn_param_;
  ::caffepro::PoolingParameter* pool_param_;
  ::caffepro::PowerParameter* power_param_;
  ::caffepro::PaddingParameter* padding_param_;
  ::caffepro::SPMParameter* spm_param_;
  ::caffepro::GPUSplitParameter* gpu_split_;
  ::caffepro::LossParameter* loss_param_;
  ::google::protobuf::int32 gpu_id_;
  bool record_;
  bool record_internel_;
  ::caffepro::ReluParameter* relu_param_;
  ::caffepro::LearnableLeakReluParameter* learnable_leak_relu_param_;
  ::google::protobuf::RepeatedField<int> update_method_;
  ::caffepro::BatchNormalizationParameter* batch_norm_param_;
  ::caffepro::EltwiseSumParameter* eltwise_sum_param_;
  ::caffepro::ClsLocLossParameter* clsloc_loss_param_;
  ::caffepro::AnchorParameter* anchor_param_;
  ::caffepro::GridGeneratorParameter* grid_generator_param_;
  ::caffepro::DataEntryParameter* data_entry_param_;
  ::caffepro::SampleParameter* sample_param_;
  ::std::string* share_weights_;
  ::caffepro::ExpParameter* exp_param_;
  ::caffepro::BoundParameter* bound_param_;
  ::caffepro::ClusterParameter* cluster_param_;
  ::caffepro::OnlineKMeansParameter* online_kmeans_param_;
  ::caffepro::CorrelationParameter* correlation_param_;
  ::caffepro::WeightParameter* weight_param_;
  ::caffepro::ScaleBiasParameter* scalebias_param_;
  ::caffepro::CropParameter* crop_param_;
  ::caffepro::ReduceDimParameter* reduce_dim_param_;
  ::caffepro::FlipParameter* flip_param_;
  ::caffepro::StepGateParameter* step_gate_param_;
  ::caffepro::HouseholderParameter* householder_param_;
  ::caffepro::InstanceSampleParameter* instance_sample_param_;
  ::caffepro::MatrixMulParameter* matrix_mul_param_;
  ::caffepro::MatrixMulStackParameter* matrix_mul_stack_param_;
  ::caffepro::TransposeParameter* transpose_param_;
  ::caffepro::ReshapeParameter* reshape_param_;
  ::caffepro::LearnableDropoutParameter* learnable_dropout_param_;
  ::caffepro::DimInnerProductParameter* dim_innerproduct_param_;
  ::caffepro::SoftthrParameter* softthr_param_;
  ::caffepro::DropoutParameter* dropoutsame_param_;
  ::caffepro::SoftMaxLossOHEMParameter* softmaxlossohem_param_;
  ::caffepro::SoftMaxOHEMParameter* softmaxohem_param_;
  ::caffepro::SoftMaxOHEMSplitParameter* softmaxohemsplit_param_;
  ::caffepro::DiagOperationParameter* diag_operation_param_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(58 + 31) / 32];
  
  friend void  protobuf_AddDesc_caffe_2eproto();
  friend void protobuf_AssignDesc_caffe_2eproto();
  friend void protobuf_ShutdownFile_caffe_2eproto();
  
  void InitAsDefaultInstance();
  static LayerParameter* default_instance_;
};
// -------------------------------------------------------------------

class ClusterParameter : public ::google::protobuf::Message {
 public:
  ClusterParameter();
  virtual ~ClusterParameter();
  
  ClusterParameter(const ClusterParameter& from);
  
  inline ClusterParameter& operator=(const ClusterParameter& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ClusterParameter& default_instance();
  
  void Swap(ClusterParameter* other);
  
  // implements Message ----------------------------------------------
  
  ClusterParameter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClusterParameter& from);
  void MergeFrom(const ClusterParameter& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 num_centers = 1;
  inline bool has_num_centers() const;
  inline void clear_num_centers();
  static const int kNumCentersFieldNumber = 1;
  inline ::google::protobuf::int32 num_centers() const;
  inline void set_num_centers(::google::protobuf::int32 value);
  
  // optional .caffepro.FillerParameter weight_filler = 2;
  inline bool has_weight_filler() const;
  inline void clear_weight_filler();
  static const int kWeightFillerFieldNumber = 2;
  inline const ::caffepro::FillerParameter& weight_filler() const;
  inline ::caffepro::FillerParameter* mutable_weight_filler();
  inline ::caffepro::FillerParameter* release_weight_filler();
  
  // @@protoc_insertion_point(class_scope:caffepro.ClusterParameter)
 private:
  inline void set_has_num_centers();
  inline void clear_has_num_centers();
  inline void set_has_weight_filler();
  inline void clear_has_weight_filler();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::caffepro::FillerParameter* weight_filler_;
  ::google::protobuf::int32 num_centers_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_caffe_2eproto();
  friend void protobuf_AssignDesc_caffe_2eproto();
  friend void protobuf_ShutdownFile_caffe_2eproto();
  
  void InitAsDefaultInstance();
  static ClusterParameter* default_instance_;
};
// -------------------------------------------------------------------

class OnlineKMeansParameter : public ::google::protobuf::Message {
 public:
  OnlineKMeansParameter();
  virtual ~OnlineKMeansParameter();
  
  OnlineKMeansParameter(const OnlineKMeansParameter& from);
  
  inline OnlineKMeansParameter& operator=(const OnlineKMeansParameter& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const OnlineKMeansParameter& default_instance();
  
  void Swap(OnlineKMeansParameter* other);
  
  // implements Message ----------------------------------------------
  
  OnlineKMeansParameter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OnlineKMeansParameter& from);
  void MergeFrom(const OnlineKMeansParameter& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 update_interval = 1;
  inline bool has_update_interval() const;
  inline void clear_update_interval();
  static const int kUpdateIntervalFieldNumber = 1;
  inline ::google::protobuf::int32 update_interval() const;
  inline void set_update_interval(::google::protobuf::int32 value);
  
  // required int32 update_iters = 2;
  inline bool has_update_iters() const;
  inline void clear_update_iters();
  static const int kUpdateItersFieldNumber = 2;
  inline ::google::protobuf::int32 update_iters() const;
  inline void set_update_iters(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:caffepro.OnlineKMeansParameter)
 private:
  inline void set_has_update_interval();
  inline void clear_has_update_interval();
  inline void set_has_update_iters();
  inline void clear_has_update_iters();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 update_interval_;
  ::google::protobuf::int32 update_iters_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_caffe_2eproto();
  friend void protobuf_AssignDesc_caffe_2eproto();
  friend void protobuf_ShutdownFile_caffe_2eproto();
  
  void InitAsDefaultInstance();
  static OnlineKMeansParameter* default_instance_;
};
// -------------------------------------------------------------------

class EltwiseSumParameter : public ::google::protobuf::Message {
 public:
  EltwiseSumParameter();
  virtual ~EltwiseSumParameter();
  
  EltwiseSumParameter(const EltwiseSumParameter& from);
  
  inline EltwiseSumParameter& operator=(const EltwiseSumParameter& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const EltwiseSumParameter& default_instance();
  
  void Swap(EltwiseSumParameter* other);
  
  // implements Message ----------------------------------------------
  
  EltwiseSumParameter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EltwiseSumParameter& from);
  void MergeFrom(const EltwiseSumParameter& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated float coeff = 1;
  inline int coeff_size() const;
  inline void clear_coeff();
  static const int kCoeffFieldNumber = 1;
  inline float coeff(int index) const;
  inline void set_coeff(int index, float value);
  inline void add_coeff(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      coeff() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_coeff();
  
  // @@protoc_insertion_point(class_scope:caffepro.EltwiseSumParameter)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedField< float > coeff_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_caffe_2eproto();
  friend void protobuf_AssignDesc_caffe_2eproto();
  friend void protobuf_ShutdownFile_caffe_2eproto();
  
  void InitAsDefaultInstance();
  static EltwiseSumParameter* default_instance_;
};
// -------------------------------------------------------------------

class ReluParameter : public ::google::protobuf::Message {
 public:
  ReluParameter();
  virtual ~ReluParameter();
  
  ReluParameter(const ReluParameter& from);
  
  inline ReluParameter& operator=(const ReluParameter& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReluParameter& default_instance();
  
  void Swap(ReluParameter* other);
  
  // implements Message ----------------------------------------------
  
  ReluParameter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReluParameter& from);
  void MergeFrom(const ReluParameter& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional float relu_leak = 1 [default = 0];
  inline bool has_relu_leak() const;
  inline void clear_relu_leak();
  static const int kReluLeakFieldNumber = 1;
  inline float relu_leak() const;
  inline void set_relu_leak(float value);
  
  // @@protoc_insertion_point(class_scope:caffepro.ReluParameter)
 private:
  inline void set_has_relu_leak();
  inline void clear_has_relu_leak();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  float relu_leak_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_caffe_2eproto();
  friend void protobuf_AssignDesc_caffe_2eproto();
  friend void protobuf_ShutdownFile_caffe_2eproto();
  
  void InitAsDefaultInstance();
  static ReluParameter* default_instance_;
};
// -------------------------------------------------------------------

class LearnableLeakReluParameter : public ::google::protobuf::Message {
 public:
  LearnableLeakReluParameter();
  virtual ~LearnableLeakReluParameter();
  
  LearnableLeakReluParameter(const LearnableLeakReluParameter& from);
  
  inline LearnableLeakReluParameter& operator=(const LearnableLeakReluParameter& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const LearnableLeakReluParameter& default_instance();
  
  void Swap(LearnableLeakReluParameter* other);
  
  // implements Message ----------------------------------------------
  
  LearnableLeakReluParameter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LearnableLeakReluParameter& from);
  void MergeFrom(const LearnableLeakReluParameter& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef LearnableLeakReluParameter_ShareParamMethod ShareParamMethod;
  static const ShareParamMethod CHANNEL = LearnableLeakReluParameter_ShareParamMethod_CHANNEL;
  static const ShareParamMethod ALL = LearnableLeakReluParameter_ShareParamMethod_ALL;
  static inline bool ShareParamMethod_IsValid(int value) {
    return LearnableLeakReluParameter_ShareParamMethod_IsValid(value);
  }
  static const ShareParamMethod ShareParamMethod_MIN =
    LearnableLeakReluParameter_ShareParamMethod_ShareParamMethod_MIN;
  static const ShareParamMethod ShareParamMethod_MAX =
    LearnableLeakReluParameter_ShareParamMethod_ShareParamMethod_MAX;
  static const int ShareParamMethod_ARRAYSIZE =
    LearnableLeakReluParameter_ShareParamMethod_ShareParamMethod_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ShareParamMethod_descriptor() {
    return LearnableLeakReluParameter_ShareParamMethod_descriptor();
  }
  static inline const ::std::string& ShareParamMethod_Name(ShareParamMethod value) {
    return LearnableLeakReluParameter_ShareParamMethod_Name(value);
  }
  static inline bool ShareParamMethod_Parse(const ::std::string& name,
      ShareParamMethod* value) {
    return LearnableLeakReluParameter_ShareParamMethod_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // required .caffepro.FillerParameter relu_leak_param = 1;
  inline bool has_relu_leak_param() const;
  inline void clear_relu_leak_param();
  static const int kReluLeakParamFieldNumber = 1;
  inline const ::caffepro::FillerParameter& relu_leak_param() const;
  inline ::caffepro::FillerParameter* mutable_relu_leak_param();
  inline ::caffepro::FillerParameter* release_relu_leak_param();
  
  // required .caffepro.LearnableLeakReluParameter.ShareParamMethod share_param = 2;
  inline bool has_share_param() const;
  inline void clear_share_param();
  static const int kShareParamFieldNumber = 2;
  inline ::caffepro::LearnableLeakReluParameter_ShareParamMethod share_param() const;
  inline void set_share_param(::caffepro::LearnableLeakReluParameter_ShareParamMethod value);
  
  // optional bool apply_bound = 3 [default = true];
  inline bool has_apply_bound() const;
  inline void clear_apply_bound();
  static const int kApplyBoundFieldNumber = 3;
  inline bool apply_bound() const;
  inline void set_apply_bound(bool value);
  
  // optional float bound_upper = 4 [default = 1];
  inline bool has_bound_upper() const;
  inline void clear_bound_upper();
  static const int kBoundUpperFieldNumber = 4;
  inline float bound_upper() const;
  inline void set_bound_upper(float value);
  
  // optional float bound_lower = 5 [default = 0];
  inline bool has_bound_lower() const;
  inline void clear_bound_lower();
  static const int kBoundLowerFieldNumber = 5;
  inline float bound_lower() const;
  inline void set_bound_lower(float value);
  
  // @@protoc_insertion_point(class_scope:caffepro.LearnableLeakReluParameter)
 private:
  inline void set_has_relu_leak_param();
  inline void clear_has_relu_leak_param();
  inline void set_has_share_param();
  inline void clear_has_share_param();
  inline void set_has_apply_bound();
  inline void clear_has_apply_bound();
  inline void set_has_bound_upper();
  inline void clear_has_bound_upper();
  inline void set_has_bound_lower();
  inline void clear_has_bound_lower();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::caffepro::FillerParameter* relu_leak_param_;
  int share_param_;
  bool apply_bound_;
  float bound_upper_;
  float bound_lower_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_caffe_2eproto();
  friend void protobuf_AssignDesc_caffe_2eproto();
  friend void protobuf_ShutdownFile_caffe_2eproto();
  
  void InitAsDefaultInstance();
  static LearnableLeakReluParameter* default_instance_;
};
// -------------------------------------------------------------------

class ExpParameter : public ::google::protobuf::Message {
 public:
  ExpParameter();
  virtual ~ExpParameter();
  
  ExpParameter(const ExpParameter& from);
  
  inline ExpParameter& operator=(const ExpParameter& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ExpParameter& default_instance();
  
  void Swap(ExpParameter* other);
  
  // implements Message ----------------------------------------------
  
  ExpParameter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ExpParameter& from);
  void MergeFrom(const ExpParameter& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional float slope = 1 [default = 1];
  inline bool has_slope() const;
  inline void clear_slope();
  static const int kSlopeFieldNumber = 1;
  inline float slope() const;
  inline void set_slope(float value);
  
  // @@protoc_insertion_point(class_scope:caffepro.ExpParameter)
 private:
  inline void set_has_slope();
  inline void clear_has_slope();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  float slope_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_caffe_2eproto();
  friend void protobuf_AssignDesc_caffe_2eproto();
  friend void protobuf_ShutdownFile_caffe_2eproto();
  
  void InitAsDefaultInstance();
  static ExpParameter* default_instance_;
};
// -------------------------------------------------------------------

class BoundParameter : public ::google::protobuf::Message {
 public:
  BoundParameter();
  virtual ~BoundParameter();
  
  BoundParameter(const BoundParameter& from);
  
  inline BoundParameter& operator=(const BoundParameter& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const BoundParameter& default_instance();
  
  void Swap(BoundParameter* other);
  
  // implements Message ----------------------------------------------
  
  BoundParameter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BoundParameter& from);
  void MergeFrom(const BoundParameter& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required float max_value = 1;
  inline bool has_max_value() const;
  inline void clear_max_value();
  static const int kMaxValueFieldNumber = 1;
  inline float max_value() const;
  inline void set_max_value(float value);
  
  // required float min_value = 2;
  inline bool has_min_value() const;
  inline void clear_min_value();
  static const int kMinValueFieldNumber = 2;
  inline float min_value() const;
  inline void set_min_value(float value);
  
  // @@protoc_insertion_point(class_scope:caffepro.BoundParameter)
 private:
  inline void set_has_max_value();
  inline void clear_has_max_value();
  inline void set_has_min_value();
  inline void clear_has_min_value();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  float max_value_;
  float min_value_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_caffe_2eproto();
  friend void protobuf_AssignDesc_caffe_2eproto();
  friend void protobuf_ShutdownFile_caffe_2eproto();
  
  void InitAsDefaultInstance();
  static BoundParameter* default_instance_;
};
// -------------------------------------------------------------------

class BatchNormalizationParameter : public ::google::protobuf::Message {
 public:
  BatchNormalizationParameter();
  virtual ~BatchNormalizationParameter();
  
  BatchNormalizationParameter(const BatchNormalizationParameter& from);
  
  inline BatchNormalizationParameter& operator=(const BatchNormalizationParameter& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const BatchNormalizationParameter& default_instance();
  
  void Swap(BatchNormalizationParameter* other);
  
  // implements Message ----------------------------------------------
  
  BatchNormalizationParameter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BatchNormalizationParameter& from);
  void MergeFrom(const BatchNormalizationParameter& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef BatchNormalizationParameter_RecordOption RecordOption;
  static const RecordOption NOT_RECORD = BatchNormalizationParameter_RecordOption_NOT_RECORD;
  static const RecordOption RECORD = BatchNormalizationParameter_RecordOption_RECORD;
  static const RecordOption USE_RECORD_NORM = BatchNormalizationParameter_RecordOption_USE_RECORD_NORM;
  static const RecordOption NOT_CALC = BatchNormalizationParameter_RecordOption_NOT_CALC;
  static inline bool RecordOption_IsValid(int value) {
    return BatchNormalizationParameter_RecordOption_IsValid(value);
  }
  static const RecordOption RecordOption_MIN =
    BatchNormalizationParameter_RecordOption_RecordOption_MIN;
  static const RecordOption RecordOption_MAX =
    BatchNormalizationParameter_RecordOption_RecordOption_MAX;
  static const int RecordOption_ARRAYSIZE =
    BatchNormalizationParameter_RecordOption_RecordOption_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  RecordOption_descriptor() {
    return BatchNormalizationParameter_RecordOption_descriptor();
  }
  static inline const ::std::string& RecordOption_Name(RecordOption value) {
    return BatchNormalizationParameter_RecordOption_Name(value);
  }
  static inline bool RecordOption_Parse(const ::std::string& name,
      RecordOption* value) {
    return BatchNormalizationParameter_RecordOption_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // required .caffepro.FillerParameter scale_filler = 1;
  inline bool has_scale_filler() const;
  inline void clear_scale_filler();
  static const int kScaleFillerFieldNumber = 1;
  inline const ::caffepro::FillerParameter& scale_filler() const;
  inline ::caffepro::FillerParameter* mutable_scale_filler();
  inline ::caffepro::FillerParameter* release_scale_filler();
  
  // required .caffepro.FillerParameter shift_filler = 2;
  inline bool has_shift_filler() const;
  inline void clear_shift_filler();
  static const int kShiftFillerFieldNumber = 2;
  inline const ::caffepro::FillerParameter& shift_filler() const;
  inline ::caffepro::FillerParameter* mutable_shift_filler();
  inline ::caffepro::FillerParameter* release_shift_filler();
  
  // optional .caffepro.BatchNormalizationParameter.RecordOption record_option = 3 [default = NOT_RECORD];
  inline bool has_record_option() const;
  inline void clear_record_option();
  static const int kRecordOptionFieldNumber = 3;
  inline ::caffepro::BatchNormalizationParameter_RecordOption record_option() const;
  inline void set_record_option(::caffepro::BatchNormalizationParameter_RecordOption value);
  
  // optional float sliding_window_eval_coeff = 4 [default = -1];
  inline bool has_sliding_window_eval_coeff() const;
  inline void clear_sliding_window_eval_coeff();
  static const int kSlidingWindowEvalCoeffFieldNumber = 4;
  inline float sliding_window_eval_coeff() const;
  inline void set_sliding_window_eval_coeff(float value);
  
  // optional bool keep_mean = 5 [default = false];
  inline bool has_keep_mean() const;
  inline void clear_keep_mean();
  static const int kKeepMeanFieldNumber = 5;
  inline bool keep_mean() const;
  inline void set_keep_mean(bool value);
  
  // @@protoc_insertion_point(class_scope:caffepro.BatchNormalizationParameter)
 private:
  inline void set_has_scale_filler();
  inline void clear_has_scale_filler();
  inline void set_has_shift_filler();
  inline void clear_has_shift_filler();
  inline void set_has_record_option();
  inline void clear_has_record_option();
  inline void set_has_sliding_window_eval_coeff();
  inline void clear_has_sliding_window_eval_coeff();
  inline void set_has_keep_mean();
  inline void clear_has_keep_mean();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::caffepro::FillerParameter* scale_filler_;
  ::caffepro::FillerParameter* shift_filler_;
  int record_option_;
  float sliding_window_eval_coeff_;
  bool keep_mean_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_caffe_2eproto();
  friend void protobuf_AssignDesc_caffe_2eproto();
  friend void protobuf_ShutdownFile_caffe_2eproto();
  
  void InitAsDefaultInstance();
  static BatchNormalizationParameter* default_instance_;
};
// -------------------------------------------------------------------

class GPUSplitParameter : public ::google::protobuf::Message {
 public:
  GPUSplitParameter();
  virtual ~GPUSplitParameter();
  
  GPUSplitParameter(const GPUSplitParameter& from);
  
  inline GPUSplitParameter& operator=(const GPUSplitParameter& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GPUSplitParameter& default_instance();
  
  void Swap(GPUSplitParameter* other);
  
  // implements Message ----------------------------------------------
  
  GPUSplitParameter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GPUSplitParameter& from);
  void MergeFrom(const GPUSplitParameter& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated int32 split_minibatch = 1;
  inline int split_minibatch_size() const;
  inline void clear_split_minibatch();
  static const int kSplitMinibatchFieldNumber = 1;
  inline ::google::protobuf::int32 split_minibatch(int index) const;
  inline void set_split_minibatch(int index, ::google::protobuf::int32 value);
  inline void add_split_minibatch(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      split_minibatch() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_split_minibatch();
  
  // repeated int32 split_gpu_id = 2;
  inline int split_gpu_id_size() const;
  inline void clear_split_gpu_id();
  static const int kSplitGpuIdFieldNumber = 2;
  inline ::google::protobuf::int32 split_gpu_id(int index) const;
  inline void set_split_gpu_id(int index, ::google::protobuf::int32 value);
  inline void add_split_gpu_id(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      split_gpu_id() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_split_gpu_id();
  
  // @@protoc_insertion_point(class_scope:caffepro.GPUSplitParameter)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > split_minibatch_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > split_gpu_id_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_caffe_2eproto();
  friend void protobuf_AssignDesc_caffe_2eproto();
  friend void protobuf_ShutdownFile_caffe_2eproto();
  
  void InitAsDefaultInstance();
  static GPUSplitParameter* default_instance_;
};
// -------------------------------------------------------------------

class ConcatParameter : public ::google::protobuf::Message {
 public:
  ConcatParameter();
  virtual ~ConcatParameter();
  
  ConcatParameter(const ConcatParameter& from);
  
  inline ConcatParameter& operator=(const ConcatParameter& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ConcatParameter& default_instance();
  
  void Swap(ConcatParameter* other);
  
  // implements Message ----------------------------------------------
  
  ConcatParameter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ConcatParameter& from);
  void MergeFrom(const ConcatParameter& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional uint32 concat_dim = 1 [default = 1];
  inline bool has_concat_dim() const;
  inline void clear_concat_dim();
  static const int kConcatDimFieldNumber = 1;
  inline ::google::protobuf::uint32 concat_dim() const;
  inline void set_concat_dim(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:caffepro.ConcatParameter)
 private:
  inline void set_has_concat_dim();
  inline void clear_has_concat_dim();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint32 concat_dim_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_caffe_2eproto();
  friend void protobuf_AssignDesc_caffe_2eproto();
  friend void protobuf_ShutdownFile_caffe_2eproto();
  
  void InitAsDefaultInstance();
  static ConcatParameter* default_instance_;
};
// -------------------------------------------------------------------

class GridGeneratorParameter : public ::google::protobuf::Message {
 public:
  GridGeneratorParameter();
  virtual ~GridGeneratorParameter();
  
  GridGeneratorParameter(const GridGeneratorParameter& from);
  
  inline GridGeneratorParameter& operator=(const GridGeneratorParameter& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GridGeneratorParameter& default_instance();
  
  void Swap(GridGeneratorParameter* other);
  
  // implements Message ----------------------------------------------
  
  GridGeneratorParameter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GridGeneratorParameter& from);
  void MergeFrom(const GridGeneratorParameter& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef GridGeneratorParameter_GridSizeOption GridSizeOption;
  static const GridSizeOption RELATIVE = GridGeneratorParameter_GridSizeOption_RELATIVE;
  static const GridSizeOption ABSOLUTE = GridGeneratorParameter_GridSizeOption_ABSOLUTE;
  static inline bool GridSizeOption_IsValid(int value) {
    return GridGeneratorParameter_GridSizeOption_IsValid(value);
  }
  static const GridSizeOption GridSizeOption_MIN =
    GridGeneratorParameter_GridSizeOption_GridSizeOption_MIN;
  static const GridSizeOption GridSizeOption_MAX =
    GridGeneratorParameter_GridSizeOption_GridSizeOption_MAX;
  static const int GridSizeOption_ARRAYSIZE =
    GridGeneratorParameter_GridSizeOption_GridSizeOption_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  GridSizeOption_descriptor() {
    return GridGeneratorParameter_GridSizeOption_descriptor();
  }
  static inline const ::std::string& GridSizeOption_Name(GridSizeOption value) {
    return GridGeneratorParameter_GridSizeOption_Name(value);
  }
  static inline bool GridSizeOption_Parse(const ::std::string& name,
      GridSizeOption* value) {
    return GridGeneratorParameter_GridSizeOption_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // required string method = 1;
  inline bool has_method() const;
  inline void clear_method();
  static const int kMethodFieldNumber = 1;
  inline const ::std::string& method() const;
  inline void set_method(const ::std::string& value);
  inline void set_method(const char* value);
  inline void set_method(const char* value, size_t size);
  inline ::std::string* mutable_method();
  inline ::std::string* release_method();
  
  // optional .caffepro.GridGeneratorParameter.GridSizeOption grid_size = 2 [default = RELATIVE];
  inline bool has_grid_size() const;
  inline void clear_grid_size();
  static const int kGridSizeFieldNumber = 2;
  inline ::caffepro::GridGeneratorParameter_GridSizeOption grid_size() const;
  inline void set_grid_size(::caffepro::GridGeneratorParameter_GridSizeOption value);
  
  // optional float scale_width = 3 [default = 1];
  inline bool has_scale_width() const;
  inline void clear_scale_width();
  static const int kScaleWidthFieldNumber = 3;
  inline float scale_width() const;
  inline void set_scale_width(float value);
  
  // optional float scale_height = 4 [default = 1];
  inline bool has_scale_height() const;
  inline void clear_scale_height();
  static const int kScaleHeightFieldNumber = 4;
  inline float scale_height() const;
  inline void set_scale_height(float value);
  
  // @@protoc_insertion_point(class_scope:caffepro.GridGeneratorParameter)
 private:
  inline void set_has_method();
  inline void clear_has_method();
  inline void set_has_grid_size();
  inline void clear_has_grid_size();
  inline void set_has_scale_width();
  inline void clear_has_scale_width();
  inline void set_has_scale_height();
  inline void clear_has_scale_height();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* method_;
  int grid_size_;
  float scale_width_;
  float scale_height_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_caffe_2eproto();
  friend void protobuf_AssignDesc_caffe_2eproto();
  friend void protobuf_ShutdownFile_caffe_2eproto();
  
  void InitAsDefaultInstance();
  static GridGeneratorParameter* default_instance_;
};
// -------------------------------------------------------------------

class SampleParameter : public ::google::protobuf::Message {
 public:
  SampleParameter();
  virtual ~SampleParameter();
  
  SampleParameter(const SampleParameter& from);
  
  inline SampleParameter& operator=(const SampleParameter& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SampleParameter& default_instance();
  
  void Swap(SampleParameter* other);
  
  // implements Message ----------------------------------------------
  
  SampleParameter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SampleParameter& from);
  void MergeFrom(const SampleParameter& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef SampleParameter_ConcatOutputOption ConcatOutputOption;
  static const ConcatOutputOption CHANNEL = SampleParameter_ConcatOutputOption_CHANNEL;
  static const ConcatOutputOption NUM = SampleParameter_ConcatOutputOption_NUM;
  static inline bool ConcatOutputOption_IsValid(int value) {
    return SampleParameter_ConcatOutputOption_IsValid(value);
  }
  static const ConcatOutputOption ConcatOutputOption_MIN =
    SampleParameter_ConcatOutputOption_ConcatOutputOption_MIN;
  static const ConcatOutputOption ConcatOutputOption_MAX =
    SampleParameter_ConcatOutputOption_ConcatOutputOption_MAX;
  static const int ConcatOutputOption_ARRAYSIZE =
    SampleParameter_ConcatOutputOption_ConcatOutputOption_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ConcatOutputOption_descriptor() {
    return SampleParameter_ConcatOutputOption_descriptor();
  }
  static inline const ::std::string& ConcatOutputOption_Name(ConcatOutputOption value) {
    return SampleParameter_ConcatOutputOption_Name(value);
  }
  static inline bool ConcatOutputOption_Parse(const ::std::string& name,
      ConcatOutputOption* value) {
    return SampleParameter_ConcatOutputOption_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // optional .caffepro.SampleParameter.ConcatOutputOption concat_output = 1 [default = CHANNEL];
  inline bool has_concat_output() const;
  inline void clear_concat_output();
  static const int kConcatOutputFieldNumber = 1;
  inline ::caffepro::SampleParameter_ConcatOutputOption concat_output() const;
  inline void set_concat_output(::caffepro::SampleParameter_ConcatOutputOption value);
  
  // @@protoc_insertion_point(class_scope:caffepro.SampleParameter)
 private:
  inline void set_has_concat_output();
  inline void clear_has_concat_output();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  int concat_output_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_caffe_2eproto();
  friend void protobuf_AssignDesc_caffe_2eproto();
  friend void protobuf_ShutdownFile_caffe_2eproto();
  
  void InitAsDefaultInstance();
  static SampleParameter* default_instance_;
};
// -------------------------------------------------------------------

class AnchorParameter : public ::google::protobuf::Message {
 public:
  AnchorParameter();
  virtual ~AnchorParameter();
  
  AnchorParameter(const AnchorParameter& from);
  
  inline AnchorParameter& operator=(const AnchorParameter& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AnchorParameter& default_instance();
  
  void Swap(AnchorParameter* other);
  
  // implements Message ----------------------------------------------
  
  AnchorParameter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AnchorParameter& from);
  void MergeFrom(const AnchorParameter& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 spatial_width = 1;
  inline bool has_spatial_width() const;
  inline void clear_spatial_width();
  static const int kSpatialWidthFieldNumber = 1;
  inline ::google::protobuf::int32 spatial_width() const;
  inline void set_spatial_width(::google::protobuf::int32 value);
  
  // required int32 spatial_height = 2;
  inline bool has_spatial_height() const;
  inline void clear_spatial_height();
  static const int kSpatialHeightFieldNumber = 2;
  inline ::google::protobuf::int32 spatial_height() const;
  inline void set_spatial_height(::google::protobuf::int32 value);
  
  // repeated float central_scale = 3;
  inline int central_scale_size() const;
  inline void clear_central_scale();
  static const int kCentralScaleFieldNumber = 3;
  inline float central_scale(int index) const;
  inline void set_central_scale(int index, float value);
  inline void add_central_scale(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      central_scale() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_central_scale();
  
  // optional float spatial_start = 4;
  inline bool has_spatial_start() const;
  inline void clear_spatial_start();
  static const int kSpatialStartFieldNumber = 4;
  inline float spatial_start() const;
  inline void set_spatial_start(float value);
  
  // optional float spatial_step = 5;
  inline bool has_spatial_step() const;
  inline void clear_spatial_step();
  static const int kSpatialStepFieldNumber = 5;
  inline float spatial_step() const;
  inline void set_spatial_step(float value);
  
  // repeated float aspect_ratio = 6;
  inline int aspect_ratio_size() const;
  inline void clear_aspect_ratio();
  static const int kAspectRatioFieldNumber = 6;
  inline float aspect_ratio(int index) const;
  inline void set_aspect_ratio(int index, float value);
  inline void add_aspect_ratio(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      aspect_ratio() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_aspect_ratio();
  
  // @@protoc_insertion_point(class_scope:caffepro.AnchorParameter)
 private:
  inline void set_has_spatial_width();
  inline void clear_has_spatial_width();
  inline void set_has_spatial_height();
  inline void clear_has_spatial_height();
  inline void set_has_spatial_start();
  inline void clear_has_spatial_start();
  inline void set_has_spatial_step();
  inline void clear_has_spatial_step();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 spatial_width_;
  ::google::protobuf::int32 spatial_height_;
  ::google::protobuf::RepeatedField< float > central_scale_;
  float spatial_start_;
  float spatial_step_;
  ::google::protobuf::RepeatedField< float > aspect_ratio_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_caffe_2eproto();
  friend void protobuf_AssignDesc_caffe_2eproto();
  friend void protobuf_ShutdownFile_caffe_2eproto();
  
  void InitAsDefaultInstance();
  static AnchorParameter* default_instance_;
};
// -------------------------------------------------------------------

class ConvolutionParameter : public ::google::protobuf::Message {
 public:
  ConvolutionParameter();
  virtual ~ConvolutionParameter();
  
  ConvolutionParameter(const ConvolutionParameter& from);
  
  inline ConvolutionParameter& operator=(const ConvolutionParameter& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ConvolutionParameter& default_instance();
  
  void Swap(ConvolutionParameter* other);
  
  // implements Message ----------------------------------------------
  
  ConvolutionParameter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ConvolutionParameter& from);
  void MergeFrom(const ConvolutionParameter& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional uint32 num_output = 1;
  inline bool has_num_output() const;
  inline void clear_num_output();
  static const int kNumOutputFieldNumber = 1;
  inline ::google::protobuf::uint32 num_output() const;
  inline void set_num_output(::google::protobuf::uint32 value);
  
  // optional bool bias_term = 2 [default = true];
  inline bool has_bias_term() const;
  inline void clear_bias_term();
  static const int kBiasTermFieldNumber = 2;
  inline bool bias_term() const;
  inline void set_bias_term(bool value);
  
  // optional int32 pad = 3 [default = 0];
  inline bool has_pad() const;
  inline void clear_pad();
  static const int kPadFieldNumber = 3;
  inline ::google::protobuf::int32 pad() const;
  inline void set_pad(::google::protobuf::int32 value);
  
  // optional uint32 kernel_size = 4;
  inline bool has_kernel_size() const;
  inline void clear_kernel_size();
  static const int kKernelSizeFieldNumber = 4;
  inline ::google::protobuf::uint32 kernel_size() const;
  inline void set_kernel_size(::google::protobuf::uint32 value);
  
  // optional uint32 group = 5 [default = 1];
  inline bool has_group() const;
  inline void clear_group();
  static const int kGroupFieldNumber = 5;
  inline ::google::protobuf::uint32 group() const;
  inline void set_group(::google::protobuf::uint32 value);
  
  // optional uint32 stride = 6 [default = 1];
  inline bool has_stride() const;
  inline void clear_stride();
  static const int kStrideFieldNumber = 6;
  inline ::google::protobuf::uint32 stride() const;
  inline void set_stride(::google::protobuf::uint32 value);
  
  // optional .caffepro.FillerParameter weight_filler = 7;
  inline bool has_weight_filler() const;
  inline void clear_weight_filler();
  static const int kWeightFillerFieldNumber = 7;
  inline const ::caffepro::FillerParameter& weight_filler() const;
  inline ::caffepro::FillerParameter* mutable_weight_filler();
  inline ::caffepro::FillerParameter* release_weight_filler();
  
  // optional .caffepro.FillerParameter bias_filler = 8;
  inline bool has_bias_filler() const;
  inline void clear_bias_filler();
  static const int kBiasFillerFieldNumber = 8;
  inline const ::caffepro::FillerParameter& bias_filler() const;
  inline ::caffepro::FillerParameter* mutable_bias_filler();
  inline ::caffepro::FillerParameter* release_bias_filler();
  
  // optional bool size_floor = 9 [default = true];
  inline bool has_size_floor() const;
  inline void clear_size_floor();
  static const int kSizeFloorFieldNumber = 9;
  inline bool size_floor() const;
  inline void set_size_floor(bool value);
  
  // repeated uint32 block_calc = 10;
  inline int block_calc_size() const;
  inline void clear_block_calc();
  static const int kBlockCalcFieldNumber = 10;
  inline ::google::protobuf::uint32 block_calc(int index) const;
  inline void set_block_calc(int index, ::google::protobuf::uint32 value);
  inline void add_block_calc(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      block_calc() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_block_calc();
  
  // optional bool use_cudnn = 11 [default = false];
  inline bool has_use_cudnn() const;
  inline void clear_use_cudnn();
  static const int kUseCudnnFieldNumber = 11;
  inline bool use_cudnn() const;
  inline void set_use_cudnn(bool value);
  
  // optional int32 out_width = 12 [default = 0];
  inline bool has_out_width() const;
  inline void clear_out_width();
  static const int kOutWidthFieldNumber = 12;
  inline ::google::protobuf::int32 out_width() const;
  inline void set_out_width(::google::protobuf::int32 value);
  
  // optional int32 out_height = 13 [default = 0];
  inline bool has_out_height() const;
  inline void clear_out_height();
  static const int kOutHeightFieldNumber = 13;
  inline ::google::protobuf::int32 out_height() const;
  inline void set_out_height(::google::protobuf::int32 value);
  
  // optional int32 pad_x = 14 [default = 0];
  inline bool has_pad_x() const;
  inline void clear_pad_x();
  static const int kPadXFieldNumber = 14;
  inline ::google::protobuf::int32 pad_x() const;
  inline void set_pad_x(::google::protobuf::int32 value);
  
  // optional int32 pad_y = 15 [default = 0];
  inline bool has_pad_y() const;
  inline void clear_pad_y();
  static const int kPadYFieldNumber = 15;
  inline ::google::protobuf::int32 pad_y() const;
  inline void set_pad_y(::google::protobuf::int32 value);
  
  // optional int32 kernel_size_x = 16 [default = 0];
  inline bool has_kernel_size_x() const;
  inline void clear_kernel_size_x();
  static const int kKernelSizeXFieldNumber = 16;
  inline ::google::protobuf::int32 kernel_size_x() const;
  inline void set_kernel_size_x(::google::protobuf::int32 value);
  
  // optional int32 kernel_size_y = 17 [default = 0];
  inline bool has_kernel_size_y() const;
  inline void clear_kernel_size_y();
  static const int kKernelSizeYFieldNumber = 17;
  inline ::google::protobuf::int32 kernel_size_y() const;
  inline void set_kernel_size_y(::google::protobuf::int32 value);
  
  // optional int32 stride_x = 18 [default = 1];
  inline bool has_stride_x() const;
  inline void clear_stride_x();
  static const int kStrideXFieldNumber = 18;
  inline ::google::protobuf::int32 stride_x() const;
  inline void set_stride_x(::google::protobuf::int32 value);
  
  // optional int32 stride_y = 19 [default = 1];
  inline bool has_stride_y() const;
  inline void clear_stride_y();
  static const int kStrideYFieldNumber = 19;
  inline ::google::protobuf::int32 stride_y() const;
  inline void set_stride_y(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:caffepro.ConvolutionParameter)
 private:
  inline void set_has_num_output();
  inline void clear_has_num_output();
  inline void set_has_bias_term();
  inline void clear_has_bias_term();
  inline void set_has_pad();
  inline void clear_has_pad();
  inline void set_has_kernel_size();
  inline void clear_has_kernel_size();
  inline void set_has_group();
  inline void clear_has_group();
  inline void set_has_stride();
  inline void clear_has_stride();
  inline void set_has_weight_filler();
  inline void clear_has_weight_filler();
  inline void set_has_bias_filler();
  inline void clear_has_bias_filler();
  inline void set_has_size_floor();
  inline void clear_has_size_floor();
  inline void set_has_use_cudnn();
  inline void clear_has_use_cudnn();
  inline void set_has_out_width();
  inline void clear_has_out_width();
  inline void set_has_out_height();
  inline void clear_has_out_height();
  inline void set_has_pad_x();
  inline void clear_has_pad_x();
  inline void set_has_pad_y();
  inline void clear_has_pad_y();
  inline void set_has_kernel_size_x();
  inline void clear_has_kernel_size_x();
  inline void set_has_kernel_size_y();
  inline void clear_has_kernel_size_y();
  inline void set_has_stride_x();
  inline void clear_has_stride_x();
  inline void set_has_stride_y();
  inline void clear_has_stride_y();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint32 num_output_;
  ::google::protobuf::int32 pad_;
  ::google::protobuf::uint32 kernel_size_;
  ::google::protobuf::uint32 group_;
  ::caffepro::FillerParameter* weight_filler_;
  ::google::protobuf::uint32 stride_;
  bool bias_term_;
  bool size_floor_;
  bool use_cudnn_;
  ::caffepro::FillerParameter* bias_filler_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > block_calc_;
  ::google::protobuf::int32 out_width_;
  ::google::protobuf::int32 out_height_;
  ::google::protobuf::int32 pad_x_;
  ::google::protobuf::int32 pad_y_;
  ::google::protobuf::int32 kernel_size_x_;
  ::google::protobuf::int32 kernel_size_y_;
  ::google::protobuf::int32 stride_x_;
  ::google::protobuf::int32 stride_y_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(19 + 31) / 32];
  
  friend void  protobuf_AddDesc_caffe_2eproto();
  friend void protobuf_AssignDesc_caffe_2eproto();
  friend void protobuf_ShutdownFile_caffe_2eproto();
  
  void InitAsDefaultInstance();
  static ConvolutionParameter* default_instance_;
};
// -------------------------------------------------------------------

class CorrelationParameter : public ::google::protobuf::Message {
 public:
  CorrelationParameter();
  virtual ~CorrelationParameter();
  
  CorrelationParameter(const CorrelationParameter& from);
  
  inline CorrelationParameter& operator=(const CorrelationParameter& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const CorrelationParameter& default_instance();
  
  void Swap(CorrelationParameter* other);
  
  // implements Message ----------------------------------------------
  
  CorrelationParameter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CorrelationParameter& from);
  void MergeFrom(const CorrelationParameter& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional bool bias_term = 2 [default = true];
  inline bool has_bias_term() const;
  inline void clear_bias_term();
  static const int kBiasTermFieldNumber = 2;
  inline bool bias_term() const;
  inline void set_bias_term(bool value);
  
  // optional int32 pad = 3 [default = 0];
  inline bool has_pad() const;
  inline void clear_pad();
  static const int kPadFieldNumber = 3;
  inline ::google::protobuf::int32 pad() const;
  inline void set_pad(::google::protobuf::int32 value);
  
  // optional uint32 group = 5 [default = 1];
  inline bool has_group() const;
  inline void clear_group();
  static const int kGroupFieldNumber = 5;
  inline ::google::protobuf::uint32 group() const;
  inline void set_group(::google::protobuf::uint32 value);
  
  // optional uint32 stride = 6 [default = 1];
  inline bool has_stride() const;
  inline void clear_stride();
  static const int kStrideFieldNumber = 6;
  inline ::google::protobuf::uint32 stride() const;
  inline void set_stride(::google::protobuf::uint32 value);
  
  // optional .caffepro.FillerParameter bias_filler = 8;
  inline bool has_bias_filler() const;
  inline void clear_bias_filler();
  static const int kBiasFillerFieldNumber = 8;
  inline const ::caffepro::FillerParameter& bias_filler() const;
  inline ::caffepro::FillerParameter* mutable_bias_filler();
  inline ::caffepro::FillerParameter* release_bias_filler();
  
  // optional bool size_floor = 9 [default = true];
  inline bool has_size_floor() const;
  inline void clear_size_floor();
  static const int kSizeFloorFieldNumber = 9;
  inline bool size_floor() const;
  inline void set_size_floor(bool value);
  
  // repeated uint32 block_calc = 10;
  inline int block_calc_size() const;
  inline void clear_block_calc();
  static const int kBlockCalcFieldNumber = 10;
  inline ::google::protobuf::uint32 block_calc(int index) const;
  inline void set_block_calc(int index, ::google::protobuf::uint32 value);
  inline void add_block_calc(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      block_calc() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_block_calc();
  
  // optional int32 out_width = 12 [default = 0];
  inline bool has_out_width() const;
  inline void clear_out_width();
  static const int kOutWidthFieldNumber = 12;
  inline ::google::protobuf::int32 out_width() const;
  inline void set_out_width(::google::protobuf::int32 value);
  
  // optional int32 out_height = 13 [default = 0];
  inline bool has_out_height() const;
  inline void clear_out_height();
  static const int kOutHeightFieldNumber = 13;
  inline ::google::protobuf::int32 out_height() const;
  inline void set_out_height(::google::protobuf::int32 value);
  
  // optional int32 pad_x = 14 [default = 0];
  inline bool has_pad_x() const;
  inline void clear_pad_x();
  static const int kPadXFieldNumber = 14;
  inline ::google::protobuf::int32 pad_x() const;
  inline void set_pad_x(::google::protobuf::int32 value);
  
  // optional int32 pad_y = 15 [default = 0];
  inline bool has_pad_y() const;
  inline void clear_pad_y();
  static const int kPadYFieldNumber = 15;
  inline ::google::protobuf::int32 pad_y() const;
  inline void set_pad_y(::google::protobuf::int32 value);
  
  // optional int32 stride_x = 18 [default = 1];
  inline bool has_stride_x() const;
  inline void clear_stride_x();
  static const int kStrideXFieldNumber = 18;
  inline ::google::protobuf::int32 stride_x() const;
  inline void set_stride_x(::google::protobuf::int32 value);
  
  // optional int32 stride_y = 19 [default = 1];
  inline bool has_stride_y() const;
  inline void clear_stride_y();
  static const int kStrideYFieldNumber = 19;
  inline ::google::protobuf::int32 stride_y() const;
  inline void set_stride_y(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:caffepro.CorrelationParameter)
 private:
  inline void set_has_bias_term();
  inline void clear_has_bias_term();
  inline void set_has_pad();
  inline void clear_has_pad();
  inline void set_has_group();
  inline void clear_has_group();
  inline void set_has_stride();
  inline void clear_has_stride();
  inline void set_has_bias_filler();
  inline void clear_has_bias_filler();
  inline void set_has_size_floor();
  inline void clear_has_size_floor();
  inline void set_has_out_width();
  inline void clear_has_out_width();
  inline void set_has_out_height();
  inline void clear_has_out_height();
  inline void set_has_pad_x();
  inline void clear_has_pad_x();
  inline void set_has_pad_y();
  inline void clear_has_pad_y();
  inline void set_has_stride_x();
  inline void clear_has_stride_x();
  inline void set_has_stride_y();
  inline void clear_has_stride_y();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 pad_;
  ::google::protobuf::uint32 group_;
  bool bias_term_;
  bool size_floor_;
  ::google::protobuf::uint32 stride_;
  ::caffepro::FillerParameter* bias_filler_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > block_calc_;
  ::google::protobuf::int32 out_width_;
  ::google::protobuf::int32 out_height_;
  ::google::protobuf::int32 pad_x_;
  ::google::protobuf::int32 pad_y_;
  ::google::protobuf::int32 stride_x_;
  ::google::protobuf::int32 stride_y_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(13 + 31) / 32];
  
  friend void  protobuf_AddDesc_caffe_2eproto();
  friend void protobuf_AssignDesc_caffe_2eproto();
  friend void protobuf_ShutdownFile_caffe_2eproto();
  
  void InitAsDefaultInstance();
  static CorrelationParameter* default_instance_;
};
// -------------------------------------------------------------------

class WeightParameter : public ::google::protobuf::Message {
 public:
  WeightParameter();
  virtual ~WeightParameter();
  
  WeightParameter(const WeightParameter& from);
  
  inline WeightParameter& operator=(const WeightParameter& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const WeightParameter& default_instance();
  
  void Swap(WeightParameter* other);
  
  // implements Message ----------------------------------------------
  
  WeightParameter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const WeightParameter& from);
  void MergeFrom(const WeightParameter& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated uint32 weight_dim = 1;
  inline int weight_dim_size() const;
  inline void clear_weight_dim();
  static const int kWeightDimFieldNumber = 1;
  inline ::google::protobuf::uint32 weight_dim(int index) const;
  inline void set_weight_dim(int index, ::google::protobuf::uint32 value);
  inline void add_weight_dim(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      weight_dim() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_weight_dim();
  
  // optional .caffepro.FillerParameter weight_filler = 2;
  inline bool has_weight_filler() const;
  inline void clear_weight_filler();
  static const int kWeightFillerFieldNumber = 2;
  inline const ::caffepro::FillerParameter& weight_filler() const;
  inline ::caffepro::FillerParameter* mutable_weight_filler();
  inline ::caffepro::FillerParameter* release_weight_filler();
  
  // @@protoc_insertion_point(class_scope:caffepro.WeightParameter)
 private:
  inline void set_has_weight_filler();
  inline void clear_has_weight_filler();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > weight_dim_;
  ::caffepro::FillerParameter* weight_filler_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_caffe_2eproto();
  friend void protobuf_AssignDesc_caffe_2eproto();
  friend void protobuf_ShutdownFile_caffe_2eproto();
  
  void InitAsDefaultInstance();
  static WeightParameter* default_instance_;
};
// -------------------------------------------------------------------

class DataProcesser : public ::google::protobuf::Message {
 public:
  DataProcesser();
  virtual ~DataProcesser();
  
  DataProcesser(const DataProcesser& from);
  
  inline DataProcesser& operator=(const DataProcesser& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const DataProcesser& default_instance();
  
  void Swap(DataProcesser* other);
  
  // implements Message ----------------------------------------------
  
  DataProcesser* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DataProcesser& from);
  void MergeFrom(const DataProcesser& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string processer_type = 1;
  inline bool has_processer_type() const;
  inline void clear_processer_type();
  static const int kProcesserTypeFieldNumber = 1;
  inline const ::std::string& processer_type() const;
  inline void set_processer_type(const ::std::string& value);
  inline void set_processer_type(const char* value);
  inline void set_processer_type(const char* value, size_t size);
  inline ::std::string* mutable_processer_type();
  inline ::std::string* release_processer_type();
  
  // repeated int32 binding_output_index = 2;
  inline int binding_output_index_size() const;
  inline void clear_binding_output_index();
  static const int kBindingOutputIndexFieldNumber = 2;
  inline ::google::protobuf::int32 binding_output_index(int index) const;
  inline void set_binding_output_index(int index, ::google::protobuf::int32 value);
  inline void add_binding_output_index(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      binding_output_index() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_binding_output_index();
  
  // repeated float threshold = 3;
  inline int threshold_size() const;
  inline void clear_threshold();
  static const int kThresholdFieldNumber = 3;
  inline float threshold(int index) const;
  inline void set_threshold(int index, float value);
  inline void add_threshold(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      threshold() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_threshold();
  
  // repeated float alpha = 4;
  inline int alpha_size() const;
  inline void clear_alpha();
  static const int kAlphaFieldNumber = 4;
  inline float alpha(int index) const;
  inline void set_alpha(int index, float value);
  inline void add_alpha(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      alpha() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_alpha();
  
  // repeated float beta = 5;
  inline int beta_size() const;
  inline void clear_beta();
  static const int kBetaFieldNumber = 5;
  inline float beta(int index) const;
  inline void set_beta(int index, float value);
  inline void add_beta(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      beta() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_beta();
  
  // repeated string method = 6;
  inline int method_size() const;
  inline void clear_method();
  static const int kMethodFieldNumber = 6;
  inline const ::std::string& method(int index) const;
  inline ::std::string* mutable_method(int index);
  inline void set_method(int index, const ::std::string& value);
  inline void set_method(int index, const char* value);
  inline void set_method(int index, const char* value, size_t size);
  inline ::std::string* add_method();
  inline void add_method(const ::std::string& value);
  inline void add_method(const char* value);
  inline void add_method(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& method() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_method();
  
  // @@protoc_insertion_point(class_scope:caffepro.DataProcesser)
 private:
  inline void set_has_processer_type();
  inline void clear_has_processer_type();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* processer_type_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > binding_output_index_;
  ::google::protobuf::RepeatedField< float > threshold_;
  ::google::protobuf::RepeatedField< float > alpha_;
  ::google::protobuf::RepeatedField< float > beta_;
  ::google::protobuf::RepeatedPtrField< ::std::string> method_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_caffe_2eproto();
  friend void protobuf_AssignDesc_caffe_2eproto();
  friend void protobuf_ShutdownFile_caffe_2eproto();
  
  void InitAsDefaultInstance();
  static DataProcesser* default_instance_;
};
// -------------------------------------------------------------------

class DataParameter_BigFile : public ::google::protobuf::Message {
 public:
  DataParameter_BigFile();
  virtual ~DataParameter_BigFile();
  
  DataParameter_BigFile(const DataParameter_BigFile& from);
  
  inline DataParameter_BigFile& operator=(const DataParameter_BigFile& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const DataParameter_BigFile& default_instance();
  
  void Swap(DataParameter_BigFile* other);
  
  // implements Message ----------------------------------------------
  
  DataParameter_BigFile* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DataParameter_BigFile& from);
  void MergeFrom(const DataParameter_BigFile& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef DataParameter_BigFile_InterpolationType InterpolationType;
  static const InterpolationType Bilinear = DataParameter_BigFile_InterpolationType_Bilinear;
  static const InterpolationType Bicubic = DataParameter_BigFile_InterpolationType_Bicubic;
  static const InterpolationType Lanczos = DataParameter_BigFile_InterpolationType_Lanczos;
  static inline bool InterpolationType_IsValid(int value) {
    return DataParameter_BigFile_InterpolationType_IsValid(value);
  }
  static const InterpolationType InterpolationType_MIN =
    DataParameter_BigFile_InterpolationType_InterpolationType_MIN;
  static const InterpolationType InterpolationType_MAX =
    DataParameter_BigFile_InterpolationType_InterpolationType_MAX;
  static const int InterpolationType_ARRAYSIZE =
    DataParameter_BigFile_InterpolationType_InterpolationType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  InterpolationType_descriptor() {
    return DataParameter_BigFile_InterpolationType_descriptor();
  }
  static inline const ::std::string& InterpolationType_Name(InterpolationType value) {
    return DataParameter_BigFile_InterpolationType_Name(value);
  }
  static inline bool InterpolationType_Parse(const ::std::string& name,
      InterpolationType* value) {
    return DataParameter_BigFile_InterpolationType_Parse(name, value);
  }
  
  typedef DataParameter_BigFile_ScaleJitterType ScaleJitterType;
  static const ScaleJitterType UniRatio = DataParameter_BigFile_ScaleJitterType_UniRatio;
  static const ScaleJitterType UniLength = DataParameter_BigFile_ScaleJitterType_UniLength;
  static const ScaleJitterType UniArea = DataParameter_BigFile_ScaleJitterType_UniArea;
  static const ScaleJitterType UniAreaV2 = DataParameter_BigFile_ScaleJitterType_UniAreaV2;
  static inline bool ScaleJitterType_IsValid(int value) {
    return DataParameter_BigFile_ScaleJitterType_IsValid(value);
  }
  static const ScaleJitterType ScaleJitterType_MIN =
    DataParameter_BigFile_ScaleJitterType_ScaleJitterType_MIN;
  static const ScaleJitterType ScaleJitterType_MAX =
    DataParameter_BigFile_ScaleJitterType_ScaleJitterType_MAX;
  static const int ScaleJitterType_ARRAYSIZE =
    DataParameter_BigFile_ScaleJitterType_ScaleJitterType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ScaleJitterType_descriptor() {
    return DataParameter_BigFile_ScaleJitterType_descriptor();
  }
  static inline const ::std::string& ScaleJitterType_Name(ScaleJitterType value) {
    return DataParameter_BigFile_ScaleJitterType_Name(value);
  }
  static inline bool ScaleJitterType_Parse(const ::std::string& name,
      ScaleJitterType* value) {
    return DataParameter_BigFile_ScaleJitterType_Parse(name, value);
  }
  
  typedef DataParameter_BigFile_CropPreference CropPreference;
  static const CropPreference IoCThres = DataParameter_BigFile_CropPreference_IoCThres;
  static const CropPreference IoUMax = DataParameter_BigFile_CropPreference_IoUMax;
  static const CropPreference IoUThres = DataParameter_BigFile_CropPreference_IoUThres;
  static const CropPreference AnchorMaxThres = DataParameter_BigFile_CropPreference_AnchorMaxThres;
  static inline bool CropPreference_IsValid(int value) {
    return DataParameter_BigFile_CropPreference_IsValid(value);
  }
  static const CropPreference CropPreference_MIN =
    DataParameter_BigFile_CropPreference_CropPreference_MIN;
  static const CropPreference CropPreference_MAX =
    DataParameter_BigFile_CropPreference_CropPreference_MAX;
  static const int CropPreference_ARRAYSIZE =
    DataParameter_BigFile_CropPreference_CropPreference_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  CropPreference_descriptor() {
    return DataParameter_BigFile_CropPreference_descriptor();
  }
  static inline const ::std::string& CropPreference_Name(CropPreference value) {
    return DataParameter_BigFile_CropPreference_Name(value);
  }
  static inline bool CropPreference_Parse(const ::std::string& name,
      CropPreference* value) {
    return DataParameter_BigFile_CropPreference_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // optional string source = 1;
  inline bool has_source() const;
  inline void clear_source();
  static const int kSourceFieldNumber = 1;
  inline const ::std::string& source() const;
  inline void set_source(const ::std::string& value);
  inline void set_source(const char* value);
  inline void set_source(const char* value, size_t size);
  inline ::std::string* mutable_source();
  inline ::std::string* release_source();
  
  // optional float scale = 2 [default = 1];
  inline bool has_scale() const;
  inline void clear_scale();
  static const int kScaleFieldNumber = 2;
  inline float scale() const;
  inline void set_scale(float value);
  
  // optional string mean_file = 3;
  inline bool has_mean_file() const;
  inline void clear_mean_file();
  static const int kMeanFileFieldNumber = 3;
  inline const ::std::string& mean_file() const;
  inline void set_mean_file(const ::std::string& value);
  inline void set_mean_file(const char* value);
  inline void set_mean_file(const char* value, size_t size);
  inline ::std::string* mutable_mean_file();
  inline ::std::string* release_mean_file();
  
  // optional uint32 batch_size = 4;
  inline bool has_batch_size() const;
  inline void clear_batch_size();
  static const int kBatchSizeFieldNumber = 4;
  inline ::google::protobuf::uint32 batch_size() const;
  inline void set_batch_size(::google::protobuf::uint32 value);
  
  // optional uint32 batch_img_size = 5 [default = 0];
  inline bool has_batch_img_size() const;
  inline void clear_batch_img_size();
  static const int kBatchImgSizeFieldNumber = 5;
  inline ::google::protobuf::uint32 batch_img_size() const;
  inline void set_batch_img_size(::google::protobuf::uint32 value);
  
  // repeated uint32 channel_num = 6;
  inline int channel_num_size() const;
  inline void clear_channel_num();
  static const int kChannelNumFieldNumber = 6;
  inline ::google::protobuf::uint32 channel_num(int index) const;
  inline void set_channel_num(int index, ::google::protobuf::uint32 value);
  inline void add_channel_num(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      channel_num() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_channel_num();
  
  // optional uint32 crop_type = 7 [default = 0];
  inline bool has_crop_type() const;
  inline void clear_crop_type();
  static const int kCropTypeFieldNumber = 7;
  inline ::google::protobuf::uint32 crop_type() const;
  inline void set_crop_type(::google::protobuf::uint32 value);
  
  // optional float crop_ratio = 8 [default = 1];
  inline bool has_crop_ratio() const;
  inline void clear_crop_ratio();
  static const int kCropRatioFieldNumber = 8;
  inline float crop_ratio() const;
  inline void set_crop_ratio(float value);
  
  // optional string color_kl_dir = 9;
  inline bool has_color_kl_dir() const;
  inline void clear_color_kl_dir();
  static const int kColorKlDirFieldNumber = 9;
  inline const ::std::string& color_kl_dir() const;
  inline void set_color_kl_dir(const ::std::string& value);
  inline void set_color_kl_dir(const char* value);
  inline void set_color_kl_dir(const char* value, size_t size);
  inline ::std::string* mutable_color_kl_dir();
  inline ::std::string* release_color_kl_dir();
  
  // optional bool random_shuffle = 11 [default = true];
  inline bool has_random_shuffle() const;
  inline void clear_random_shuffle();
  static const int kRandomShuffleFieldNumber = 11;
  inline bool random_shuffle() const;
  inline void set_random_shuffle(bool value);
  
  // optional float overlap_thres = 12 [default = 0];
  inline bool has_overlap_thres() const;
  inline void clear_overlap_thres();
  static const int kOverlapThresFieldNumber = 12;
  inline float overlap_thres() const;
  inline void set_overlap_thres(float value);
  
  // optional string object_windows_dir = 13;
  inline bool has_object_windows_dir() const;
  inline void clear_object_windows_dir();
  static const int kObjectWindowsDirFieldNumber = 13;
  inline const ::std::string& object_windows_dir() const;
  inline void set_object_windows_dir(const ::std::string& value);
  inline void set_object_windows_dir(const char* value);
  inline void set_object_windows_dir(const char* value, size_t size);
  inline ::std::string* mutable_object_windows_dir();
  inline ::std::string* release_object_windows_dir();
  
  // optional float crop_ratio_upperbound = 14 [default = -1];
  inline bool has_crop_ratio_upperbound() const;
  inline void clear_crop_ratio_upperbound();
  static const int kCropRatioUpperboundFieldNumber = 14;
  inline float crop_ratio_upperbound() const;
  inline void set_crop_ratio_upperbound(float value);
  
  // optional float crop_ratio_lowerbound = 15 [default = -1];
  inline bool has_crop_ratio_lowerbound() const;
  inline void clear_crop_ratio_lowerbound();
  static const int kCropRatioLowerboundFieldNumber = 15;
  inline float crop_ratio_lowerbound() const;
  inline void set_crop_ratio_lowerbound(float value);
  
  // repeated .caffepro.DataParameter_BigFile.InterpolationType interpolation = 16;
  inline int interpolation_size() const;
  inline void clear_interpolation();
  static const int kInterpolationFieldNumber = 16;
  inline ::caffepro::DataParameter_BigFile_InterpolationType interpolation(int index) const;
  inline void set_interpolation(int index, ::caffepro::DataParameter_BigFile_InterpolationType value);
  inline void add_interpolation(::caffepro::DataParameter_BigFile_InterpolationType value);
  inline const ::google::protobuf::RepeatedField<int>& interpolation() const;
  inline ::google::protobuf::RepeatedField<int>* mutable_interpolation();
  
  // optional float aspect_ratio_variation = 17 [default = 0];
  inline bool has_aspect_ratio_variation() const;
  inline void clear_aspect_ratio_variation();
  static const int kAspectRatioVariationFieldNumber = 17;
  inline float aspect_ratio_variation() const;
  inline void set_aspect_ratio_variation(float value);
  
  // optional .caffepro.DataParameter_BigFile.ScaleJitterType scale_jitter_type = 18 [default = UniRatio];
  inline bool has_scale_jitter_type() const;
  inline void clear_scale_jitter_type();
  static const int kScaleJitterTypeFieldNumber = 18;
  inline ::caffepro::DataParameter_BigFile_ScaleJitterType scale_jitter_type() const;
  inline void set_scale_jitter_type(::caffepro::DataParameter_BigFile_ScaleJitterType value);
  
  // repeated .caffepro.DataProcesser additional_data_processer = 19;
  inline int additional_data_processer_size() const;
  inline void clear_additional_data_processer();
  static const int kAdditionalDataProcesserFieldNumber = 19;
  inline const ::caffepro::DataProcesser& additional_data_processer(int index) const;
  inline ::caffepro::DataProcesser* mutable_additional_data_processer(int index);
  inline ::caffepro::DataProcesser* add_additional_data_processer();
  inline const ::google::protobuf::RepeatedPtrField< ::caffepro::DataProcesser >&
      additional_data_processer() const;
  inline ::google::protobuf::RepeatedPtrField< ::caffepro::DataProcesser >*
      mutable_additional_data_processer();
  
  // optional bool cache_data = 20 [default = true];
  inline bool has_cache_data() const;
  inline void clear_cache_data();
  static const int kCacheDataFieldNumber = 20;
  inline bool cache_data() const;
  inline void set_cache_data(bool value);
  
  // optional string multilabel_def_file = 21;
  inline bool has_multilabel_def_file() const;
  inline void clear_multilabel_def_file();
  static const int kMultilabelDefFileFieldNumber = 21;
  inline const ::std::string& multilabel_def_file() const;
  inline void set_multilabel_def_file(const ::std::string& value);
  inline void set_multilabel_def_file(const char* value);
  inline void set_multilabel_def_file(const char* value, size_t size);
  inline ::std::string* mutable_multilabel_def_file();
  inline ::std::string* release_multilabel_def_file();
  
  // optional string metadata_file = 22;
  inline bool has_metadata_file() const;
  inline void clear_metadata_file();
  static const int kMetadataFileFieldNumber = 22;
  inline const ::std::string& metadata_file() const;
  inline void set_metadata_file(const ::std::string& value);
  inline void set_metadata_file(const char* value);
  inline void set_metadata_file(const char* value, size_t size);
  inline ::std::string* mutable_metadata_file();
  inline ::std::string* release_metadata_file();
  
  // optional float random_crop_overlap_threshold = 23 [default = 0];
  inline bool has_random_crop_overlap_threshold() const;
  inline void clear_random_crop_overlap_threshold();
  static const int kRandomCropOverlapThresholdFieldNumber = 23;
  inline float random_crop_overlap_threshold() const;
  inline void set_random_crop_overlap_threshold(float value);
  
  // optional .caffepro.DataParameter_BigFile.CropPreference crop_preference = 24 [default = IoCThres];
  inline bool has_crop_preference() const;
  inline void clear_crop_preference();
  static const int kCropPreferenceFieldNumber = 24;
  inline ::caffepro::DataParameter_BigFile_CropPreference crop_preference() const;
  inline void set_crop_preference(::caffepro::DataParameter_BigFile_CropPreference value);
  
  // optional int32 crop_dim1_segs = 25;
  inline bool has_crop_dim1_segs() const;
  inline void clear_crop_dim1_segs();
  static const int kCropDim1SegsFieldNumber = 25;
  inline ::google::protobuf::int32 crop_dim1_segs() const;
  inline void set_crop_dim1_segs(::google::protobuf::int32 value);
  
  // optional int32 crop_dim2_segs = 26;
  inline bool has_crop_dim2_segs() const;
  inline void clear_crop_dim2_segs();
  static const int kCropDim2SegsFieldNumber = 26;
  inline ::google::protobuf::int32 crop_dim2_segs() const;
  inline void set_crop_dim2_segs(::google::protobuf::int32 value);
  
  // optional string crop_box_file = 27;
  inline bool has_crop_box_file() const;
  inline void clear_crop_box_file();
  static const int kCropBoxFileFieldNumber = 27;
  inline const ::std::string& crop_box_file() const;
  inline void set_crop_box_file(const ::std::string& value);
  inline void set_crop_box_file(const char* value);
  inline void set_crop_box_file(const char* value, size_t size);
  inline ::std::string* mutable_crop_box_file();
  inline ::std::string* release_crop_box_file();
  
  // optional float rcnn_pad = 28;
  inline bool has_rcnn_pad() const;
  inline void clear_rcnn_pad();
  static const int kRcnnPadFieldNumber = 28;
  inline float rcnn_pad() const;
  inline void set_rcnn_pad(float value);
  
  // @@protoc_insertion_point(class_scope:caffepro.DataParameter_BigFile)
 private:
  inline void set_has_source();
  inline void clear_has_source();
  inline void set_has_scale();
  inline void clear_has_scale();
  inline void set_has_mean_file();
  inline void clear_has_mean_file();
  inline void set_has_batch_size();
  inline void clear_has_batch_size();
  inline void set_has_batch_img_size();
  inline void clear_has_batch_img_size();
  inline void set_has_crop_type();
  inline void clear_has_crop_type();
  inline void set_has_crop_ratio();
  inline void clear_has_crop_ratio();
  inline void set_has_color_kl_dir();
  inline void clear_has_color_kl_dir();
  inline void set_has_random_shuffle();
  inline void clear_has_random_shuffle();
  inline void set_has_overlap_thres();
  inline void clear_has_overlap_thres();
  inline void set_has_object_windows_dir();
  inline void clear_has_object_windows_dir();
  inline void set_has_crop_ratio_upperbound();
  inline void clear_has_crop_ratio_upperbound();
  inline void set_has_crop_ratio_lowerbound();
  inline void clear_has_crop_ratio_lowerbound();
  inline void set_has_aspect_ratio_variation();
  inline void clear_has_aspect_ratio_variation();
  inline void set_has_scale_jitter_type();
  inline void clear_has_scale_jitter_type();
  inline void set_has_cache_data();
  inline void clear_has_cache_data();
  inline void set_has_multilabel_def_file();
  inline void clear_has_multilabel_def_file();
  inline void set_has_metadata_file();
  inline void clear_has_metadata_file();
  inline void set_has_random_crop_overlap_threshold();
  inline void clear_has_random_crop_overlap_threshold();
  inline void set_has_crop_preference();
  inline void clear_has_crop_preference();
  inline void set_has_crop_dim1_segs();
  inline void clear_has_crop_dim1_segs();
  inline void set_has_crop_dim2_segs();
  inline void clear_has_crop_dim2_segs();
  inline void set_has_crop_box_file();
  inline void clear_has_crop_box_file();
  inline void set_has_rcnn_pad();
  inline void clear_has_rcnn_pad();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* source_;
  ::std::string* mean_file_;
  float scale_;
  ::google::protobuf::uint32 batch_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > channel_num_;
  ::google::protobuf::uint32 batch_img_size_;
  ::google::protobuf::uint32 crop_type_;
  ::std::string* color_kl_dir_;
  float crop_ratio_;
  float overlap_thres_;
  ::std::string* object_windows_dir_;
  float crop_ratio_upperbound_;
  float crop_ratio_lowerbound_;
  ::google::protobuf::RepeatedField<int> interpolation_;
  bool random_shuffle_;
  bool cache_data_;
  float aspect_ratio_variation_;
  ::google::protobuf::RepeatedPtrField< ::caffepro::DataProcesser > additional_data_processer_;
  int scale_jitter_type_;
  float random_crop_overlap_threshold_;
  ::std::string* multilabel_def_file_;
  ::std::string* metadata_file_;
  int crop_preference_;
  ::google::protobuf::int32 crop_dim1_segs_;
  ::std::string* crop_box_file_;
  ::google::protobuf::int32 crop_dim2_segs_;
  float rcnn_pad_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(27 + 31) / 32];
  
  friend void  protobuf_AddDesc_caffe_2eproto();
  friend void protobuf_AssignDesc_caffe_2eproto();
  friend void protobuf_ShutdownFile_caffe_2eproto();
  
  void InitAsDefaultInstance();
  static DataParameter_BigFile* default_instance_;
};
// -------------------------------------------------------------------

class DataEntryParameter : public ::google::protobuf::Message {
 public:
  DataEntryParameter();
  virtual ~DataEntryParameter();
  
  DataEntryParameter(const DataEntryParameter& from);
  
  inline DataEntryParameter& operator=(const DataEntryParameter& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const DataEntryParameter& default_instance();
  
  void Swap(DataEntryParameter* other);
  
  // implements Message ----------------------------------------------
  
  DataEntryParameter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DataEntryParameter& from);
  void MergeFrom(const DataEntryParameter& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string entry_name = 1;
  inline bool has_entry_name() const;
  inline void clear_entry_name();
  static const int kEntryNameFieldNumber = 1;
  inline const ::std::string& entry_name() const;
  inline void set_entry_name(const ::std::string& value);
  inline void set_entry_name(const char* value);
  inline void set_entry_name(const char* value, size_t size);
  inline ::std::string* mutable_entry_name();
  inline ::std::string* release_entry_name();
  
  // optional int32 entry_index = 2 [default = 0];
  inline bool has_entry_index() const;
  inline void clear_entry_index();
  static const int kEntryIndexFieldNumber = 2;
  inline ::google::protobuf::int32 entry_index() const;
  inline void set_entry_index(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:caffepro.DataEntryParameter)
 private:
  inline void set_has_entry_name();
  inline void clear_has_entry_name();
  inline void set_has_entry_index();
  inline void clear_has_entry_index();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* entry_name_;
  ::google::protobuf::int32 entry_index_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_caffe_2eproto();
  friend void protobuf_AssignDesc_caffe_2eproto();
  friend void protobuf_ShutdownFile_caffe_2eproto();
  
  void InitAsDefaultInstance();
  static DataEntryParameter* default_instance_;
};
// -------------------------------------------------------------------

class DropoutParameter : public ::google::protobuf::Message {
 public:
  DropoutParameter();
  virtual ~DropoutParameter();
  
  DropoutParameter(const DropoutParameter& from);
  
  inline DropoutParameter& operator=(const DropoutParameter& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const DropoutParameter& default_instance();
  
  void Swap(DropoutParameter* other);
  
  // implements Message ----------------------------------------------
  
  DropoutParameter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DropoutParameter& from);
  void MergeFrom(const DropoutParameter& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional float dropout_ratio = 1 [default = 0.5];
  inline bool has_dropout_ratio() const;
  inline void clear_dropout_ratio();
  static const int kDropoutRatioFieldNumber = 1;
  inline float dropout_ratio() const;
  inline void set_dropout_ratio(float value);
  
  // optional bool force_random = 2 [default = false];
  inline bool has_force_random() const;
  inline void clear_force_random();
  static const int kForceRandomFieldNumber = 2;
  inline bool force_random() const;
  inline void set_force_random(bool value);
  
  // optional bool force_same = 3 [default = false];
  inline bool has_force_same() const;
  inline void clear_force_same();
  static const int kForceSameFieldNumber = 3;
  inline bool force_same() const;
  inline void set_force_same(bool value);
  
  // @@protoc_insertion_point(class_scope:caffepro.DropoutParameter)
 private:
  inline void set_has_dropout_ratio();
  inline void clear_has_dropout_ratio();
  inline void set_has_force_random();
  inline void clear_has_force_random();
  inline void set_has_force_same();
  inline void clear_has_force_same();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  float dropout_ratio_;
  bool force_random_;
  bool force_same_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_caffe_2eproto();
  friend void protobuf_AssignDesc_caffe_2eproto();
  friend void protobuf_ShutdownFile_caffe_2eproto();
  
  void InitAsDefaultInstance();
  static DropoutParameter* default_instance_;
};
// -------------------------------------------------------------------

class PaddingParameter : public ::google::protobuf::Message {
 public:
  PaddingParameter();
  virtual ~PaddingParameter();
  
  PaddingParameter(const PaddingParameter& from);
  
  inline PaddingParameter& operator=(const PaddingParameter& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PaddingParameter& default_instance();
  
  void Swap(PaddingParameter* other);
  
  // implements Message ----------------------------------------------
  
  PaddingParameter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PaddingParameter& from);
  void MergeFrom(const PaddingParameter& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional uint32 pad = 1 [default = 0];
  inline bool has_pad() const;
  inline void clear_pad();
  static const int kPadFieldNumber = 1;
  inline ::google::protobuf::uint32 pad() const;
  inline void set_pad(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:caffepro.PaddingParameter)
 private:
  inline void set_has_pad();
  inline void clear_has_pad();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint32 pad_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_caffe_2eproto();
  friend void protobuf_AssignDesc_caffe_2eproto();
  friend void protobuf_ShutdownFile_caffe_2eproto();
  
  void InitAsDefaultInstance();
  static PaddingParameter* default_instance_;
};
// -------------------------------------------------------------------

class InfogainLossParameter : public ::google::protobuf::Message {
 public:
  InfogainLossParameter();
  virtual ~InfogainLossParameter();
  
  InfogainLossParameter(const InfogainLossParameter& from);
  
  inline InfogainLossParameter& operator=(const InfogainLossParameter& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const InfogainLossParameter& default_instance();
  
  void Swap(InfogainLossParameter* other);
  
  // implements Message ----------------------------------------------
  
  InfogainLossParameter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InfogainLossParameter& from);
  void MergeFrom(const InfogainLossParameter& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string source = 1;
  inline bool has_source() const;
  inline void clear_source();
  static const int kSourceFieldNumber = 1;
  inline const ::std::string& source() const;
  inline void set_source(const ::std::string& value);
  inline void set_source(const char* value);
  inline void set_source(const char* value, size_t size);
  inline ::std::string* mutable_source();
  inline ::std::string* release_source();
  
  // @@protoc_insertion_point(class_scope:caffepro.InfogainLossParameter)
 private:
  inline void set_has_source();
  inline void clear_has_source();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* source_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_caffe_2eproto();
  friend void protobuf_AssignDesc_caffe_2eproto();
  friend void protobuf_ShutdownFile_caffe_2eproto();
  
  void InitAsDefaultInstance();
  static InfogainLossParameter* default_instance_;
};
// -------------------------------------------------------------------

class LossParameter : public ::google::protobuf::Message {
 public:
  LossParameter();
  virtual ~LossParameter();
  
  LossParameter(const LossParameter& from);
  
  inline LossParameter& operator=(const LossParameter& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const LossParameter& default_instance();
  
  void Swap(LossParameter* other);
  
  // implements Message ----------------------------------------------
  
  LossParameter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LossParameter& from);
  void MergeFrom(const LossParameter& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional float coeff = 1 [default = 1];
  inline bool has_coeff() const;
  inline void clear_coeff();
  static const int kCoeffFieldNumber = 1;
  inline float coeff() const;
  inline void set_coeff(float value);
  
  // optional bool display_result = 2 [default = true];
  inline bool has_display_result() const;
  inline void clear_display_result();
  static const int kDisplayResultFieldNumber = 2;
  inline bool display_result() const;
  inline void set_display_result(bool value);
  
  // @@protoc_insertion_point(class_scope:caffepro.LossParameter)
 private:
  inline void set_has_coeff();
  inline void clear_has_coeff();
  inline void set_has_display_result();
  inline void clear_has_display_result();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  float coeff_;
  bool display_result_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_caffe_2eproto();
  friend void protobuf_AssignDesc_caffe_2eproto();
  friend void protobuf_ShutdownFile_caffe_2eproto();
  
  void InitAsDefaultInstance();
  static LossParameter* default_instance_;
};
// -------------------------------------------------------------------

class ClsLocLossParameter : public ::google::protobuf::Message {
 public:
  ClsLocLossParameter();
  virtual ~ClsLocLossParameter();
  
  ClsLocLossParameter(const ClsLocLossParameter& from);
  
  inline ClsLocLossParameter& operator=(const ClsLocLossParameter& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ClsLocLossParameter& default_instance();
  
  void Swap(ClsLocLossParameter* other);
  
  // implements Message ----------------------------------------------
  
  ClsLocLossParameter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClsLocLossParameter& from);
  void MergeFrom(const ClsLocLossParameter& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef ClsLocLossParameter_LocType LocType;
  static const LocType PCR = ClsLocLossParameter_LocType_PCR;
  static const LocType SCR = ClsLocLossParameter_LocType_SCR;
  static const LocType USER_DEFINED = ClsLocLossParameter_LocType_USER_DEFINED;
  static inline bool LocType_IsValid(int value) {
    return ClsLocLossParameter_LocType_IsValid(value);
  }
  static const LocType LocType_MIN =
    ClsLocLossParameter_LocType_LocType_MIN;
  static const LocType LocType_MAX =
    ClsLocLossParameter_LocType_LocType_MAX;
  static const int LocType_ARRAYSIZE =
    ClsLocLossParameter_LocType_LocType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  LocType_descriptor() {
    return ClsLocLossParameter_LocType_descriptor();
  }
  static inline const ::std::string& LocType_Name(LocType value) {
    return ClsLocLossParameter_LocType_Name(value);
  }
  static inline bool LocType_Parse(const ::std::string& name,
      LocType* value) {
    return ClsLocLossParameter_LocType_Parse(name, value);
  }
  
  typedef ClsLocLossParameter_LossTransform LossTransform;
  static const LossTransform LTRB = ClsLocLossParameter_LossTransform_LTRB;
  static const LossTransform CX_CY_LOGW_LOGH = ClsLocLossParameter_LossTransform_CX_CY_LOGW_LOGH;
  static inline bool LossTransform_IsValid(int value) {
    return ClsLocLossParameter_LossTransform_IsValid(value);
  }
  static const LossTransform LossTransform_MIN =
    ClsLocLossParameter_LossTransform_LossTransform_MIN;
  static const LossTransform LossTransform_MAX =
    ClsLocLossParameter_LossTransform_LossTransform_MAX;
  static const int LossTransform_ARRAYSIZE =
    ClsLocLossParameter_LossTransform_LossTransform_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  LossTransform_descriptor() {
    return ClsLocLossParameter_LossTransform_descriptor();
  }
  static inline const ::std::string& LossTransform_Name(LossTransform value) {
    return ClsLocLossParameter_LossTransform_Name(value);
  }
  static inline bool LossTransform_Parse(const ::std::string& name,
      LossTransform* value) {
    return ClsLocLossParameter_LossTransform_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // optional float cls_coeff = 1 [default = 1];
  inline bool has_cls_coeff() const;
  inline void clear_cls_coeff();
  static const int kClsCoeffFieldNumber = 1;
  inline float cls_coeff() const;
  inline void set_cls_coeff(float value);
  
  // optional float loc_coeff = 2 [default = 1];
  inline bool has_loc_coeff() const;
  inline void clear_loc_coeff();
  static const int kLocCoeffFieldNumber = 2;
  inline float loc_coeff() const;
  inline void set_loc_coeff(float value);
  
  // optional .caffepro.ClsLocLossParameter.LocType loc_type = 3 [default = PCR];
  inline bool has_loc_type() const;
  inline void clear_loc_type();
  static const int kLocTypeFieldNumber = 3;
  inline ::caffepro::ClsLocLossParameter_LocType loc_type() const;
  inline void set_loc_type(::caffepro::ClsLocLossParameter_LocType value);
  
  // optional string user_def_file = 4;
  inline bool has_user_def_file() const;
  inline void clear_user_def_file();
  static const int kUserDefFileFieldNumber = 4;
  inline const ::std::string& user_def_file() const;
  inline void set_user_def_file(const ::std::string& value);
  inline void set_user_def_file(const char* value);
  inline void set_user_def_file(const char* value, size_t size);
  inline ::std::string* mutable_user_def_file();
  inline ::std::string* release_user_def_file();
  
  // optional .caffepro.ClsLocLossParameter.LossTransform loss_transform = 5 [default = LTRB];
  inline bool has_loss_transform() const;
  inline void clear_loss_transform();
  static const int kLossTransformFieldNumber = 5;
  inline ::caffepro::ClsLocLossParameter_LossTransform loss_transform() const;
  inline void set_loss_transform(::caffepro::ClsLocLossParameter_LossTransform value);
  
  // optional float assign_reject_iou = 6 [default = 0.2];
  inline bool has_assign_reject_iou() const;
  inline void clear_assign_reject_iou();
  static const int kAssignRejectIouFieldNumber = 6;
  inline float assign_reject_iou() const;
  inline void set_assign_reject_iou(float value);
  
  // optional float cls_pos_iou = 7 [default = 0.5];
  inline bool has_cls_pos_iou() const;
  inline void clear_cls_pos_iou();
  static const int kClsPosIouFieldNumber = 7;
  inline float cls_pos_iou() const;
  inline void set_cls_pos_iou(float value);
  
  // optional float cls_neg_iou = 8 [default = 0.2];
  inline bool has_cls_neg_iou() const;
  inline void clear_cls_neg_iou();
  static const int kClsNegIouFieldNumber = 8;
  inline float cls_neg_iou() const;
  inline void set_cls_neg_iou(float value);
  
  // optional bool prediction_box_classification = 9 [default = false];
  inline bool has_prediction_box_classification() const;
  inline void clear_prediction_box_classification();
  static const int kPredictionBoxClassificationFieldNumber = 9;
  inline bool prediction_box_classification() const;
  inline void set_prediction_box_classification(bool value);
  
  // optional bool auto_spatial_anchor = 10 [default = false];
  inline bool has_auto_spatial_anchor() const;
  inline void clear_auto_spatial_anchor();
  static const int kAutoSpatialAnchorFieldNumber = 10;
  inline bool auto_spatial_anchor() const;
  inline void set_auto_spatial_anchor(bool value);
  
  // optional int32 expected_pos_num = 11 [default = -1];
  inline bool has_expected_pos_num() const;
  inline void clear_expected_pos_num();
  static const int kExpectedPosNumFieldNumber = 11;
  inline ::google::protobuf::int32 expected_pos_num() const;
  inline void set_expected_pos_num(::google::protobuf::int32 value);
  
  // optional int32 expected_neg_num = 12 [default = -1];
  inline bool has_expected_neg_num() const;
  inline void clear_expected_neg_num();
  static const int kExpectedNegNumFieldNumber = 12;
  inline ::google::protobuf::int32 expected_neg_num() const;
  inline void set_expected_neg_num(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:caffepro.ClsLocLossParameter)
 private:
  inline void set_has_cls_coeff();
  inline void clear_has_cls_coeff();
  inline void set_has_loc_coeff();
  inline void clear_has_loc_coeff();
  inline void set_has_loc_type();
  inline void clear_has_loc_type();
  inline void set_has_user_def_file();
  inline void clear_has_user_def_file();
  inline void set_has_loss_transform();
  inline void clear_has_loss_transform();
  inline void set_has_assign_reject_iou();
  inline void clear_has_assign_reject_iou();
  inline void set_has_cls_pos_iou();
  inline void clear_has_cls_pos_iou();
  inline void set_has_cls_neg_iou();
  inline void clear_has_cls_neg_iou();
  inline void set_has_prediction_box_classification();
  inline void clear_has_prediction_box_classification();
  inline void set_has_auto_spatial_anchor();
  inline void clear_has_auto_spatial_anchor();
  inline void set_has_expected_pos_num();
  inline void clear_has_expected_pos_num();
  inline void set_has_expected_neg_num();
  inline void clear_has_expected_neg_num();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  float cls_coeff_;
  float loc_coeff_;
  ::std::string* user_def_file_;
  int loc_type_;
  int loss_transform_;
  float assign_reject_iou_;
  float cls_pos_iou_;
  float cls_neg_iou_;
  bool prediction_box_classification_;
  bool auto_spatial_anchor_;
  ::google::protobuf::int32 expected_pos_num_;
  ::google::protobuf::int32 expected_neg_num_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];
  
  friend void  protobuf_AddDesc_caffe_2eproto();
  friend void protobuf_AssignDesc_caffe_2eproto();
  friend void protobuf_ShutdownFile_caffe_2eproto();
  
  void InitAsDefaultInstance();
  static ClsLocLossParameter* default_instance_;
};
// -------------------------------------------------------------------

class InnerProductParameter : public ::google::protobuf::Message {
 public:
  InnerProductParameter();
  virtual ~InnerProductParameter();
  
  InnerProductParameter(const InnerProductParameter& from);
  
  inline InnerProductParameter& operator=(const InnerProductParameter& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const InnerProductParameter& default_instance();
  
  void Swap(InnerProductParameter* other);
  
  // implements Message ----------------------------------------------
  
  InnerProductParameter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InnerProductParameter& from);
  void MergeFrom(const InnerProductParameter& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional uint32 num_output = 1;
  inline bool has_num_output() const;
  inline void clear_num_output();
  static const int kNumOutputFieldNumber = 1;
  inline ::google::protobuf::uint32 num_output() const;
  inline void set_num_output(::google::protobuf::uint32 value);
  
  // optional bool bias_term = 2 [default = true];
  inline bool has_bias_term() const;
  inline void clear_bias_term();
  static const int kBiasTermFieldNumber = 2;
  inline bool bias_term() const;
  inline void set_bias_term(bool value);
  
  // optional .caffepro.FillerParameter weight_filler = 3;
  inline bool has_weight_filler() const;
  inline void clear_weight_filler();
  static const int kWeightFillerFieldNumber = 3;
  inline const ::caffepro::FillerParameter& weight_filler() const;
  inline ::caffepro::FillerParameter* mutable_weight_filler();
  inline ::caffepro::FillerParameter* release_weight_filler();
  
  // optional .caffepro.FillerParameter bias_filler = 4;
  inline bool has_bias_filler() const;
  inline void clear_bias_filler();
  static const int kBiasFillerFieldNumber = 4;
  inline const ::caffepro::FillerParameter& bias_filler() const;
  inline ::caffepro::FillerParameter* mutable_bias_filler();
  inline ::caffepro::FillerParameter* release_bias_filler();
  
  // optional bool update_inplace = 5 [default = false];
  inline bool has_update_inplace() const;
  inline void clear_update_inplace();
  static const int kUpdateInplaceFieldNumber = 5;
  inline bool update_inplace() const;
  inline void set_update_inplace(bool value);
  
  // @@protoc_insertion_point(class_scope:caffepro.InnerProductParameter)
 private:
  inline void set_has_num_output();
  inline void clear_has_num_output();
  inline void set_has_bias_term();
  inline void clear_has_bias_term();
  inline void set_has_weight_filler();
  inline void clear_has_weight_filler();
  inline void set_has_bias_filler();
  inline void clear_has_bias_filler();
  inline void set_has_update_inplace();
  inline void clear_has_update_inplace();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint32 num_output_;
  bool bias_term_;
  bool update_inplace_;
  ::caffepro::FillerParameter* weight_filler_;
  ::caffepro::FillerParameter* bias_filler_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_caffe_2eproto();
  friend void protobuf_AssignDesc_caffe_2eproto();
  friend void protobuf_ShutdownFile_caffe_2eproto();
  
  void InitAsDefaultInstance();
  static InnerProductParameter* default_instance_;
};
// -------------------------------------------------------------------

class LRNParameter : public ::google::protobuf::Message {
 public:
  LRNParameter();
  virtual ~LRNParameter();
  
  LRNParameter(const LRNParameter& from);
  
  inline LRNParameter& operator=(const LRNParameter& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const LRNParameter& default_instance();
  
  void Swap(LRNParameter* other);
  
  // implements Message ----------------------------------------------
  
  LRNParameter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LRNParameter& from);
  void MergeFrom(const LRNParameter& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef LRNParameter_NormRegion NormRegion;
  static const NormRegion ACROSS_CHANNELS = LRNParameter_NormRegion_ACROSS_CHANNELS;
  static const NormRegion WITHIN_CHANNEL = LRNParameter_NormRegion_WITHIN_CHANNEL;
  static inline bool NormRegion_IsValid(int value) {
    return LRNParameter_NormRegion_IsValid(value);
  }
  static const NormRegion NormRegion_MIN =
    LRNParameter_NormRegion_NormRegion_MIN;
  static const NormRegion NormRegion_MAX =
    LRNParameter_NormRegion_NormRegion_MAX;
  static const int NormRegion_ARRAYSIZE =
    LRNParameter_NormRegion_NormRegion_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  NormRegion_descriptor() {
    return LRNParameter_NormRegion_descriptor();
  }
  static inline const ::std::string& NormRegion_Name(NormRegion value) {
    return LRNParameter_NormRegion_Name(value);
  }
  static inline bool NormRegion_Parse(const ::std::string& name,
      NormRegion* value) {
    return LRNParameter_NormRegion_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // optional uint32 local_size = 1 [default = 5];
  inline bool has_local_size() const;
  inline void clear_local_size();
  static const int kLocalSizeFieldNumber = 1;
  inline ::google::protobuf::uint32 local_size() const;
  inline void set_local_size(::google::protobuf::uint32 value);
  
  // optional float alpha = 2 [default = 1];
  inline bool has_alpha() const;
  inline void clear_alpha();
  static const int kAlphaFieldNumber = 2;
  inline float alpha() const;
  inline void set_alpha(float value);
  
  // optional float beta = 3 [default = 0.75];
  inline bool has_beta() const;
  inline void clear_beta();
  static const int kBetaFieldNumber = 3;
  inline float beta() const;
  inline void set_beta(float value);
  
  // optional .caffepro.LRNParameter.NormRegion norm_region = 4 [default = ACROSS_CHANNELS];
  inline bool has_norm_region() const;
  inline void clear_norm_region();
  static const int kNormRegionFieldNumber = 4;
  inline ::caffepro::LRNParameter_NormRegion norm_region() const;
  inline void set_norm_region(::caffepro::LRNParameter_NormRegion value);
  
  // @@protoc_insertion_point(class_scope:caffepro.LRNParameter)
 private:
  inline void set_has_local_size();
  inline void clear_has_local_size();
  inline void set_has_alpha();
  inline void clear_has_alpha();
  inline void set_has_beta();
  inline void clear_has_beta();
  inline void set_has_norm_region();
  inline void clear_has_norm_region();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint32 local_size_;
  float alpha_;
  float beta_;
  int norm_region_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_caffe_2eproto();
  friend void protobuf_AssignDesc_caffe_2eproto();
  friend void protobuf_ShutdownFile_caffe_2eproto();
  
  void InitAsDefaultInstance();
  static LRNParameter* default_instance_;
};
// -------------------------------------------------------------------

class PoolingParameter : public ::google::protobuf::Message {
 public:
  PoolingParameter();
  virtual ~PoolingParameter();
  
  PoolingParameter(const PoolingParameter& from);
  
  inline PoolingParameter& operator=(const PoolingParameter& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PoolingParameter& default_instance();
  
  void Swap(PoolingParameter* other);
  
  // implements Message ----------------------------------------------
  
  PoolingParameter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PoolingParameter& from);
  void MergeFrom(const PoolingParameter& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef PoolingParameter_PoolMethod PoolMethod;
  static const PoolMethod MAX = PoolingParameter_PoolMethod_MAX;
  static const PoolMethod AVE = PoolingParameter_PoolMethod_AVE;
  static const PoolMethod STOCHASTIC = PoolingParameter_PoolMethod_STOCHASTIC;
  static inline bool PoolMethod_IsValid(int value) {
    return PoolingParameter_PoolMethod_IsValid(value);
  }
  static const PoolMethod PoolMethod_MIN =
    PoolingParameter_PoolMethod_PoolMethod_MIN;
  static const PoolMethod PoolMethod_MAX =
    PoolingParameter_PoolMethod_PoolMethod_MAX;
  static const int PoolMethod_ARRAYSIZE =
    PoolingParameter_PoolMethod_PoolMethod_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  PoolMethod_descriptor() {
    return PoolingParameter_PoolMethod_descriptor();
  }
  static inline const ::std::string& PoolMethod_Name(PoolMethod value) {
    return PoolingParameter_PoolMethod_Name(value);
  }
  static inline bool PoolMethod_Parse(const ::std::string& name,
      PoolMethod* value) {
    return PoolingParameter_PoolMethod_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // optional .caffepro.PoolingParameter.PoolMethod pool = 1 [default = MAX];
  inline bool has_pool() const;
  inline void clear_pool();
  static const int kPoolFieldNumber = 1;
  inline ::caffepro::PoolingParameter_PoolMethod pool() const;
  inline void set_pool(::caffepro::PoolingParameter_PoolMethod value);
  
  // optional uint32 kernel_size = 2;
  inline bool has_kernel_size() const;
  inline void clear_kernel_size();
  static const int kKernelSizeFieldNumber = 2;
  inline ::google::protobuf::uint32 kernel_size() const;
  inline void set_kernel_size(::google::protobuf::uint32 value);
  
  // optional uint32 stride = 3 [default = 1];
  inline bool has_stride() const;
  inline void clear_stride();
  static const int kStrideFieldNumber = 3;
  inline ::google::protobuf::uint32 stride() const;
  inline void set_stride(::google::protobuf::uint32 value);
  
  // optional bool size_floor = 4 [default = false];
  inline bool has_size_floor() const;
  inline void clear_size_floor();
  static const int kSizeFloorFieldNumber = 4;
  inline bool size_floor() const;
  inline void set_size_floor(bool value);
  
  // optional int32 pad = 5 [default = 0];
  inline bool has_pad() const;
  inline void clear_pad();
  static const int kPadFieldNumber = 5;
  inline ::google::protobuf::int32 pad() const;
  inline void set_pad(::google::protobuf::int32 value);
  
  // optional int32 pad_x = 6 [default = 0];
  inline bool has_pad_x() const;
  inline void clear_pad_x();
  static const int kPadXFieldNumber = 6;
  inline ::google::protobuf::int32 pad_x() const;
  inline void set_pad_x(::google::protobuf::int32 value);
  
  // optional int32 pad_y = 7 [default = 0];
  inline bool has_pad_y() const;
  inline void clear_pad_y();
  static const int kPadYFieldNumber = 7;
  inline ::google::protobuf::int32 pad_y() const;
  inline void set_pad_y(::google::protobuf::int32 value);
  
  // optional int32 kernel_size_x = 8 [default = 0];
  inline bool has_kernel_size_x() const;
  inline void clear_kernel_size_x();
  static const int kKernelSizeXFieldNumber = 8;
  inline ::google::protobuf::int32 kernel_size_x() const;
  inline void set_kernel_size_x(::google::protobuf::int32 value);
  
  // optional int32 kernel_size_y = 9 [default = 0];
  inline bool has_kernel_size_y() const;
  inline void clear_kernel_size_y();
  static const int kKernelSizeYFieldNumber = 9;
  inline ::google::protobuf::int32 kernel_size_y() const;
  inline void set_kernel_size_y(::google::protobuf::int32 value);
  
  // optional int32 stride_x = 10 [default = 1];
  inline bool has_stride_x() const;
  inline void clear_stride_x();
  static const int kStrideXFieldNumber = 10;
  inline ::google::protobuf::int32 stride_x() const;
  inline void set_stride_x(::google::protobuf::int32 value);
  
  // optional int32 stride_y = 11 [default = 1];
  inline bool has_stride_y() const;
  inline void clear_stride_y();
  static const int kStrideYFieldNumber = 11;
  inline ::google::protobuf::int32 stride_y() const;
  inline void set_stride_y(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:caffepro.PoolingParameter)
 private:
  inline void set_has_pool();
  inline void clear_has_pool();
  inline void set_has_kernel_size();
  inline void clear_has_kernel_size();
  inline void set_has_stride();
  inline void clear_has_stride();
  inline void set_has_size_floor();
  inline void clear_has_size_floor();
  inline void set_has_pad();
  inline void clear_has_pad();
  inline void set_has_pad_x();
  inline void clear_has_pad_x();
  inline void set_has_pad_y();
  inline void clear_has_pad_y();
  inline void set_has_kernel_size_x();
  inline void clear_has_kernel_size_x();
  inline void set_has_kernel_size_y();
  inline void clear_has_kernel_size_y();
  inline void set_has_stride_x();
  inline void clear_has_stride_x();
  inline void set_has_stride_y();
  inline void clear_has_stride_y();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  int pool_;
  ::google::protobuf::uint32 kernel_size_;
  ::google::protobuf::uint32 stride_;
  bool size_floor_;
  ::google::protobuf::int32 pad_;
  ::google::protobuf::int32 pad_x_;
  ::google::protobuf::int32 pad_y_;
  ::google::protobuf::int32 kernel_size_x_;
  ::google::protobuf::int32 kernel_size_y_;
  ::google::protobuf::int32 stride_x_;
  ::google::protobuf::int32 stride_y_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];
  
  friend void  protobuf_AddDesc_caffe_2eproto();
  friend void protobuf_AssignDesc_caffe_2eproto();
  friend void protobuf_ShutdownFile_caffe_2eproto();
  
  void InitAsDefaultInstance();
  static PoolingParameter* default_instance_;
};
// -------------------------------------------------------------------

class SPMParameter : public ::google::protobuf::Message {
 public:
  SPMParameter();
  virtual ~SPMParameter();
  
  SPMParameter(const SPMParameter& from);
  
  inline SPMParameter& operator=(const SPMParameter& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SPMParameter& default_instance();
  
  void Swap(SPMParameter* other);
  
  // implements Message ----------------------------------------------
  
  SPMParameter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SPMParameter& from);
  void MergeFrom(const SPMParameter& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef SPMParameter_PoolMethod PoolMethod;
  static const PoolMethod MAX = SPMParameter_PoolMethod_MAX;
  static const PoolMethod AVE = SPMParameter_PoolMethod_AVE;
  static const PoolMethod STOCHASTIC = SPMParameter_PoolMethod_STOCHASTIC;
  static inline bool PoolMethod_IsValid(int value) {
    return SPMParameter_PoolMethod_IsValid(value);
  }
  static const PoolMethod PoolMethod_MIN =
    SPMParameter_PoolMethod_PoolMethod_MIN;
  static const PoolMethod PoolMethod_MAX =
    SPMParameter_PoolMethod_PoolMethod_MAX;
  static const int PoolMethod_ARRAYSIZE =
    SPMParameter_PoolMethod_PoolMethod_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  PoolMethod_descriptor() {
    return SPMParameter_PoolMethod_descriptor();
  }
  static inline const ::std::string& PoolMethod_Name(PoolMethod value) {
    return SPMParameter_PoolMethod_Name(value);
  }
  static inline bool PoolMethod_Parse(const ::std::string& name,
      PoolMethod* value) {
    return SPMParameter_PoolMethod_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // optional .caffepro.SPMParameter.PoolMethod pool = 1 [default = MAX];
  inline bool has_pool() const;
  inline void clear_pool();
  static const int kPoolFieldNumber = 1;
  inline ::caffepro::SPMParameter_PoolMethod pool() const;
  inline void set_pool(::caffepro::SPMParameter_PoolMethod value);
  
  // optional uint32 cell_x = 2;
  inline bool has_cell_x() const;
  inline void clear_cell_x();
  static const int kCellXFieldNumber = 2;
  inline ::google::protobuf::uint32 cell_x() const;
  inline void set_cell_x(::google::protobuf::uint32 value);
  
  // optional uint32 cell_y = 3;
  inline bool has_cell_y() const;
  inline void clear_cell_y();
  static const int kCellYFieldNumber = 3;
  inline ::google::protobuf::uint32 cell_y() const;
  inline void set_cell_y(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:caffepro.SPMParameter)
 private:
  inline void set_has_pool();
  inline void clear_has_pool();
  inline void set_has_cell_x();
  inline void clear_has_cell_x();
  inline void set_has_cell_y();
  inline void clear_has_cell_y();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  int pool_;
  ::google::protobuf::uint32 cell_x_;
  ::google::protobuf::uint32 cell_y_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_caffe_2eproto();
  friend void protobuf_AssignDesc_caffe_2eproto();
  friend void protobuf_ShutdownFile_caffe_2eproto();
  
  void InitAsDefaultInstance();
  static SPMParameter* default_instance_;
};
// -------------------------------------------------------------------

class PowerParameter : public ::google::protobuf::Message {
 public:
  PowerParameter();
  virtual ~PowerParameter();
  
  PowerParameter(const PowerParameter& from);
  
  inline PowerParameter& operator=(const PowerParameter& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PowerParameter& default_instance();
  
  void Swap(PowerParameter* other);
  
  // implements Message ----------------------------------------------
  
  PowerParameter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PowerParameter& from);
  void MergeFrom(const PowerParameter& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional float power = 1 [default = 1];
  inline bool has_power() const;
  inline void clear_power();
  static const int kPowerFieldNumber = 1;
  inline float power() const;
  inline void set_power(float value);
  
  // optional float scale = 2 [default = 1];
  inline bool has_scale() const;
  inline void clear_scale();
  static const int kScaleFieldNumber = 2;
  inline float scale() const;
  inline void set_scale(float value);
  
  // optional float shift = 3 [default = 0];
  inline bool has_shift() const;
  inline void clear_shift();
  static const int kShiftFieldNumber = 3;
  inline float shift() const;
  inline void set_shift(float value);
  
  // @@protoc_insertion_point(class_scope:caffepro.PowerParameter)
 private:
  inline void set_has_power();
  inline void clear_has_power();
  inline void set_has_scale();
  inline void clear_has_scale();
  inline void set_has_shift();
  inline void clear_has_shift();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  float power_;
  float scale_;
  float shift_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_caffe_2eproto();
  friend void protobuf_AssignDesc_caffe_2eproto();
  friend void protobuf_ShutdownFile_caffe_2eproto();
  
  void InitAsDefaultInstance();
  static PowerParameter* default_instance_;
};
// -------------------------------------------------------------------

class LayerConnection : public ::google::protobuf::Message {
 public:
  LayerConnection();
  virtual ~LayerConnection();
  
  LayerConnection(const LayerConnection& from);
  
  inline LayerConnection& operator=(const LayerConnection& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const LayerConnection& default_instance();
  
  void Swap(LayerConnection* other);
  
  // implements Message ----------------------------------------------
  
  LayerConnection* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LayerConnection& from);
  void MergeFrom(const LayerConnection& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .caffepro.LayerParameter layer = 1;
  inline bool has_layer() const;
  inline void clear_layer();
  static const int kLayerFieldNumber = 1;
  inline const ::caffepro::LayerParameter& layer() const;
  inline ::caffepro::LayerParameter* mutable_layer();
  inline ::caffepro::LayerParameter* release_layer();
  
  // repeated string bottom = 2;
  inline int bottom_size() const;
  inline void clear_bottom();
  static const int kBottomFieldNumber = 2;
  inline const ::std::string& bottom(int index) const;
  inline ::std::string* mutable_bottom(int index);
  inline void set_bottom(int index, const ::std::string& value);
  inline void set_bottom(int index, const char* value);
  inline void set_bottom(int index, const char* value, size_t size);
  inline ::std::string* add_bottom();
  inline void add_bottom(const ::std::string& value);
  inline void add_bottom(const char* value);
  inline void add_bottom(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& bottom() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_bottom();
  
  // repeated string top = 3;
  inline int top_size() const;
  inline void clear_top();
  static const int kTopFieldNumber = 3;
  inline const ::std::string& top(int index) const;
  inline ::std::string* mutable_top(int index);
  inline void set_top(int index, const ::std::string& value);
  inline void set_top(int index, const char* value);
  inline void set_top(int index, const char* value, size_t size);
  inline ::std::string* add_top();
  inline void add_top(const ::std::string& value);
  inline void add_top(const char* value);
  inline void add_top(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& top() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_top();
  
  // @@protoc_insertion_point(class_scope:caffepro.LayerConnection)
 private:
  inline void set_has_layer();
  inline void clear_has_layer();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::caffepro::LayerParameter* layer_;
  ::google::protobuf::RepeatedPtrField< ::std::string> bottom_;
  ::google::protobuf::RepeatedPtrField< ::std::string> top_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_caffe_2eproto();
  friend void protobuf_AssignDesc_caffe_2eproto();
  friend void protobuf_ShutdownFile_caffe_2eproto();
  
  void InitAsDefaultInstance();
  static LayerConnection* default_instance_;
};
// -------------------------------------------------------------------

class NetParameter : public ::google::protobuf::Message {
 public:
  NetParameter();
  virtual ~NetParameter();
  
  NetParameter(const NetParameter& from);
  
  inline NetParameter& operator=(const NetParameter& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const NetParameter& default_instance();
  
  void Swap(NetParameter* other);
  
  // implements Message ----------------------------------------------
  
  NetParameter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NetParameter& from);
  void MergeFrom(const NetParameter& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // repeated .caffepro.LayerConnection layers = 2;
  inline int layers_size() const;
  inline void clear_layers();
  static const int kLayersFieldNumber = 2;
  inline const ::caffepro::LayerConnection& layers(int index) const;
  inline ::caffepro::LayerConnection* mutable_layers(int index);
  inline ::caffepro::LayerConnection* add_layers();
  inline const ::google::protobuf::RepeatedPtrField< ::caffepro::LayerConnection >&
      layers() const;
  inline ::google::protobuf::RepeatedPtrField< ::caffepro::LayerConnection >*
      mutable_layers();
  
  // repeated string input = 3;
  inline int input_size() const;
  inline void clear_input();
  static const int kInputFieldNumber = 3;
  inline const ::std::string& input(int index) const;
  inline ::std::string* mutable_input(int index);
  inline void set_input(int index, const ::std::string& value);
  inline void set_input(int index, const char* value);
  inline void set_input(int index, const char* value, size_t size);
  inline ::std::string* add_input();
  inline void add_input(const ::std::string& value);
  inline void add_input(const char* value);
  inline void add_input(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& input() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_input();
  
  // repeated int32 input_dim = 4;
  inline int input_dim_size() const;
  inline void clear_input_dim();
  static const int kInputDimFieldNumber = 4;
  inline ::google::protobuf::int32 input_dim(int index) const;
  inline void set_input_dim(int index, ::google::protobuf::int32 value);
  inline void add_input_dim(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      input_dim() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_input_dim();
  
  // optional bool force_backward = 5 [default = false];
  inline bool has_force_backward() const;
  inline void clear_force_backward();
  static const int kForceBackwardFieldNumber = 5;
  inline bool force_backward() const;
  inline void set_force_backward(bool value);
  
  // optional string config_file = 6;
  inline bool has_config_file() const;
  inline void clear_config_file();
  static const int kConfigFileFieldNumber = 6;
  inline const ::std::string& config_file() const;
  inline void set_config_file(const ::std::string& value);
  inline void set_config_file(const char* value);
  inline void set_config_file(const char* value, size_t size);
  inline ::std::string* mutable_config_file();
  inline ::std::string* release_config_file();
  
  // optional string data_provider_name = 7;
  inline bool has_data_provider_name() const;
  inline void clear_data_provider_name();
  static const int kDataProviderNameFieldNumber = 7;
  inline const ::std::string& data_provider_name() const;
  inline void set_data_provider_name(const ::std::string& value);
  inline void set_data_provider_name(const char* value);
  inline void set_data_provider_name(const char* value, size_t size);
  inline ::std::string* mutable_data_provider_name();
  inline ::std::string* release_data_provider_name();
  
  // @@protoc_insertion_point(class_scope:caffepro.NetParameter)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_force_backward();
  inline void clear_has_force_backward();
  inline void set_has_config_file();
  inline void clear_has_config_file();
  inline void set_has_data_provider_name();
  inline void clear_has_data_provider_name();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* name_;
  ::google::protobuf::RepeatedPtrField< ::caffepro::LayerConnection > layers_;
  ::google::protobuf::RepeatedPtrField< ::std::string> input_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > input_dim_;
  ::std::string* config_file_;
  ::std::string* data_provider_name_;
  bool force_backward_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  friend void  protobuf_AddDesc_caffe_2eproto();
  friend void protobuf_AssignDesc_caffe_2eproto();
  friend void protobuf_ShutdownFile_caffe_2eproto();
  
  void InitAsDefaultInstance();
  static NetParameter* default_instance_;
};
// -------------------------------------------------------------------

class SolverParameter : public ::google::protobuf::Message {
 public:
  SolverParameter();
  virtual ~SolverParameter();
  
  SolverParameter(const SolverParameter& from);
  
  inline SolverParameter& operator=(const SolverParameter& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SolverParameter& default_instance();
  
  void Swap(SolverParameter* other);
  
  // implements Message ----------------------------------------------
  
  SolverParameter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SolverParameter& from);
  void MergeFrom(const SolverParameter& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string train_net = 1;
  inline bool has_train_net() const;
  inline void clear_train_net();
  static const int kTrainNetFieldNumber = 1;
  inline const ::std::string& train_net() const;
  inline void set_train_net(const ::std::string& value);
  inline void set_train_net(const char* value);
  inline void set_train_net(const char* value, size_t size);
  inline ::std::string* mutable_train_net();
  inline ::std::string* release_train_net();
  
  // optional string test_net = 2;
  inline bool has_test_net() const;
  inline void clear_test_net();
  static const int kTestNetFieldNumber = 2;
  inline const ::std::string& test_net() const;
  inline void set_test_net(const ::std::string& value);
  inline void set_test_net(const char* value);
  inline void set_test_net(const char* value, size_t size);
  inline ::std::string* mutable_test_net();
  inline ::std::string* release_test_net();
  
  // optional int32 test_iter = 3 [default = 0];
  inline bool has_test_iter() const;
  inline void clear_test_iter();
  static const int kTestIterFieldNumber = 3;
  inline ::google::protobuf::int32 test_iter() const;
  inline void set_test_iter(::google::protobuf::int32 value);
  
  // optional int32 test_interval = 4 [default = 0];
  inline bool has_test_interval() const;
  inline void clear_test_interval();
  static const int kTestIntervalFieldNumber = 4;
  inline ::google::protobuf::int32 test_interval() const;
  inline void set_test_interval(::google::protobuf::int32 value);
  
  // optional float base_lr = 5;
  inline bool has_base_lr() const;
  inline void clear_base_lr();
  static const int kBaseLrFieldNumber = 5;
  inline float base_lr() const;
  inline void set_base_lr(float value);
  
  // optional int32 display = 6;
  inline bool has_display() const;
  inline void clear_display();
  static const int kDisplayFieldNumber = 6;
  inline ::google::protobuf::int32 display() const;
  inline void set_display(::google::protobuf::int32 value);
  
  // optional int32 max_iter = 7;
  inline bool has_max_iter() const;
  inline void clear_max_iter();
  static const int kMaxIterFieldNumber = 7;
  inline ::google::protobuf::int32 max_iter() const;
  inline void set_max_iter(::google::protobuf::int32 value);
  
  // optional string lr_policy = 8;
  inline bool has_lr_policy() const;
  inline void clear_lr_policy();
  static const int kLrPolicyFieldNumber = 8;
  inline const ::std::string& lr_policy() const;
  inline void set_lr_policy(const ::std::string& value);
  inline void set_lr_policy(const char* value);
  inline void set_lr_policy(const char* value, size_t size);
  inline ::std::string* mutable_lr_policy();
  inline ::std::string* release_lr_policy();
  
  // optional float gamma = 9;
  inline bool has_gamma() const;
  inline void clear_gamma();
  static const int kGammaFieldNumber = 9;
  inline float gamma() const;
  inline void set_gamma(float value);
  
  // optional float power = 10;
  inline bool has_power() const;
  inline void clear_power();
  static const int kPowerFieldNumber = 10;
  inline float power() const;
  inline void set_power(float value);
  
  // optional float momentum = 11;
  inline bool has_momentum() const;
  inline void clear_momentum();
  static const int kMomentumFieldNumber = 11;
  inline float momentum() const;
  inline void set_momentum(float value);
  
  // optional float weight_decay = 12;
  inline bool has_weight_decay() const;
  inline void clear_weight_decay();
  static const int kWeightDecayFieldNumber = 12;
  inline float weight_decay() const;
  inline void set_weight_decay(float value);
  
  // optional int32 stepsize = 13;
  inline bool has_stepsize() const;
  inline void clear_stepsize();
  static const int kStepsizeFieldNumber = 13;
  inline ::google::protobuf::int32 stepsize() const;
  inline void set_stepsize(::google::protobuf::int32 value);
  
  // optional int32 snapshot = 14 [default = 0];
  inline bool has_snapshot() const;
  inline void clear_snapshot();
  static const int kSnapshotFieldNumber = 14;
  inline ::google::protobuf::int32 snapshot() const;
  inline void set_snapshot(::google::protobuf::int32 value);
  
  // optional string snapshot_prefix = 15;
  inline bool has_snapshot_prefix() const;
  inline void clear_snapshot_prefix();
  static const int kSnapshotPrefixFieldNumber = 15;
  inline const ::std::string& snapshot_prefix() const;
  inline void set_snapshot_prefix(const ::std::string& value);
  inline void set_snapshot_prefix(const char* value);
  inline void set_snapshot_prefix(const char* value, size_t size);
  inline ::std::string* mutable_snapshot_prefix();
  inline ::std::string* release_snapshot_prefix();
  
  // optional bool snapshot_diff = 16 [default = false];
  inline bool has_snapshot_diff() const;
  inline void clear_snapshot_diff();
  static const int kSnapshotDiffFieldNumber = 16;
  inline bool snapshot_diff() const;
  inline void set_snapshot_diff(bool value);
  
  // optional int32 solver_mode = 17 [default = 1];
  inline bool has_solver_mode() const;
  inline void clear_solver_mode();
  static const int kSolverModeFieldNumber = 17;
  inline ::google::protobuf::int32 solver_mode() const;
  inline void set_solver_mode(::google::protobuf::int32 value);
  
  // optional int32 device_id = 18 [default = 0];
  inline bool has_device_id() const;
  inline void clear_device_id();
  static const int kDeviceIdFieldNumber = 18;
  inline ::google::protobuf::int32 device_id() const;
  inline void set_device_id(::google::protobuf::int32 value);
  
  // repeated float vstep_lr = 19;
  inline int vstep_lr_size() const;
  inline void clear_vstep_lr();
  static const int kVstepLrFieldNumber = 19;
  inline float vstep_lr(int index) const;
  inline void set_vstep_lr(int index, float value);
  inline void add_vstep_lr(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      vstep_lr() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_vstep_lr();
  
  // repeated int32 vstep_size = 20;
  inline int vstep_size_size() const;
  inline void clear_vstep_size();
  static const int kVstepSizeFieldNumber = 20;
  inline ::google::protobuf::int32 vstep_size(int index) const;
  inline void set_vstep_size(int index, ::google::protobuf::int32 value);
  inline void add_vstep_size(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      vstep_size() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_vstep_size();
  
  // optional int32 num_threads = 21 [default = 0];
  inline bool has_num_threads() const;
  inline void clear_num_threads();
  static const int kNumThreadsFieldNumber = 21;
  inline ::google::protobuf::int32 num_threads() const;
  inline void set_num_threads(::google::protobuf::int32 value);
  
  // optional int32 train_primary_output_index = 22 [default = 0];
  inline bool has_train_primary_output_index() const;
  inline void clear_train_primary_output_index();
  static const int kTrainPrimaryOutputIndexFieldNumber = 22;
  inline ::google::protobuf::int32 train_primary_output_index() const;
  inline void set_train_primary_output_index(::google::protobuf::int32 value);
  
  // optional int32 test_primary_output_index = 23 [default = 0];
  inline bool has_test_primary_output_index() const;
  inline void clear_test_primary_output_index();
  static const int kTestPrimaryOutputIndexFieldNumber = 23;
  inline ::google::protobuf::int32 test_primary_output_index() const;
  inline void set_test_primary_output_index(::google::protobuf::int32 value);
  
  // optional int32 update_interval = 24 [default = 1];
  inline bool has_update_interval() const;
  inline void clear_update_interval();
  static const int kUpdateIntervalFieldNumber = 24;
  inline ::google::protobuf::int32 update_interval() const;
  inline void set_update_interval(::google::protobuf::int32 value);
  
  // optional string ohem_net = 25;
  inline bool has_ohem_net() const;
  inline void clear_ohem_net();
  static const int kOhemNetFieldNumber = 25;
  inline const ::std::string& ohem_net() const;
  inline void set_ohem_net(const ::std::string& value);
  inline void set_ohem_net(const char* value);
  inline void set_ohem_net(const char* value, size_t size);
  inline ::std::string* mutable_ohem_net();
  inline ::std::string* release_ohem_net();
  
  // optional int32 dump_interval = 26 [default = 0];
  inline bool has_dump_interval() const;
  inline void clear_dump_interval();
  static const int kDumpIntervalFieldNumber = 26;
  inline ::google::protobuf::int32 dump_interval() const;
  inline void set_dump_interval(::google::protobuf::int32 value);
  
  // optional int32 sim_update_interval = 27 [default = 1];
  inline bool has_sim_update_interval() const;
  inline void clear_sim_update_interval();
  static const int kSimUpdateIntervalFieldNumber = 27;
  inline ::google::protobuf::int32 sim_update_interval() const;
  inline void set_sim_update_interval(::google::protobuf::int32 value);
  
  // optional bool data_split = 28 [default = false];
  inline bool has_data_split() const;
  inline void clear_data_split();
  static const int kDataSplitFieldNumber = 28;
  inline bool data_split() const;
  inline void set_data_split(bool value);
  
  // optional string bmuf_method = 29;
  inline bool has_bmuf_method() const;
  inline void clear_bmuf_method();
  static const int kBmufMethodFieldNumber = 29;
  inline const ::std::string& bmuf_method() const;
  inline void set_bmuf_method(const ::std::string& value);
  inline void set_bmuf_method(const char* value);
  inline void set_bmuf_method(const char* value, size_t size);
  inline ::std::string* mutable_bmuf_method();
  inline ::std::string* release_bmuf_method();
  
  // optional float bmuf_lr = 30 [default = 1];
  inline bool has_bmuf_lr() const;
  inline void clear_bmuf_lr();
  static const int kBmufLrFieldNumber = 30;
  inline float bmuf_lr() const;
  inline void set_bmuf_lr(float value);
  
  // optional float bmuf_momentum = 31 [default = 0];
  inline bool has_bmuf_momentum() const;
  inline void clear_bmuf_momentum();
  static const int kBmufMomentumFieldNumber = 31;
  inline float bmuf_momentum() const;
  inline void set_bmuf_momentum(float value);
  
  // optional int32 bmuf_interval = 32 [default = 1];
  inline bool has_bmuf_interval() const;
  inline void clear_bmuf_interval();
  static const int kBmufIntervalFieldNumber = 32;
  inline ::google::protobuf::int32 bmuf_interval() const;
  inline void set_bmuf_interval(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:caffepro.SolverParameter)
 private:
  inline void set_has_train_net();
  inline void clear_has_train_net();
  inline void set_has_test_net();
  inline void clear_has_test_net();
  inline void set_has_test_iter();
  inline void clear_has_test_iter();
  inline void set_has_test_interval();
  inline void clear_has_test_interval();
  inline void set_has_base_lr();
  inline void clear_has_base_lr();
  inline void set_has_display();
  inline void clear_has_display();
  inline void set_has_max_iter();
  inline void clear_has_max_iter();
  inline void set_has_lr_policy();
  inline void clear_has_lr_policy();
  inline void set_has_gamma();
  inline void clear_has_gamma();
  inline void set_has_power();
  inline void clear_has_power();
  inline void set_has_momentum();
  inline void clear_has_momentum();
  inline void set_has_weight_decay();
  inline void clear_has_weight_decay();
  inline void set_has_stepsize();
  inline void clear_has_stepsize();
  inline void set_has_snapshot();
  inline void clear_has_snapshot();
  inline void set_has_snapshot_prefix();
  inline void clear_has_snapshot_prefix();
  inline void set_has_snapshot_diff();
  inline void clear_has_snapshot_diff();
  inline void set_has_solver_mode();
  inline void clear_has_solver_mode();
  inline void set_has_device_id();
  inline void clear_has_device_id();
  inline void set_has_num_threads();
  inline void clear_has_num_threads();
  inline void set_has_train_primary_output_index();
  inline void clear_has_train_primary_output_index();
  inline void set_has_test_primary_output_index();
  inline void clear_has_test_primary_output_index();
  inline void set_has_update_interval();
  inline void clear_has_update_interval();
  inline void set_has_ohem_net();
  inline void clear_has_ohem_net();
  inline void set_has_dump_interval();
  inline void clear_has_dump_interval();
  inline void set_has_sim_update_interval();
  inline void clear_has_sim_update_interval();
  inline void set_has_data_split();
  inline void clear_has_data_split();
  inline void set_has_bmuf_method();
  inline void clear_has_bmuf_method();
  inline void set_has_bmuf_lr();
  inline void clear_has_bmuf_lr();
  inline void set_has_bmuf_momentum();
  inline void clear_has_bmuf_momentum();
  inline void set_has_bmuf_interval();
  inline void clear_has_bmuf_interval();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* train_net_;
  ::std::string* test_net_;
  ::google::protobuf::int32 test_iter_;
  ::google::protobuf::int32 test_interval_;
  float base_lr_;
  ::google::protobuf::int32 display_;
  ::std::string* lr_policy_;
  ::google::protobuf::int32 max_iter_;
  float gamma_;
  float power_;
  float momentum_;
  float weight_decay_;
  ::google::protobuf::int32 stepsize_;
  ::std::string* snapshot_prefix_;
  ::google::protobuf::int32 snapshot_;
  ::google::protobuf::int32 solver_mode_;
  ::google::protobuf::RepeatedField< float > vstep_lr_;
  ::google::protobuf::int32 device_id_;
  ::google::protobuf::int32 num_threads_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > vstep_size_;
  ::google::protobuf::int32 train_primary_output_index_;
  bool snapshot_diff_;
  bool data_split_;
  ::google::protobuf::int32 test_primary_output_index_;
  ::google::protobuf::int32 update_interval_;
  ::std::string* ohem_net_;
  ::google::protobuf::int32 dump_interval_;
  ::google::protobuf::int32 sim_update_interval_;
  ::std::string* bmuf_method_;
  float bmuf_lr_;
  float bmuf_momentum_;
  ::google::protobuf::int32 bmuf_interval_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(32 + 31) / 32];
  
  friend void  protobuf_AddDesc_caffe_2eproto();
  friend void protobuf_AssignDesc_caffe_2eproto();
  friend void protobuf_ShutdownFile_caffe_2eproto();
  
  void InitAsDefaultInstance();
  static SolverParameter* default_instance_;
};
// -------------------------------------------------------------------

class SolverState : public ::google::protobuf::Message {
 public:
  SolverState();
  virtual ~SolverState();
  
  SolverState(const SolverState& from);
  
  inline SolverState& operator=(const SolverState& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SolverState& default_instance();
  
  void Swap(SolverState* other);
  
  // implements Message ----------------------------------------------
  
  SolverState* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SolverState& from);
  void MergeFrom(const SolverState& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 iter = 1;
  inline bool has_iter() const;
  inline void clear_iter();
  static const int kIterFieldNumber = 1;
  inline ::google::protobuf::int32 iter() const;
  inline void set_iter(::google::protobuf::int32 value);
  
  // optional string learned_net = 2;
  inline bool has_learned_net() const;
  inline void clear_learned_net();
  static const int kLearnedNetFieldNumber = 2;
  inline const ::std::string& learned_net() const;
  inline void set_learned_net(const ::std::string& value);
  inline void set_learned_net(const char* value);
  inline void set_learned_net(const char* value, size_t size);
  inline ::std::string* mutable_learned_net();
  inline ::std::string* release_learned_net();
  
  // repeated .caffepro.BlobProto history = 3;
  inline int history_size() const;
  inline void clear_history();
  static const int kHistoryFieldNumber = 3;
  inline const ::caffepro::BlobProto& history(int index) const;
  inline ::caffepro::BlobProto* mutable_history(int index);
  inline ::caffepro::BlobProto* add_history();
  inline const ::google::protobuf::RepeatedPtrField< ::caffepro::BlobProto >&
      history() const;
  inline ::google::protobuf::RepeatedPtrField< ::caffepro::BlobProto >*
      mutable_history();
  
  // @@protoc_insertion_point(class_scope:caffepro.SolverState)
 private:
  inline void set_has_iter();
  inline void clear_has_iter();
  inline void set_has_learned_net();
  inline void clear_has_learned_net();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* learned_net_;
  ::google::protobuf::RepeatedPtrField< ::caffepro::BlobProto > history_;
  ::google::protobuf::int32 iter_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_caffe_2eproto();
  friend void protobuf_AssignDesc_caffe_2eproto();
  friend void protobuf_ShutdownFile_caffe_2eproto();
  
  void InitAsDefaultInstance();
  static SolverState* default_instance_;
};
// -------------------------------------------------------------------

class ScaleBiasParameter : public ::google::protobuf::Message {
 public:
  ScaleBiasParameter();
  virtual ~ScaleBiasParameter();
  
  ScaleBiasParameter(const ScaleBiasParameter& from);
  
  inline ScaleBiasParameter& operator=(const ScaleBiasParameter& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ScaleBiasParameter& default_instance();
  
  void Swap(ScaleBiasParameter* other);
  
  // implements Message ----------------------------------------------
  
  ScaleBiasParameter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ScaleBiasParameter& from);
  void MergeFrom(const ScaleBiasParameter& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .caffepro.FillerParameter weight_filler = 1;
  inline bool has_weight_filler() const;
  inline void clear_weight_filler();
  static const int kWeightFillerFieldNumber = 1;
  inline const ::caffepro::FillerParameter& weight_filler() const;
  inline ::caffepro::FillerParameter* mutable_weight_filler();
  inline ::caffepro::FillerParameter* release_weight_filler();
  
  // optional .caffepro.FillerParameter bias_filler = 2;
  inline bool has_bias_filler() const;
  inline void clear_bias_filler();
  static const int kBiasFillerFieldNumber = 2;
  inline const ::caffepro::FillerParameter& bias_filler() const;
  inline ::caffepro::FillerParameter* mutable_bias_filler();
  inline ::caffepro::FillerParameter* release_bias_filler();
  
  // @@protoc_insertion_point(class_scope:caffepro.ScaleBiasParameter)
 private:
  inline void set_has_weight_filler();
  inline void clear_has_weight_filler();
  inline void set_has_bias_filler();
  inline void clear_has_bias_filler();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::caffepro::FillerParameter* weight_filler_;
  ::caffepro::FillerParameter* bias_filler_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_caffe_2eproto();
  friend void protobuf_AssignDesc_caffe_2eproto();
  friend void protobuf_ShutdownFile_caffe_2eproto();
  
  void InitAsDefaultInstance();
  static ScaleBiasParameter* default_instance_;
};
// -------------------------------------------------------------------

class CropParameter : public ::google::protobuf::Message {
 public:
  CropParameter();
  virtual ~CropParameter();
  
  CropParameter(const CropParameter& from);
  
  inline CropParameter& operator=(const CropParameter& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const CropParameter& default_instance();
  
  void Swap(CropParameter* other);
  
  // implements Message ----------------------------------------------
  
  CropParameter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CropParameter& from);
  void MergeFrom(const CropParameter& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef CropParameter_CropType CropType;
  static const CropType ViewDense = CropParameter_CropType_ViewDense;
  static const CropType View10 = CropParameter_CropType_View10;
  static inline bool CropType_IsValid(int value) {
    return CropParameter_CropType_IsValid(value);
  }
  static const CropType CropType_MIN =
    CropParameter_CropType_CropType_MIN;
  static const CropType CropType_MAX =
    CropParameter_CropType_CropType_MAX;
  static const int CropType_ARRAYSIZE =
    CropParameter_CropType_CropType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  CropType_descriptor() {
    return CropParameter_CropType_descriptor();
  }
  static inline const ::std::string& CropType_Name(CropType value) {
    return CropParameter_CropType_Name(value);
  }
  static inline bool CropType_Parse(const ::std::string& name,
      CropType* value) {
    return CropParameter_CropType_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // required .caffepro.CropParameter.CropType crop_type = 1;
  inline bool has_crop_type() const;
  inline void clear_crop_type();
  static const int kCropTypeFieldNumber = 1;
  inline ::caffepro::CropParameter_CropType crop_type() const;
  inline void set_crop_type(::caffepro::CropParameter_CropType value);
  
  // optional uint32 stride = 2 [default = 1];
  inline bool has_stride() const;
  inline void clear_stride();
  static const int kStrideFieldNumber = 2;
  inline ::google::protobuf::uint32 stride() const;
  inline void set_stride(::google::protobuf::uint32 value);
  
  // required uint32 crop_width = 3;
  inline bool has_crop_width() const;
  inline void clear_crop_width();
  static const int kCropWidthFieldNumber = 3;
  inline ::google::protobuf::uint32 crop_width() const;
  inline void set_crop_width(::google::protobuf::uint32 value);
  
  // required uint32 crop_height = 4;
  inline bool has_crop_height() const;
  inline void clear_crop_height();
  static const int kCropHeightFieldNumber = 4;
  inline ::google::protobuf::uint32 crop_height() const;
  inline void set_crop_height(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:caffepro.CropParameter)
 private:
  inline void set_has_crop_type();
  inline void clear_has_crop_type();
  inline void set_has_stride();
  inline void clear_has_stride();
  inline void set_has_crop_width();
  inline void clear_has_crop_width();
  inline void set_has_crop_height();
  inline void clear_has_crop_height();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  int crop_type_;
  ::google::protobuf::uint32 stride_;
  ::google::protobuf::uint32 crop_width_;
  ::google::protobuf::uint32 crop_height_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_caffe_2eproto();
  friend void protobuf_AssignDesc_caffe_2eproto();
  friend void protobuf_ShutdownFile_caffe_2eproto();
  
  void InitAsDefaultInstance();
  static CropParameter* default_instance_;
};
// -------------------------------------------------------------------

class ReduceDimParameter : public ::google::protobuf::Message {
 public:
  ReduceDimParameter();
  virtual ~ReduceDimParameter();
  
  ReduceDimParameter(const ReduceDimParameter& from);
  
  inline ReduceDimParameter& operator=(const ReduceDimParameter& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReduceDimParameter& default_instance();
  
  void Swap(ReduceDimParameter* other);
  
  // implements Message ----------------------------------------------
  
  ReduceDimParameter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReduceDimParameter& from);
  void MergeFrom(const ReduceDimParameter& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef ReduceDimParameter_ReduceType ReduceType;
  static const ReduceType AVE = ReduceDimParameter_ReduceType_AVE;
  static const ReduceType SUM = ReduceDimParameter_ReduceType_SUM;
  static inline bool ReduceType_IsValid(int value) {
    return ReduceDimParameter_ReduceType_IsValid(value);
  }
  static const ReduceType ReduceType_MIN =
    ReduceDimParameter_ReduceType_ReduceType_MIN;
  static const ReduceType ReduceType_MAX =
    ReduceDimParameter_ReduceType_ReduceType_MAX;
  static const int ReduceType_ARRAYSIZE =
    ReduceDimParameter_ReduceType_ReduceType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ReduceType_descriptor() {
    return ReduceDimParameter_ReduceType_descriptor();
  }
  static inline const ::std::string& ReduceType_Name(ReduceType value) {
    return ReduceDimParameter_ReduceType_Name(value);
  }
  static inline bool ReduceType_Parse(const ::std::string& name,
      ReduceType* value) {
    return ReduceDimParameter_ReduceType_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // required uint32 dim = 1;
  inline bool has_dim() const;
  inline void clear_dim();
  static const int kDimFieldNumber = 1;
  inline ::google::protobuf::uint32 dim() const;
  inline void set_dim(::google::protobuf::uint32 value);
  
  // optional uint32 group = 2 [default = 1];
  inline bool has_group() const;
  inline void clear_group();
  static const int kGroupFieldNumber = 2;
  inline ::google::protobuf::uint32 group() const;
  inline void set_group(::google::protobuf::uint32 value);
  
  // required .caffepro.ReduceDimParameter.ReduceType reduce_type = 3 [default = AVE];
  inline bool has_reduce_type() const;
  inline void clear_reduce_type();
  static const int kReduceTypeFieldNumber = 3;
  inline ::caffepro::ReduceDimParameter_ReduceType reduce_type() const;
  inline void set_reduce_type(::caffepro::ReduceDimParameter_ReduceType value);
  
  // @@protoc_insertion_point(class_scope:caffepro.ReduceDimParameter)
 private:
  inline void set_has_dim();
  inline void clear_has_dim();
  inline void set_has_group();
  inline void clear_has_group();
  inline void set_has_reduce_type();
  inline void clear_has_reduce_type();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint32 dim_;
  ::google::protobuf::uint32 group_;
  int reduce_type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_caffe_2eproto();
  friend void protobuf_AssignDesc_caffe_2eproto();
  friend void protobuf_ShutdownFile_caffe_2eproto();
  
  void InitAsDefaultInstance();
  static ReduceDimParameter* default_instance_;
};
// -------------------------------------------------------------------

class FlipParameter : public ::google::protobuf::Message {
 public:
  FlipParameter();
  virtual ~FlipParameter();
  
  FlipParameter(const FlipParameter& from);
  
  inline FlipParameter& operator=(const FlipParameter& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const FlipParameter& default_instance();
  
  void Swap(FlipParameter* other);
  
  // implements Message ----------------------------------------------
  
  FlipParameter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FlipParameter& from);
  void MergeFrom(const FlipParameter& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional bool keep_original = 1 [default = true];
  inline bool has_keep_original() const;
  inline void clear_keep_original();
  static const int kKeepOriginalFieldNumber = 1;
  inline bool keep_original() const;
  inline void set_keep_original(bool value);
  
  // @@protoc_insertion_point(class_scope:caffepro.FlipParameter)
 private:
  inline void set_has_keep_original();
  inline void clear_has_keep_original();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  bool keep_original_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_caffe_2eproto();
  friend void protobuf_AssignDesc_caffe_2eproto();
  friend void protobuf_ShutdownFile_caffe_2eproto();
  
  void InitAsDefaultInstance();
  static FlipParameter* default_instance_;
};
// -------------------------------------------------------------------

class StepGateParameter : public ::google::protobuf::Message {
 public:
  StepGateParameter();
  virtual ~StepGateParameter();
  
  StepGateParameter(const StepGateParameter& from);
  
  inline StepGateParameter& operator=(const StepGateParameter& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const StepGateParameter& default_instance();
  
  void Swap(StepGateParameter* other);
  
  // implements Message ----------------------------------------------
  
  StepGateParameter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StepGateParameter& from);
  void MergeFrom(const StepGateParameter& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required float init_value = 1;
  inline bool has_init_value() const;
  inline void clear_init_value();
  static const int kInitValueFieldNumber = 1;
  inline float init_value() const;
  inline void set_init_value(float value);
  
  // required float step_value = 2;
  inline bool has_step_value() const;
  inline void clear_step_value();
  static const int kStepValueFieldNumber = 2;
  inline float step_value() const;
  inline void set_step_value(float value);
  
  // required float max_value = 3;
  inline bool has_max_value() const;
  inline void clear_max_value();
  static const int kMaxValueFieldNumber = 3;
  inline float max_value() const;
  inline void set_max_value(float value);
  
  // optional bool keep_backward = 4 [default = false];
  inline bool has_keep_backward() const;
  inline void clear_keep_backward();
  static const int kKeepBackwardFieldNumber = 4;
  inline bool keep_backward() const;
  inline void set_keep_backward(bool value);
  
  // optional bool keep_forward = 5 [default = false];
  inline bool has_keep_forward() const;
  inline void clear_keep_forward();
  static const int kKeepForwardFieldNumber = 5;
  inline bool keep_forward() const;
  inline void set_keep_forward(bool value);
  
  // optional uint32 start_iter = 6;
  inline bool has_start_iter() const;
  inline void clear_start_iter();
  static const int kStartIterFieldNumber = 6;
  inline ::google::protobuf::uint32 start_iter() const;
  inline void set_start_iter(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:caffepro.StepGateParameter)
 private:
  inline void set_has_init_value();
  inline void clear_has_init_value();
  inline void set_has_step_value();
  inline void clear_has_step_value();
  inline void set_has_max_value();
  inline void clear_has_max_value();
  inline void set_has_keep_backward();
  inline void clear_has_keep_backward();
  inline void set_has_keep_forward();
  inline void clear_has_keep_forward();
  inline void set_has_start_iter();
  inline void clear_has_start_iter();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  float init_value_;
  float step_value_;
  float max_value_;
  bool keep_backward_;
  bool keep_forward_;
  ::google::protobuf::uint32 start_iter_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_caffe_2eproto();
  friend void protobuf_AssignDesc_caffe_2eproto();
  friend void protobuf_ShutdownFile_caffe_2eproto();
  
  void InitAsDefaultInstance();
  static StepGateParameter* default_instance_;
};
// -------------------------------------------------------------------

class HouseholderParameter : public ::google::protobuf::Message {
 public:
  HouseholderParameter();
  virtual ~HouseholderParameter();
  
  HouseholderParameter(const HouseholderParameter& from);
  
  inline HouseholderParameter& operator=(const HouseholderParameter& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const HouseholderParameter& default_instance();
  
  void Swap(HouseholderParameter* other);
  
  // implements Message ----------------------------------------------
  
  HouseholderParameter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HouseholderParameter& from);
  void MergeFrom(const HouseholderParameter& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional uint32 source = 1 [default = 0];
  inline bool has_source() const;
  inline void clear_source();
  static const int kSourceFieldNumber = 1;
  inline ::google::protobuf::uint32 source() const;
  inline void set_source(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:caffepro.HouseholderParameter)
 private:
  inline void set_has_source();
  inline void clear_has_source();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint32 source_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_caffe_2eproto();
  friend void protobuf_AssignDesc_caffe_2eproto();
  friend void protobuf_ShutdownFile_caffe_2eproto();
  
  void InitAsDefaultInstance();
  static HouseholderParameter* default_instance_;
};
// -------------------------------------------------------------------

class InstanceSampleParameter : public ::google::protobuf::Message {
 public:
  InstanceSampleParameter();
  virtual ~InstanceSampleParameter();
  
  InstanceSampleParameter(const InstanceSampleParameter& from);
  
  inline InstanceSampleParameter& operator=(const InstanceSampleParameter& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const InstanceSampleParameter& default_instance();
  
  void Swap(InstanceSampleParameter* other);
  
  // implements Message ----------------------------------------------
  
  InstanceSampleParameter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InstanceSampleParameter& from);
  void MergeFrom(const InstanceSampleParameter& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef InstanceSampleParameter_SampleMethod SampleMethod;
  static const SampleMethod SEQ = InstanceSampleParameter_SampleMethod_SEQ;
  static const SampleMethod RAND = InstanceSampleParameter_SampleMethod_RAND;
  static inline bool SampleMethod_IsValid(int value) {
    return InstanceSampleParameter_SampleMethod_IsValid(value);
  }
  static const SampleMethod SampleMethod_MIN =
    InstanceSampleParameter_SampleMethod_SampleMethod_MIN;
  static const SampleMethod SampleMethod_MAX =
    InstanceSampleParameter_SampleMethod_SampleMethod_MAX;
  static const int SampleMethod_ARRAYSIZE =
    InstanceSampleParameter_SampleMethod_SampleMethod_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  SampleMethod_descriptor() {
    return InstanceSampleParameter_SampleMethod_descriptor();
  }
  static inline const ::std::string& SampleMethod_Name(SampleMethod value) {
    return InstanceSampleParameter_SampleMethod_Name(value);
  }
  static inline bool SampleMethod_Parse(const ::std::string& name,
      SampleMethod* value) {
    return InstanceSampleParameter_SampleMethod_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // optional .caffepro.InstanceSampleParameter.SampleMethod sample_method = 1 [default = SEQ];
  inline bool has_sample_method() const;
  inline void clear_sample_method();
  static const int kSampleMethodFieldNumber = 1;
  inline ::caffepro::InstanceSampleParameter_SampleMethod sample_method() const;
  inline void set_sample_method(::caffepro::InstanceSampleParameter_SampleMethod value);
  
  // required uint32 num = 2;
  inline bool has_num() const;
  inline void clear_num();
  static const int kNumFieldNumber = 2;
  inline ::google::protobuf::uint32 num() const;
  inline void set_num(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:caffepro.InstanceSampleParameter)
 private:
  inline void set_has_sample_method();
  inline void clear_has_sample_method();
  inline void set_has_num();
  inline void clear_has_num();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  int sample_method_;
  ::google::protobuf::uint32 num_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_caffe_2eproto();
  friend void protobuf_AssignDesc_caffe_2eproto();
  friend void protobuf_ShutdownFile_caffe_2eproto();
  
  void InitAsDefaultInstance();
  static InstanceSampleParameter* default_instance_;
};
// -------------------------------------------------------------------

class MatrixMulParameter : public ::google::protobuf::Message {
 public:
  MatrixMulParameter();
  virtual ~MatrixMulParameter();
  
  MatrixMulParameter(const MatrixMulParameter& from);
  
  inline MatrixMulParameter& operator=(const MatrixMulParameter& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MatrixMulParameter& default_instance();
  
  void Swap(MatrixMulParameter* other);
  
  // implements Message ----------------------------------------------
  
  MatrixMulParameter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MatrixMulParameter& from);
  void MergeFrom(const MatrixMulParameter& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional bool trans_A = 1 [default = false];
  inline bool has_trans_a() const;
  inline void clear_trans_a();
  static const int kTransAFieldNumber = 1;
  inline bool trans_a() const;
  inline void set_trans_a(bool value);
  
  // optional bool trans_B = 2 [default = true];
  inline bool has_trans_b() const;
  inline void clear_trans_b();
  static const int kTransBFieldNumber = 2;
  inline bool trans_b() const;
  inline void set_trans_b(bool value);
  
  // @@protoc_insertion_point(class_scope:caffepro.MatrixMulParameter)
 private:
  inline void set_has_trans_a();
  inline void clear_has_trans_a();
  inline void set_has_trans_b();
  inline void clear_has_trans_b();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  bool trans_a_;
  bool trans_b_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_caffe_2eproto();
  friend void protobuf_AssignDesc_caffe_2eproto();
  friend void protobuf_ShutdownFile_caffe_2eproto();
  
  void InitAsDefaultInstance();
  static MatrixMulParameter* default_instance_;
};
// -------------------------------------------------------------------

class MatrixMulStackParameter : public ::google::protobuf::Message {
 public:
  MatrixMulStackParameter();
  virtual ~MatrixMulStackParameter();
  
  MatrixMulStackParameter(const MatrixMulStackParameter& from);
  
  inline MatrixMulStackParameter& operator=(const MatrixMulStackParameter& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MatrixMulStackParameter& default_instance();
  
  void Swap(MatrixMulStackParameter* other);
  
  // implements Message ----------------------------------------------
  
  MatrixMulStackParameter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MatrixMulStackParameter& from);
  void MergeFrom(const MatrixMulStackParameter& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 num = 1;
  inline bool has_num() const;
  inline void clear_num();
  static const int kNumFieldNumber = 1;
  inline ::google::protobuf::uint32 num() const;
  inline void set_num(::google::protobuf::uint32 value);
  
  // optional bool trans_odd = 2 [default = false];
  inline bool has_trans_odd() const;
  inline void clear_trans_odd();
  static const int kTransOddFieldNumber = 2;
  inline bool trans_odd() const;
  inline void set_trans_odd(bool value);
  
  // optional bool trans_even = 3 [default = true];
  inline bool has_trans_even() const;
  inline void clear_trans_even();
  static const int kTransEvenFieldNumber = 3;
  inline bool trans_even() const;
  inline void set_trans_even(bool value);
  
  // @@protoc_insertion_point(class_scope:caffepro.MatrixMulStackParameter)
 private:
  inline void set_has_num();
  inline void clear_has_num();
  inline void set_has_trans_odd();
  inline void clear_has_trans_odd();
  inline void set_has_trans_even();
  inline void clear_has_trans_even();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint32 num_;
  bool trans_odd_;
  bool trans_even_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_caffe_2eproto();
  friend void protobuf_AssignDesc_caffe_2eproto();
  friend void protobuf_ShutdownFile_caffe_2eproto();
  
  void InitAsDefaultInstance();
  static MatrixMulStackParameter* default_instance_;
};
// -------------------------------------------------------------------

class TransposeParameter : public ::google::protobuf::Message {
 public:
  TransposeParameter();
  virtual ~TransposeParameter();
  
  TransposeParameter(const TransposeParameter& from);
  
  inline TransposeParameter& operator=(const TransposeParameter& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const TransposeParameter& default_instance();
  
  void Swap(TransposeParameter* other);
  
  // implements Message ----------------------------------------------
  
  TransposeParameter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TransposeParameter& from);
  void MergeFrom(const TransposeParameter& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 lead_dim = 1;
  inline bool has_lead_dim() const;
  inline void clear_lead_dim();
  static const int kLeadDimFieldNumber = 1;
  inline ::google::protobuf::uint32 lead_dim() const;
  inline void set_lead_dim(::google::protobuf::uint32 value);
  
  // repeated int32 output_dims = 2;
  inline int output_dims_size() const;
  inline void clear_output_dims();
  static const int kOutputDimsFieldNumber = 2;
  inline ::google::protobuf::int32 output_dims(int index) const;
  inline void set_output_dims(int index, ::google::protobuf::int32 value);
  inline void add_output_dims(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      output_dims() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_output_dims();
  
  // @@protoc_insertion_point(class_scope:caffepro.TransposeParameter)
 private:
  inline void set_has_lead_dim();
  inline void clear_has_lead_dim();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > output_dims_;
  ::google::protobuf::uint32 lead_dim_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_caffe_2eproto();
  friend void protobuf_AssignDesc_caffe_2eproto();
  friend void protobuf_ShutdownFile_caffe_2eproto();
  
  void InitAsDefaultInstance();
  static TransposeParameter* default_instance_;
};
// -------------------------------------------------------------------

class ReshapeParameter : public ::google::protobuf::Message {
 public:
  ReshapeParameter();
  virtual ~ReshapeParameter();
  
  ReshapeParameter(const ReshapeParameter& from);
  
  inline ReshapeParameter& operator=(const ReshapeParameter& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReshapeParameter& default_instance();
  
  void Swap(ReshapeParameter* other);
  
  // implements Message ----------------------------------------------
  
  ReshapeParameter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReshapeParameter& from);
  void MergeFrom(const ReshapeParameter& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated int32 dims = 1;
  inline int dims_size() const;
  inline void clear_dims();
  static const int kDimsFieldNumber = 1;
  inline ::google::protobuf::int32 dims(int index) const;
  inline void set_dims(int index, ::google::protobuf::int32 value);
  inline void add_dims(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      dims() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_dims();
  
  // @@protoc_insertion_point(class_scope:caffepro.ReshapeParameter)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > dims_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_caffe_2eproto();
  friend void protobuf_AssignDesc_caffe_2eproto();
  friend void protobuf_ShutdownFile_caffe_2eproto();
  
  void InitAsDefaultInstance();
  static ReshapeParameter* default_instance_;
};
// -------------------------------------------------------------------

class LearnableDropoutParameter : public ::google::protobuf::Message {
 public:
  LearnableDropoutParameter();
  virtual ~LearnableDropoutParameter();
  
  LearnableDropoutParameter(const LearnableDropoutParameter& from);
  
  inline LearnableDropoutParameter& operator=(const LearnableDropoutParameter& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const LearnableDropoutParameter& default_instance();
  
  void Swap(LearnableDropoutParameter* other);
  
  // implements Message ----------------------------------------------
  
  LearnableDropoutParameter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LearnableDropoutParameter& from);
  void MergeFrom(const LearnableDropoutParameter& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional float init_value = 1 [default = 0];
  inline bool has_init_value() const;
  inline void clear_init_value();
  static const int kInitValueFieldNumber = 1;
  inline float init_value() const;
  inline void set_init_value(float value);
  
  // @@protoc_insertion_point(class_scope:caffepro.LearnableDropoutParameter)
 private:
  inline void set_has_init_value();
  inline void clear_has_init_value();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  float init_value_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_caffe_2eproto();
  friend void protobuf_AssignDesc_caffe_2eproto();
  friend void protobuf_ShutdownFile_caffe_2eproto();
  
  void InitAsDefaultInstance();
  static LearnableDropoutParameter* default_instance_;
};
// -------------------------------------------------------------------

class DimInnerProductParameter : public ::google::protobuf::Message {
 public:
  DimInnerProductParameter();
  virtual ~DimInnerProductParameter();
  
  DimInnerProductParameter(const DimInnerProductParameter& from);
  
  inline DimInnerProductParameter& operator=(const DimInnerProductParameter& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const DimInnerProductParameter& default_instance();
  
  void Swap(DimInnerProductParameter* other);
  
  // implements Message ----------------------------------------------
  
  DimInnerProductParameter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DimInnerProductParameter& from);
  void MergeFrom(const DimInnerProductParameter& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 dim = 1;
  inline bool has_dim() const;
  inline void clear_dim();
  static const int kDimFieldNumber = 1;
  inline ::google::protobuf::uint32 dim() const;
  inline void set_dim(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:caffepro.DimInnerProductParameter)
 private:
  inline void set_has_dim();
  inline void clear_has_dim();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint32 dim_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_caffe_2eproto();
  friend void protobuf_AssignDesc_caffe_2eproto();
  friend void protobuf_ShutdownFile_caffe_2eproto();
  
  void InitAsDefaultInstance();
  static DimInnerProductParameter* default_instance_;
};
// -------------------------------------------------------------------

class SoftthrParameter : public ::google::protobuf::Message {
 public:
  SoftthrParameter();
  virtual ~SoftthrParameter();
  
  SoftthrParameter(const SoftthrParameter& from);
  
  inline SoftthrParameter& operator=(const SoftthrParameter& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SoftthrParameter& default_instance();
  
  void Swap(SoftthrParameter* other);
  
  // implements Message ----------------------------------------------
  
  SoftthrParameter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SoftthrParameter& from);
  void MergeFrom(const SoftthrParameter& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional float softthr_thr = 1 [default = 0.1];
  inline bool has_softthr_thr() const;
  inline void clear_softthr_thr();
  static const int kSoftthrThrFieldNumber = 1;
  inline float softthr_thr() const;
  inline void set_softthr_thr(float value);
  
  // @@protoc_insertion_point(class_scope:caffepro.SoftthrParameter)
 private:
  inline void set_has_softthr_thr();
  inline void clear_has_softthr_thr();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  float softthr_thr_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_caffe_2eproto();
  friend void protobuf_AssignDesc_caffe_2eproto();
  friend void protobuf_ShutdownFile_caffe_2eproto();
  
  void InitAsDefaultInstance();
  static SoftthrParameter* default_instance_;
};
// -------------------------------------------------------------------

class DropoutsameParameter : public ::google::protobuf::Message {
 public:
  DropoutsameParameter();
  virtual ~DropoutsameParameter();
  
  DropoutsameParameter(const DropoutsameParameter& from);
  
  inline DropoutsameParameter& operator=(const DropoutsameParameter& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const DropoutsameParameter& default_instance();
  
  void Swap(DropoutsameParameter* other);
  
  // implements Message ----------------------------------------------
  
  DropoutsameParameter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DropoutsameParameter& from);
  void MergeFrom(const DropoutsameParameter& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional float dropout_ratio = 1 [default = 0.5];
  inline bool has_dropout_ratio() const;
  inline void clear_dropout_ratio();
  static const int kDropoutRatioFieldNumber = 1;
  inline float dropout_ratio() const;
  inline void set_dropout_ratio(float value);
  
  // optional bool force_random = 2 [default = false];
  inline bool has_force_random() const;
  inline void clear_force_random();
  static const int kForceRandomFieldNumber = 2;
  inline bool force_random() const;
  inline void set_force_random(bool value);
  
  // @@protoc_insertion_point(class_scope:caffepro.DropoutsameParameter)
 private:
  inline void set_has_dropout_ratio();
  inline void clear_has_dropout_ratio();
  inline void set_has_force_random();
  inline void clear_has_force_random();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  float dropout_ratio_;
  bool force_random_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_caffe_2eproto();
  friend void protobuf_AssignDesc_caffe_2eproto();
  friend void protobuf_ShutdownFile_caffe_2eproto();
  
  void InitAsDefaultInstance();
  static DropoutsameParameter* default_instance_;
};
// -------------------------------------------------------------------

class DiagOperationParameter : public ::google::protobuf::Message {
 public:
  DiagOperationParameter();
  virtual ~DiagOperationParameter();
  
  DiagOperationParameter(const DiagOperationParameter& from);
  
  inline DiagOperationParameter& operator=(const DiagOperationParameter& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const DiagOperationParameter& default_instance();
  
  void Swap(DiagOperationParameter* other);
  
  // implements Message ----------------------------------------------
  
  DiagOperationParameter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DiagOperationParameter& from);
  void MergeFrom(const DiagOperationParameter& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional float scale = 1 [default = 1];
  inline bool has_scale() const;
  inline void clear_scale();
  static const int kScaleFieldNumber = 1;
  inline float scale() const;
  inline void set_scale(float value);
  
  // optional float shift = 2 [default = 0];
  inline bool has_shift() const;
  inline void clear_shift();
  static const int kShiftFieldNumber = 2;
  inline float shift() const;
  inline void set_shift(float value);
  
  // @@protoc_insertion_point(class_scope:caffepro.DiagOperationParameter)
 private:
  inline void set_has_scale();
  inline void clear_has_scale();
  inline void set_has_shift();
  inline void clear_has_shift();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  float scale_;
  float shift_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_caffe_2eproto();
  friend void protobuf_AssignDesc_caffe_2eproto();
  friend void protobuf_ShutdownFile_caffe_2eproto();
  
  void InitAsDefaultInstance();
  static DiagOperationParameter* default_instance_;
};
// -------------------------------------------------------------------

class SoftMaxLossOHEMParameter : public ::google::protobuf::Message {
 public:
  SoftMaxLossOHEMParameter();
  virtual ~SoftMaxLossOHEMParameter();
  
  SoftMaxLossOHEMParameter(const SoftMaxLossOHEMParameter& from);
  
  inline SoftMaxLossOHEMParameter& operator=(const SoftMaxLossOHEMParameter& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SoftMaxLossOHEMParameter& default_instance();
  
  void Swap(SoftMaxLossOHEMParameter* other);
  
  // implements Message ----------------------------------------------
  
  SoftMaxLossOHEMParameter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SoftMaxLossOHEMParameter& from);
  void MergeFrom(const SoftMaxLossOHEMParameter& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 ohem_size = 1 [default = 64];
  inline bool has_ohem_size() const;
  inline void clear_ohem_size();
  static const int kOhemSizeFieldNumber = 1;
  inline ::google::protobuf::int32 ohem_size() const;
  inline void set_ohem_size(::google::protobuf::int32 value);
  
  // optional bool force_random = 2 [default = false];
  inline bool has_force_random() const;
  inline void clear_force_random();
  static const int kForceRandomFieldNumber = 2;
  inline bool force_random() const;
  inline void set_force_random(bool value);
  
  // @@protoc_insertion_point(class_scope:caffepro.SoftMaxLossOHEMParameter)
 private:
  inline void set_has_ohem_size();
  inline void clear_has_ohem_size();
  inline void set_has_force_random();
  inline void clear_has_force_random();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 ohem_size_;
  bool force_random_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_caffe_2eproto();
  friend void protobuf_AssignDesc_caffe_2eproto();
  friend void protobuf_ShutdownFile_caffe_2eproto();
  
  void InitAsDefaultInstance();
  static SoftMaxLossOHEMParameter* default_instance_;
};
// -------------------------------------------------------------------

class SoftMaxOHEMParameter : public ::google::protobuf::Message {
 public:
  SoftMaxOHEMParameter();
  virtual ~SoftMaxOHEMParameter();
  
  SoftMaxOHEMParameter(const SoftMaxOHEMParameter& from);
  
  inline SoftMaxOHEMParameter& operator=(const SoftMaxOHEMParameter& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SoftMaxOHEMParameter& default_instance();
  
  void Swap(SoftMaxOHEMParameter* other);
  
  // implements Message ----------------------------------------------
  
  SoftMaxOHEMParameter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SoftMaxOHEMParameter& from);
  void MergeFrom(const SoftMaxOHEMParameter& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 ohem_size = 1 [default = 64];
  inline bool has_ohem_size() const;
  inline void clear_ohem_size();
  static const int kOhemSizeFieldNumber = 1;
  inline ::google::protobuf::int32 ohem_size() const;
  inline void set_ohem_size(::google::protobuf::int32 value);
  
  // optional bool force_random = 2 [default = false];
  inline bool has_force_random() const;
  inline void clear_force_random();
  static const int kForceRandomFieldNumber = 2;
  inline bool force_random() const;
  inline void set_force_random(bool value);
  
  // optional bool use_max_loss = 3 [default = false];
  inline bool has_use_max_loss() const;
  inline void clear_use_max_loss();
  static const int kUseMaxLossFieldNumber = 3;
  inline bool use_max_loss() const;
  inline void set_use_max_loss(bool value);
  
  // @@protoc_insertion_point(class_scope:caffepro.SoftMaxOHEMParameter)
 private:
  inline void set_has_ohem_size();
  inline void clear_has_ohem_size();
  inline void set_has_force_random();
  inline void clear_has_force_random();
  inline void set_has_use_max_loss();
  inline void clear_has_use_max_loss();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 ohem_size_;
  bool force_random_;
  bool use_max_loss_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_caffe_2eproto();
  friend void protobuf_AssignDesc_caffe_2eproto();
  friend void protobuf_ShutdownFile_caffe_2eproto();
  
  void InitAsDefaultInstance();
  static SoftMaxOHEMParameter* default_instance_;
};
// -------------------------------------------------------------------

class SoftMaxOHEMSplitParameter : public ::google::protobuf::Message {
 public:
  SoftMaxOHEMSplitParameter();
  virtual ~SoftMaxOHEMSplitParameter();
  
  SoftMaxOHEMSplitParameter(const SoftMaxOHEMSplitParameter& from);
  
  inline SoftMaxOHEMSplitParameter& operator=(const SoftMaxOHEMSplitParameter& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SoftMaxOHEMSplitParameter& default_instance();
  
  void Swap(SoftMaxOHEMSplitParameter* other);
  
  // implements Message ----------------------------------------------
  
  SoftMaxOHEMSplitParameter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SoftMaxOHEMSplitParameter& from);
  void MergeFrom(const SoftMaxOHEMSplitParameter& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 ohem_size = 1 [default = 64];
  inline bool has_ohem_size() const;
  inline void clear_ohem_size();
  static const int kOhemSizeFieldNumber = 1;
  inline ::google::protobuf::int32 ohem_size() const;
  inline void set_ohem_size(::google::protobuf::int32 value);
  
  // optional bool force_random = 2 [default = false];
  inline bool has_force_random() const;
  inline void clear_force_random();
  static const int kForceRandomFieldNumber = 2;
  inline bool force_random() const;
  inline void set_force_random(bool value);
  
  // optional bool use_max_loss = 3 [default = false];
  inline bool has_use_max_loss() const;
  inline void clear_use_max_loss();
  static const int kUseMaxLossFieldNumber = 3;
  inline bool use_max_loss() const;
  inline void set_use_max_loss(bool value);
  
  // @@protoc_insertion_point(class_scope:caffepro.SoftMaxOHEMSplitParameter)
 private:
  inline void set_has_ohem_size();
  inline void clear_has_ohem_size();
  inline void set_has_force_random();
  inline void clear_has_force_random();
  inline void set_has_use_max_loss();
  inline void clear_has_use_max_loss();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 ohem_size_;
  bool force_random_;
  bool use_max_loss_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_caffe_2eproto();
  friend void protobuf_AssignDesc_caffe_2eproto();
  friend void protobuf_ShutdownFile_caffe_2eproto();
  
  void InitAsDefaultInstance();
  static SoftMaxOHEMSplitParameter* default_instance_;
};
// ===================================================================


// ===================================================================

// BlobProto

// optional int32 num = 1 [default = 0];
inline bool BlobProto::has_num() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BlobProto::set_has_num() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BlobProto::clear_has_num() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BlobProto::clear_num() {
  num_ = 0;
  clear_has_num();
}
inline ::google::protobuf::int32 BlobProto::num() const {
  return num_;
}
inline void BlobProto::set_num(::google::protobuf::int32 value) {
  set_has_num();
  num_ = value;
}

// optional int32 channels = 2 [default = 0];
inline bool BlobProto::has_channels() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BlobProto::set_has_channels() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BlobProto::clear_has_channels() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BlobProto::clear_channels() {
  channels_ = 0;
  clear_has_channels();
}
inline ::google::protobuf::int32 BlobProto::channels() const {
  return channels_;
}
inline void BlobProto::set_channels(::google::protobuf::int32 value) {
  set_has_channels();
  channels_ = value;
}

// optional int32 height = 3 [default = 0];
inline bool BlobProto::has_height() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BlobProto::set_has_height() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BlobProto::clear_has_height() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BlobProto::clear_height() {
  height_ = 0;
  clear_has_height();
}
inline ::google::protobuf::int32 BlobProto::height() const {
  return height_;
}
inline void BlobProto::set_height(::google::protobuf::int32 value) {
  set_has_height();
  height_ = value;
}

// optional int32 width = 4 [default = 0];
inline bool BlobProto::has_width() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BlobProto::set_has_width() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BlobProto::clear_has_width() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BlobProto::clear_width() {
  width_ = 0;
  clear_has_width();
}
inline ::google::protobuf::int32 BlobProto::width() const {
  return width_;
}
inline void BlobProto::set_width(::google::protobuf::int32 value) {
  set_has_width();
  width_ = value;
}

// repeated float data = 5 [packed = true];
inline int BlobProto::data_size() const {
  return data_.size();
}
inline void BlobProto::clear_data() {
  data_.Clear();
}
inline float BlobProto::data(int index) const {
  return data_.Get(index);
}
inline void BlobProto::set_data(int index, float value) {
  data_.Set(index, value);
}
inline void BlobProto::add_data(float value) {
  data_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
BlobProto::data() const {
  return data_;
}
inline ::google::protobuf::RepeatedField< float >*
BlobProto::mutable_data() {
  return &data_;
}

// repeated float diff = 6 [packed = true];
inline int BlobProto::diff_size() const {
  return diff_.size();
}
inline void BlobProto::clear_diff() {
  diff_.Clear();
}
inline float BlobProto::diff(int index) const {
  return diff_.Get(index);
}
inline void BlobProto::set_diff(int index, float value) {
  diff_.Set(index, value);
}
inline void BlobProto::add_diff(float value) {
  diff_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
BlobProto::diff() const {
  return diff_;
}
inline ::google::protobuf::RepeatedField< float >*
BlobProto::mutable_diff() {
  return &diff_;
}

// -------------------------------------------------------------------

// BlobProtoVector

// repeated .caffepro.BlobProto blobs = 1;
inline int BlobProtoVector::blobs_size() const {
  return blobs_.size();
}
inline void BlobProtoVector::clear_blobs() {
  blobs_.Clear();
}
inline const ::caffepro::BlobProto& BlobProtoVector::blobs(int index) const {
  return blobs_.Get(index);
}
inline ::caffepro::BlobProto* BlobProtoVector::mutable_blobs(int index) {
  return blobs_.Mutable(index);
}
inline ::caffepro::BlobProto* BlobProtoVector::add_blobs() {
  return blobs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::caffepro::BlobProto >&
BlobProtoVector::blobs() const {
  return blobs_;
}
inline ::google::protobuf::RepeatedPtrField< ::caffepro::BlobProto >*
BlobProtoVector::mutable_blobs() {
  return &blobs_;
}

// -------------------------------------------------------------------

// Datum

// optional int32 channels = 1;
inline bool Datum::has_channels() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Datum::set_has_channels() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Datum::clear_has_channels() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Datum::clear_channels() {
  channels_ = 0;
  clear_has_channels();
}
inline ::google::protobuf::int32 Datum::channels() const {
  return channels_;
}
inline void Datum::set_channels(::google::protobuf::int32 value) {
  set_has_channels();
  channels_ = value;
}

// optional int32 height = 2;
inline bool Datum::has_height() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Datum::set_has_height() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Datum::clear_has_height() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Datum::clear_height() {
  height_ = 0;
  clear_has_height();
}
inline ::google::protobuf::int32 Datum::height() const {
  return height_;
}
inline void Datum::set_height(::google::protobuf::int32 value) {
  set_has_height();
  height_ = value;
}

// optional int32 width = 3;
inline bool Datum::has_width() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Datum::set_has_width() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Datum::clear_has_width() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Datum::clear_width() {
  width_ = 0;
  clear_has_width();
}
inline ::google::protobuf::int32 Datum::width() const {
  return width_;
}
inline void Datum::set_width(::google::protobuf::int32 value) {
  set_has_width();
  width_ = value;
}

// optional bytes data = 4;
inline bool Datum::has_data() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Datum::set_has_data() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Datum::clear_has_data() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Datum::clear_data() {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& Datum::data() const {
  return *data_;
}
inline void Datum::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void Datum::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void Datum::set_data(const void* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Datum::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  return data_;
}
inline ::std::string* Datum::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 label = 5;
inline bool Datum::has_label() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Datum::set_has_label() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Datum::clear_has_label() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Datum::clear_label() {
  label_ = 0;
  clear_has_label();
}
inline ::google::protobuf::int32 Datum::label() const {
  return label_;
}
inline void Datum::set_label(::google::protobuf::int32 value) {
  set_has_label();
  label_ = value;
}

// repeated float float_data = 6;
inline int Datum::float_data_size() const {
  return float_data_.size();
}
inline void Datum::clear_float_data() {
  float_data_.Clear();
}
inline float Datum::float_data(int index) const {
  return float_data_.Get(index);
}
inline void Datum::set_float_data(int index, float value) {
  float_data_.Set(index, value);
}
inline void Datum::add_float_data(float value) {
  float_data_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
Datum::float_data() const {
  return float_data_;
}
inline ::google::protobuf::RepeatedField< float >*
Datum::mutable_float_data() {
  return &float_data_;
}

// -------------------------------------------------------------------

// FillerParameter

// optional string type = 1 [default = "constant"];
inline bool FillerParameter::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FillerParameter::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FillerParameter::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FillerParameter::clear_type() {
  if (type_ != &_default_type_) {
    type_->assign(_default_type_);
  }
  clear_has_type();
}
inline const ::std::string& FillerParameter::type() const {
  return *type_;
}
inline void FillerParameter::set_type(const ::std::string& value) {
  set_has_type();
  if (type_ == &_default_type_) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void FillerParameter::set_type(const char* value) {
  set_has_type();
  if (type_ == &_default_type_) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void FillerParameter::set_type(const char* value, size_t size) {
  set_has_type();
  if (type_ == &_default_type_) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FillerParameter::mutable_type() {
  set_has_type();
  if (type_ == &_default_type_) {
    type_ = new ::std::string(_default_type_);
  }
  return type_;
}
inline ::std::string* FillerParameter::release_type() {
  clear_has_type();
  if (type_ == &_default_type_) {
    return NULL;
  } else {
    ::std::string* temp = type_;
    type_ = const_cast< ::std::string*>(&_default_type_);
    return temp;
  }
}

// optional float value = 2 [default = 0];
inline bool FillerParameter::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FillerParameter::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FillerParameter::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FillerParameter::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline float FillerParameter::value() const {
  return value_;
}
inline void FillerParameter::set_value(float value) {
  set_has_value();
  value_ = value;
}

// optional float min = 3 [default = 0];
inline bool FillerParameter::has_min() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FillerParameter::set_has_min() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FillerParameter::clear_has_min() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FillerParameter::clear_min() {
  min_ = 0;
  clear_has_min();
}
inline float FillerParameter::min() const {
  return min_;
}
inline void FillerParameter::set_min(float value) {
  set_has_min();
  min_ = value;
}

// optional float max = 4 [default = 1];
inline bool FillerParameter::has_max() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FillerParameter::set_has_max() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FillerParameter::clear_has_max() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FillerParameter::clear_max() {
  max_ = 1;
  clear_has_max();
}
inline float FillerParameter::max() const {
  return max_;
}
inline void FillerParameter::set_max(float value) {
  set_has_max();
  max_ = value;
}

// optional float mean = 5 [default = 0];
inline bool FillerParameter::has_mean() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FillerParameter::set_has_mean() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FillerParameter::clear_has_mean() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FillerParameter::clear_mean() {
  mean_ = 0;
  clear_has_mean();
}
inline float FillerParameter::mean() const {
  return mean_;
}
inline void FillerParameter::set_mean(float value) {
  set_has_mean();
  mean_ = value;
}

// optional float std = 6 [default = 1];
inline bool FillerParameter::has_std() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void FillerParameter::set_has_std() {
  _has_bits_[0] |= 0x00000020u;
}
inline void FillerParameter::clear_has_std() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void FillerParameter::clear_std() {
  std_ = 1;
  clear_has_std();
}
inline float FillerParameter::std() const {
  return std_;
}
inline void FillerParameter::set_std(float value) {
  set_has_std();
  std_ = value;
}

// -------------------------------------------------------------------

// LayerParameter

// optional string name = 1;
inline bool LayerParameter::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LayerParameter::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LayerParameter::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LayerParameter::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& LayerParameter::name() const {
  return *name_;
}
inline void LayerParameter::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void LayerParameter::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void LayerParameter::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LayerParameter::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* LayerParameter::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string type = 2;
inline bool LayerParameter::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LayerParameter::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LayerParameter::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LayerParameter::clear_type() {
  if (type_ != &::google::protobuf::internal::kEmptyString) {
    type_->clear();
  }
  clear_has_type();
}
inline const ::std::string& LayerParameter::type() const {
  return *type_;
}
inline void LayerParameter::set_type(const ::std::string& value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void LayerParameter::set_type(const char* value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void LayerParameter::set_type(const char* value, size_t size) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LayerParameter::mutable_type() {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  return type_;
}
inline ::std::string* LayerParameter::release_type() {
  clear_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = type_;
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .caffepro.BlobProto blobs = 3;
inline int LayerParameter::blobs_size() const {
  return blobs_.size();
}
inline void LayerParameter::clear_blobs() {
  blobs_.Clear();
}
inline const ::caffepro::BlobProto& LayerParameter::blobs(int index) const {
  return blobs_.Get(index);
}
inline ::caffepro::BlobProto* LayerParameter::mutable_blobs(int index) {
  return blobs_.Mutable(index);
}
inline ::caffepro::BlobProto* LayerParameter::add_blobs() {
  return blobs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::caffepro::BlobProto >&
LayerParameter::blobs() const {
  return blobs_;
}
inline ::google::protobuf::RepeatedPtrField< ::caffepro::BlobProto >*
LayerParameter::mutable_blobs() {
  return &blobs_;
}

// repeated float blobs_lr = 4;
inline int LayerParameter::blobs_lr_size() const {
  return blobs_lr_.size();
}
inline void LayerParameter::clear_blobs_lr() {
  blobs_lr_.Clear();
}
inline float LayerParameter::blobs_lr(int index) const {
  return blobs_lr_.Get(index);
}
inline void LayerParameter::set_blobs_lr(int index, float value) {
  blobs_lr_.Set(index, value);
}
inline void LayerParameter::add_blobs_lr(float value) {
  blobs_lr_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
LayerParameter::blobs_lr() const {
  return blobs_lr_;
}
inline ::google::protobuf::RepeatedField< float >*
LayerParameter::mutable_blobs_lr() {
  return &blobs_lr_;
}

// repeated float weight_decay = 5;
inline int LayerParameter::weight_decay_size() const {
  return weight_decay_.size();
}
inline void LayerParameter::clear_weight_decay() {
  weight_decay_.Clear();
}
inline float LayerParameter::weight_decay(int index) const {
  return weight_decay_.Get(index);
}
inline void LayerParameter::set_weight_decay(int index, float value) {
  weight_decay_.Set(index, value);
}
inline void LayerParameter::add_weight_decay(float value) {
  weight_decay_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
LayerParameter::weight_decay() const {
  return weight_decay_;
}
inline ::google::protobuf::RepeatedField< float >*
LayerParameter::mutable_weight_decay() {
  return &weight_decay_;
}

// repeated string blob_source_layer = 6;
inline int LayerParameter::blob_source_layer_size() const {
  return blob_source_layer_.size();
}
inline void LayerParameter::clear_blob_source_layer() {
  blob_source_layer_.Clear();
}
inline const ::std::string& LayerParameter::blob_source_layer(int index) const {
  return blob_source_layer_.Get(index);
}
inline ::std::string* LayerParameter::mutable_blob_source_layer(int index) {
  return blob_source_layer_.Mutable(index);
}
inline void LayerParameter::set_blob_source_layer(int index, const ::std::string& value) {
  blob_source_layer_.Mutable(index)->assign(value);
}
inline void LayerParameter::set_blob_source_layer(int index, const char* value) {
  blob_source_layer_.Mutable(index)->assign(value);
}
inline void LayerParameter::set_blob_source_layer(int index, const char* value, size_t size) {
  blob_source_layer_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LayerParameter::add_blob_source_layer() {
  return blob_source_layer_.Add();
}
inline void LayerParameter::add_blob_source_layer(const ::std::string& value) {
  blob_source_layer_.Add()->assign(value);
}
inline void LayerParameter::add_blob_source_layer(const char* value) {
  blob_source_layer_.Add()->assign(value);
}
inline void LayerParameter::add_blob_source_layer(const char* value, size_t size) {
  blob_source_layer_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
LayerParameter::blob_source_layer() const {
  return blob_source_layer_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
LayerParameter::mutable_blob_source_layer() {
  return &blob_source_layer_;
}

// optional .caffepro.ConcatParameter concat_param = 8;
inline bool LayerParameter::has_concat_param() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void LayerParameter::set_has_concat_param() {
  _has_bits_[0] |= 0x00000040u;
}
inline void LayerParameter::clear_has_concat_param() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void LayerParameter::clear_concat_param() {
  if (concat_param_ != NULL) concat_param_->::caffepro::ConcatParameter::Clear();
  clear_has_concat_param();
}
inline const ::caffepro::ConcatParameter& LayerParameter::concat_param() const {
  return concat_param_ != NULL ? *concat_param_ : *default_instance_->concat_param_;
}
inline ::caffepro::ConcatParameter* LayerParameter::mutable_concat_param() {
  set_has_concat_param();
  if (concat_param_ == NULL) concat_param_ = new ::caffepro::ConcatParameter;
  return concat_param_;
}
inline ::caffepro::ConcatParameter* LayerParameter::release_concat_param() {
  clear_has_concat_param();
  ::caffepro::ConcatParameter* temp = concat_param_;
  concat_param_ = NULL;
  return temp;
}

// optional .caffepro.ConvolutionParameter conv_param = 9;
inline bool LayerParameter::has_conv_param() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void LayerParameter::set_has_conv_param() {
  _has_bits_[0] |= 0x00000080u;
}
inline void LayerParameter::clear_has_conv_param() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void LayerParameter::clear_conv_param() {
  if (conv_param_ != NULL) conv_param_->::caffepro::ConvolutionParameter::Clear();
  clear_has_conv_param();
}
inline const ::caffepro::ConvolutionParameter& LayerParameter::conv_param() const {
  return conv_param_ != NULL ? *conv_param_ : *default_instance_->conv_param_;
}
inline ::caffepro::ConvolutionParameter* LayerParameter::mutable_conv_param() {
  set_has_conv_param();
  if (conv_param_ == NULL) conv_param_ = new ::caffepro::ConvolutionParameter;
  return conv_param_;
}
inline ::caffepro::ConvolutionParameter* LayerParameter::release_conv_param() {
  clear_has_conv_param();
  ::caffepro::ConvolutionParameter* temp = conv_param_;
  conv_param_ = NULL;
  return temp;
}

// optional .caffepro.DataParameter_BigFile data_bigfile_param = 11;
inline bool LayerParameter::has_data_bigfile_param() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void LayerParameter::set_has_data_bigfile_param() {
  _has_bits_[0] |= 0x00000100u;
}
inline void LayerParameter::clear_has_data_bigfile_param() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void LayerParameter::clear_data_bigfile_param() {
  if (data_bigfile_param_ != NULL) data_bigfile_param_->::caffepro::DataParameter_BigFile::Clear();
  clear_has_data_bigfile_param();
}
inline const ::caffepro::DataParameter_BigFile& LayerParameter::data_bigfile_param() const {
  return data_bigfile_param_ != NULL ? *data_bigfile_param_ : *default_instance_->data_bigfile_param_;
}
inline ::caffepro::DataParameter_BigFile* LayerParameter::mutable_data_bigfile_param() {
  set_has_data_bigfile_param();
  if (data_bigfile_param_ == NULL) data_bigfile_param_ = new ::caffepro::DataParameter_BigFile;
  return data_bigfile_param_;
}
inline ::caffepro::DataParameter_BigFile* LayerParameter::release_data_bigfile_param() {
  clear_has_data_bigfile_param();
  ::caffepro::DataParameter_BigFile* temp = data_bigfile_param_;
  data_bigfile_param_ = NULL;
  return temp;
}

// optional .caffepro.DropoutParameter dropout_param = 12;
inline bool LayerParameter::has_dropout_param() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void LayerParameter::set_has_dropout_param() {
  _has_bits_[0] |= 0x00000200u;
}
inline void LayerParameter::clear_has_dropout_param() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void LayerParameter::clear_dropout_param() {
  if (dropout_param_ != NULL) dropout_param_->::caffepro::DropoutParameter::Clear();
  clear_has_dropout_param();
}
inline const ::caffepro::DropoutParameter& LayerParameter::dropout_param() const {
  return dropout_param_ != NULL ? *dropout_param_ : *default_instance_->dropout_param_;
}
inline ::caffepro::DropoutParameter* LayerParameter::mutable_dropout_param() {
  set_has_dropout_param();
  if (dropout_param_ == NULL) dropout_param_ = new ::caffepro::DropoutParameter;
  return dropout_param_;
}
inline ::caffepro::DropoutParameter* LayerParameter::release_dropout_param() {
  clear_has_dropout_param();
  ::caffepro::DropoutParameter* temp = dropout_param_;
  dropout_param_ = NULL;
  return temp;
}

// optional .caffepro.InfogainLossParameter infogain_loss_param = 16;
inline bool LayerParameter::has_infogain_loss_param() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void LayerParameter::set_has_infogain_loss_param() {
  _has_bits_[0] |= 0x00000400u;
}
inline void LayerParameter::clear_has_infogain_loss_param() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void LayerParameter::clear_infogain_loss_param() {
  if (infogain_loss_param_ != NULL) infogain_loss_param_->::caffepro::InfogainLossParameter::Clear();
  clear_has_infogain_loss_param();
}
inline const ::caffepro::InfogainLossParameter& LayerParameter::infogain_loss_param() const {
  return infogain_loss_param_ != NULL ? *infogain_loss_param_ : *default_instance_->infogain_loss_param_;
}
inline ::caffepro::InfogainLossParameter* LayerParameter::mutable_infogain_loss_param() {
  set_has_infogain_loss_param();
  if (infogain_loss_param_ == NULL) infogain_loss_param_ = new ::caffepro::InfogainLossParameter;
  return infogain_loss_param_;
}
inline ::caffepro::InfogainLossParameter* LayerParameter::release_infogain_loss_param() {
  clear_has_infogain_loss_param();
  ::caffepro::InfogainLossParameter* temp = infogain_loss_param_;
  infogain_loss_param_ = NULL;
  return temp;
}

// optional .caffepro.InnerProductParameter inner_product_param = 17;
inline bool LayerParameter::has_inner_product_param() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void LayerParameter::set_has_inner_product_param() {
  _has_bits_[0] |= 0x00000800u;
}
inline void LayerParameter::clear_has_inner_product_param() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void LayerParameter::clear_inner_product_param() {
  if (inner_product_param_ != NULL) inner_product_param_->::caffepro::InnerProductParameter::Clear();
  clear_has_inner_product_param();
}
inline const ::caffepro::InnerProductParameter& LayerParameter::inner_product_param() const {
  return inner_product_param_ != NULL ? *inner_product_param_ : *default_instance_->inner_product_param_;
}
inline ::caffepro::InnerProductParameter* LayerParameter::mutable_inner_product_param() {
  set_has_inner_product_param();
  if (inner_product_param_ == NULL) inner_product_param_ = new ::caffepro::InnerProductParameter;
  return inner_product_param_;
}
inline ::caffepro::InnerProductParameter* LayerParameter::release_inner_product_param() {
  clear_has_inner_product_param();
  ::caffepro::InnerProductParameter* temp = inner_product_param_;
  inner_product_param_ = NULL;
  return temp;
}

// optional .caffepro.LRNParameter lrn_param = 18;
inline bool LayerParameter::has_lrn_param() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void LayerParameter::set_has_lrn_param() {
  _has_bits_[0] |= 0x00001000u;
}
inline void LayerParameter::clear_has_lrn_param() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void LayerParameter::clear_lrn_param() {
  if (lrn_param_ != NULL) lrn_param_->::caffepro::LRNParameter::Clear();
  clear_has_lrn_param();
}
inline const ::caffepro::LRNParameter& LayerParameter::lrn_param() const {
  return lrn_param_ != NULL ? *lrn_param_ : *default_instance_->lrn_param_;
}
inline ::caffepro::LRNParameter* LayerParameter::mutable_lrn_param() {
  set_has_lrn_param();
  if (lrn_param_ == NULL) lrn_param_ = new ::caffepro::LRNParameter;
  return lrn_param_;
}
inline ::caffepro::LRNParameter* LayerParameter::release_lrn_param() {
  clear_has_lrn_param();
  ::caffepro::LRNParameter* temp = lrn_param_;
  lrn_param_ = NULL;
  return temp;
}

// optional .caffepro.PoolingParameter pool_param = 19;
inline bool LayerParameter::has_pool_param() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void LayerParameter::set_has_pool_param() {
  _has_bits_[0] |= 0x00002000u;
}
inline void LayerParameter::clear_has_pool_param() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void LayerParameter::clear_pool_param() {
  if (pool_param_ != NULL) pool_param_->::caffepro::PoolingParameter::Clear();
  clear_has_pool_param();
}
inline const ::caffepro::PoolingParameter& LayerParameter::pool_param() const {
  return pool_param_ != NULL ? *pool_param_ : *default_instance_->pool_param_;
}
inline ::caffepro::PoolingParameter* LayerParameter::mutable_pool_param() {
  set_has_pool_param();
  if (pool_param_ == NULL) pool_param_ = new ::caffepro::PoolingParameter;
  return pool_param_;
}
inline ::caffepro::PoolingParameter* LayerParameter::release_pool_param() {
  clear_has_pool_param();
  ::caffepro::PoolingParameter* temp = pool_param_;
  pool_param_ = NULL;
  return temp;
}

// optional .caffepro.PowerParameter power_param = 20;
inline bool LayerParameter::has_power_param() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void LayerParameter::set_has_power_param() {
  _has_bits_[0] |= 0x00004000u;
}
inline void LayerParameter::clear_has_power_param() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void LayerParameter::clear_power_param() {
  if (power_param_ != NULL) power_param_->::caffepro::PowerParameter::Clear();
  clear_has_power_param();
}
inline const ::caffepro::PowerParameter& LayerParameter::power_param() const {
  return power_param_ != NULL ? *power_param_ : *default_instance_->power_param_;
}
inline ::caffepro::PowerParameter* LayerParameter::mutable_power_param() {
  set_has_power_param();
  if (power_param_ == NULL) power_param_ = new ::caffepro::PowerParameter;
  return power_param_;
}
inline ::caffepro::PowerParameter* LayerParameter::release_power_param() {
  clear_has_power_param();
  ::caffepro::PowerParameter* temp = power_param_;
  power_param_ = NULL;
  return temp;
}

// optional .caffepro.PaddingParameter padding_param = 23;
inline bool LayerParameter::has_padding_param() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void LayerParameter::set_has_padding_param() {
  _has_bits_[0] |= 0x00008000u;
}
inline void LayerParameter::clear_has_padding_param() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void LayerParameter::clear_padding_param() {
  if (padding_param_ != NULL) padding_param_->::caffepro::PaddingParameter::Clear();
  clear_has_padding_param();
}
inline const ::caffepro::PaddingParameter& LayerParameter::padding_param() const {
  return padding_param_ != NULL ? *padding_param_ : *default_instance_->padding_param_;
}
inline ::caffepro::PaddingParameter* LayerParameter::mutable_padding_param() {
  set_has_padding_param();
  if (padding_param_ == NULL) padding_param_ = new ::caffepro::PaddingParameter;
  return padding_param_;
}
inline ::caffepro::PaddingParameter* LayerParameter::release_padding_param() {
  clear_has_padding_param();
  ::caffepro::PaddingParameter* temp = padding_param_;
  padding_param_ = NULL;
  return temp;
}

// optional .caffepro.SPMParameter spm_param = 24;
inline bool LayerParameter::has_spm_param() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void LayerParameter::set_has_spm_param() {
  _has_bits_[0] |= 0x00010000u;
}
inline void LayerParameter::clear_has_spm_param() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void LayerParameter::clear_spm_param() {
  if (spm_param_ != NULL) spm_param_->::caffepro::SPMParameter::Clear();
  clear_has_spm_param();
}
inline const ::caffepro::SPMParameter& LayerParameter::spm_param() const {
  return spm_param_ != NULL ? *spm_param_ : *default_instance_->spm_param_;
}
inline ::caffepro::SPMParameter* LayerParameter::mutable_spm_param() {
  set_has_spm_param();
  if (spm_param_ == NULL) spm_param_ = new ::caffepro::SPMParameter;
  return spm_param_;
}
inline ::caffepro::SPMParameter* LayerParameter::release_spm_param() {
  clear_has_spm_param();
  ::caffepro::SPMParameter* temp = spm_param_;
  spm_param_ = NULL;
  return temp;
}

// optional int32 gpu_id = 30 [default = -1];
inline bool LayerParameter::has_gpu_id() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void LayerParameter::set_has_gpu_id() {
  _has_bits_[0] |= 0x00020000u;
}
inline void LayerParameter::clear_has_gpu_id() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void LayerParameter::clear_gpu_id() {
  gpu_id_ = -1;
  clear_has_gpu_id();
}
inline ::google::protobuf::int32 LayerParameter::gpu_id() const {
  return gpu_id_;
}
inline void LayerParameter::set_gpu_id(::google::protobuf::int32 value) {
  set_has_gpu_id();
  gpu_id_ = value;
}

// optional .caffepro.GPUSplitParameter gpu_split = 31;
inline bool LayerParameter::has_gpu_split() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void LayerParameter::set_has_gpu_split() {
  _has_bits_[0] |= 0x00040000u;
}
inline void LayerParameter::clear_has_gpu_split() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void LayerParameter::clear_gpu_split() {
  if (gpu_split_ != NULL) gpu_split_->::caffepro::GPUSplitParameter::Clear();
  clear_has_gpu_split();
}
inline const ::caffepro::GPUSplitParameter& LayerParameter::gpu_split() const {
  return gpu_split_ != NULL ? *gpu_split_ : *default_instance_->gpu_split_;
}
inline ::caffepro::GPUSplitParameter* LayerParameter::mutable_gpu_split() {
  set_has_gpu_split();
  if (gpu_split_ == NULL) gpu_split_ = new ::caffepro::GPUSplitParameter;
  return gpu_split_;
}
inline ::caffepro::GPUSplitParameter* LayerParameter::release_gpu_split() {
  clear_has_gpu_split();
  ::caffepro::GPUSplitParameter* temp = gpu_split_;
  gpu_split_ = NULL;
  return temp;
}

// optional .caffepro.LossParameter loss_param = 34;
inline bool LayerParameter::has_loss_param() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void LayerParameter::set_has_loss_param() {
  _has_bits_[0] |= 0x00080000u;
}
inline void LayerParameter::clear_has_loss_param() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void LayerParameter::clear_loss_param() {
  if (loss_param_ != NULL) loss_param_->::caffepro::LossParameter::Clear();
  clear_has_loss_param();
}
inline const ::caffepro::LossParameter& LayerParameter::loss_param() const {
  return loss_param_ != NULL ? *loss_param_ : *default_instance_->loss_param_;
}
inline ::caffepro::LossParameter* LayerParameter::mutable_loss_param() {
  set_has_loss_param();
  if (loss_param_ == NULL) loss_param_ = new ::caffepro::LossParameter;
  return loss_param_;
}
inline ::caffepro::LossParameter* LayerParameter::release_loss_param() {
  clear_has_loss_param();
  ::caffepro::LossParameter* temp = loss_param_;
  loss_param_ = NULL;
  return temp;
}

// optional bool record = 35 [default = false];
inline bool LayerParameter::has_record() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void LayerParameter::set_has_record() {
  _has_bits_[0] |= 0x00100000u;
}
inline void LayerParameter::clear_has_record() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void LayerParameter::clear_record() {
  record_ = false;
  clear_has_record();
}
inline bool LayerParameter::record() const {
  return record_;
}
inline void LayerParameter::set_record(bool value) {
  set_has_record();
  record_ = value;
}

// optional .caffepro.ReluParameter relu_param = 36;
inline bool LayerParameter::has_relu_param() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void LayerParameter::set_has_relu_param() {
  _has_bits_[0] |= 0x00200000u;
}
inline void LayerParameter::clear_has_relu_param() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void LayerParameter::clear_relu_param() {
  if (relu_param_ != NULL) relu_param_->::caffepro::ReluParameter::Clear();
  clear_has_relu_param();
}
inline const ::caffepro::ReluParameter& LayerParameter::relu_param() const {
  return relu_param_ != NULL ? *relu_param_ : *default_instance_->relu_param_;
}
inline ::caffepro::ReluParameter* LayerParameter::mutable_relu_param() {
  set_has_relu_param();
  if (relu_param_ == NULL) relu_param_ = new ::caffepro::ReluParameter;
  return relu_param_;
}
inline ::caffepro::ReluParameter* LayerParameter::release_relu_param() {
  clear_has_relu_param();
  ::caffepro::ReluParameter* temp = relu_param_;
  relu_param_ = NULL;
  return temp;
}

// optional .caffepro.LearnableLeakReluParameter learnable_leak_relu_param = 37;
inline bool LayerParameter::has_learnable_leak_relu_param() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void LayerParameter::set_has_learnable_leak_relu_param() {
  _has_bits_[0] |= 0x00400000u;
}
inline void LayerParameter::clear_has_learnable_leak_relu_param() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void LayerParameter::clear_learnable_leak_relu_param() {
  if (learnable_leak_relu_param_ != NULL) learnable_leak_relu_param_->::caffepro::LearnableLeakReluParameter::Clear();
  clear_has_learnable_leak_relu_param();
}
inline const ::caffepro::LearnableLeakReluParameter& LayerParameter::learnable_leak_relu_param() const {
  return learnable_leak_relu_param_ != NULL ? *learnable_leak_relu_param_ : *default_instance_->learnable_leak_relu_param_;
}
inline ::caffepro::LearnableLeakReluParameter* LayerParameter::mutable_learnable_leak_relu_param() {
  set_has_learnable_leak_relu_param();
  if (learnable_leak_relu_param_ == NULL) learnable_leak_relu_param_ = new ::caffepro::LearnableLeakReluParameter;
  return learnable_leak_relu_param_;
}
inline ::caffepro::LearnableLeakReluParameter* LayerParameter::release_learnable_leak_relu_param() {
  clear_has_learnable_leak_relu_param();
  ::caffepro::LearnableLeakReluParameter* temp = learnable_leak_relu_param_;
  learnable_leak_relu_param_ = NULL;
  return temp;
}

// repeated .caffepro.LayerParameter.UpdateMethod update_method = 38;
inline int LayerParameter::update_method_size() const {
  return update_method_.size();
}
inline void LayerParameter::clear_update_method() {
  update_method_.Clear();
}
inline ::caffepro::LayerParameter_UpdateMethod LayerParameter::update_method(int index) const {
  return static_cast< ::caffepro::LayerParameter_UpdateMethod >(update_method_.Get(index));
}
inline void LayerParameter::set_update_method(int index, ::caffepro::LayerParameter_UpdateMethod value) {
  GOOGLE_DCHECK(::caffepro::LayerParameter_UpdateMethod_IsValid(value));
  update_method_.Set(index, value);
}
inline void LayerParameter::add_update_method(::caffepro::LayerParameter_UpdateMethod value) {
  GOOGLE_DCHECK(::caffepro::LayerParameter_UpdateMethod_IsValid(value));
  update_method_.Add(value);
}
inline const ::google::protobuf::RepeatedField<int>&
LayerParameter::update_method() const {
  return update_method_;
}
inline ::google::protobuf::RepeatedField<int>*
LayerParameter::mutable_update_method() {
  return &update_method_;
}

// optional .caffepro.BatchNormalizationParameter batch_norm_param = 40;
inline bool LayerParameter::has_batch_norm_param() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void LayerParameter::set_has_batch_norm_param() {
  _has_bits_[0] |= 0x01000000u;
}
inline void LayerParameter::clear_has_batch_norm_param() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void LayerParameter::clear_batch_norm_param() {
  if (batch_norm_param_ != NULL) batch_norm_param_->::caffepro::BatchNormalizationParameter::Clear();
  clear_has_batch_norm_param();
}
inline const ::caffepro::BatchNormalizationParameter& LayerParameter::batch_norm_param() const {
  return batch_norm_param_ != NULL ? *batch_norm_param_ : *default_instance_->batch_norm_param_;
}
inline ::caffepro::BatchNormalizationParameter* LayerParameter::mutable_batch_norm_param() {
  set_has_batch_norm_param();
  if (batch_norm_param_ == NULL) batch_norm_param_ = new ::caffepro::BatchNormalizationParameter;
  return batch_norm_param_;
}
inline ::caffepro::BatchNormalizationParameter* LayerParameter::release_batch_norm_param() {
  clear_has_batch_norm_param();
  ::caffepro::BatchNormalizationParameter* temp = batch_norm_param_;
  batch_norm_param_ = NULL;
  return temp;
}

// optional bool record_internel = 41 [default = false];
inline bool LayerParameter::has_record_internel() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void LayerParameter::set_has_record_internel() {
  _has_bits_[0] |= 0x02000000u;
}
inline void LayerParameter::clear_has_record_internel() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void LayerParameter::clear_record_internel() {
  record_internel_ = false;
  clear_has_record_internel();
}
inline bool LayerParameter::record_internel() const {
  return record_internel_;
}
inline void LayerParameter::set_record_internel(bool value) {
  set_has_record_internel();
  record_internel_ = value;
}

// optional .caffepro.EltwiseSumParameter eltwise_sum_param = 44;
inline bool LayerParameter::has_eltwise_sum_param() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void LayerParameter::set_has_eltwise_sum_param() {
  _has_bits_[0] |= 0x04000000u;
}
inline void LayerParameter::clear_has_eltwise_sum_param() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void LayerParameter::clear_eltwise_sum_param() {
  if (eltwise_sum_param_ != NULL) eltwise_sum_param_->::caffepro::EltwiseSumParameter::Clear();
  clear_has_eltwise_sum_param();
}
inline const ::caffepro::EltwiseSumParameter& LayerParameter::eltwise_sum_param() const {
  return eltwise_sum_param_ != NULL ? *eltwise_sum_param_ : *default_instance_->eltwise_sum_param_;
}
inline ::caffepro::EltwiseSumParameter* LayerParameter::mutable_eltwise_sum_param() {
  set_has_eltwise_sum_param();
  if (eltwise_sum_param_ == NULL) eltwise_sum_param_ = new ::caffepro::EltwiseSumParameter;
  return eltwise_sum_param_;
}
inline ::caffepro::EltwiseSumParameter* LayerParameter::release_eltwise_sum_param() {
  clear_has_eltwise_sum_param();
  ::caffepro::EltwiseSumParameter* temp = eltwise_sum_param_;
  eltwise_sum_param_ = NULL;
  return temp;
}

// optional .caffepro.ClsLocLossParameter clsloc_loss_param = 48;
inline bool LayerParameter::has_clsloc_loss_param() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void LayerParameter::set_has_clsloc_loss_param() {
  _has_bits_[0] |= 0x08000000u;
}
inline void LayerParameter::clear_has_clsloc_loss_param() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void LayerParameter::clear_clsloc_loss_param() {
  if (clsloc_loss_param_ != NULL) clsloc_loss_param_->::caffepro::ClsLocLossParameter::Clear();
  clear_has_clsloc_loss_param();
}
inline const ::caffepro::ClsLocLossParameter& LayerParameter::clsloc_loss_param() const {
  return clsloc_loss_param_ != NULL ? *clsloc_loss_param_ : *default_instance_->clsloc_loss_param_;
}
inline ::caffepro::ClsLocLossParameter* LayerParameter::mutable_clsloc_loss_param() {
  set_has_clsloc_loss_param();
  if (clsloc_loss_param_ == NULL) clsloc_loss_param_ = new ::caffepro::ClsLocLossParameter;
  return clsloc_loss_param_;
}
inline ::caffepro::ClsLocLossParameter* LayerParameter::release_clsloc_loss_param() {
  clear_has_clsloc_loss_param();
  ::caffepro::ClsLocLossParameter* temp = clsloc_loss_param_;
  clsloc_loss_param_ = NULL;
  return temp;
}

// optional .caffepro.AnchorParameter anchor_param = 49;
inline bool LayerParameter::has_anchor_param() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void LayerParameter::set_has_anchor_param() {
  _has_bits_[0] |= 0x10000000u;
}
inline void LayerParameter::clear_has_anchor_param() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void LayerParameter::clear_anchor_param() {
  if (anchor_param_ != NULL) anchor_param_->::caffepro::AnchorParameter::Clear();
  clear_has_anchor_param();
}
inline const ::caffepro::AnchorParameter& LayerParameter::anchor_param() const {
  return anchor_param_ != NULL ? *anchor_param_ : *default_instance_->anchor_param_;
}
inline ::caffepro::AnchorParameter* LayerParameter::mutable_anchor_param() {
  set_has_anchor_param();
  if (anchor_param_ == NULL) anchor_param_ = new ::caffepro::AnchorParameter;
  return anchor_param_;
}
inline ::caffepro::AnchorParameter* LayerParameter::release_anchor_param() {
  clear_has_anchor_param();
  ::caffepro::AnchorParameter* temp = anchor_param_;
  anchor_param_ = NULL;
  return temp;
}

// optional .caffepro.GridGeneratorParameter grid_generator_param = 52;
inline bool LayerParameter::has_grid_generator_param() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void LayerParameter::set_has_grid_generator_param() {
  _has_bits_[0] |= 0x20000000u;
}
inline void LayerParameter::clear_has_grid_generator_param() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void LayerParameter::clear_grid_generator_param() {
  if (grid_generator_param_ != NULL) grid_generator_param_->::caffepro::GridGeneratorParameter::Clear();
  clear_has_grid_generator_param();
}
inline const ::caffepro::GridGeneratorParameter& LayerParameter::grid_generator_param() const {
  return grid_generator_param_ != NULL ? *grid_generator_param_ : *default_instance_->grid_generator_param_;
}
inline ::caffepro::GridGeneratorParameter* LayerParameter::mutable_grid_generator_param() {
  set_has_grid_generator_param();
  if (grid_generator_param_ == NULL) grid_generator_param_ = new ::caffepro::GridGeneratorParameter;
  return grid_generator_param_;
}
inline ::caffepro::GridGeneratorParameter* LayerParameter::release_grid_generator_param() {
  clear_has_grid_generator_param();
  ::caffepro::GridGeneratorParameter* temp = grid_generator_param_;
  grid_generator_param_ = NULL;
  return temp;
}

// optional .caffepro.DataEntryParameter data_entry_param = 53;
inline bool LayerParameter::has_data_entry_param() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void LayerParameter::set_has_data_entry_param() {
  _has_bits_[0] |= 0x40000000u;
}
inline void LayerParameter::clear_has_data_entry_param() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void LayerParameter::clear_data_entry_param() {
  if (data_entry_param_ != NULL) data_entry_param_->::caffepro::DataEntryParameter::Clear();
  clear_has_data_entry_param();
}
inline const ::caffepro::DataEntryParameter& LayerParameter::data_entry_param() const {
  return data_entry_param_ != NULL ? *data_entry_param_ : *default_instance_->data_entry_param_;
}
inline ::caffepro::DataEntryParameter* LayerParameter::mutable_data_entry_param() {
  set_has_data_entry_param();
  if (data_entry_param_ == NULL) data_entry_param_ = new ::caffepro::DataEntryParameter;
  return data_entry_param_;
}
inline ::caffepro::DataEntryParameter* LayerParameter::release_data_entry_param() {
  clear_has_data_entry_param();
  ::caffepro::DataEntryParameter* temp = data_entry_param_;
  data_entry_param_ = NULL;
  return temp;
}

// optional .caffepro.SampleParameter sample_param = 54;
inline bool LayerParameter::has_sample_param() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void LayerParameter::set_has_sample_param() {
  _has_bits_[0] |= 0x80000000u;
}
inline void LayerParameter::clear_has_sample_param() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void LayerParameter::clear_sample_param() {
  if (sample_param_ != NULL) sample_param_->::caffepro::SampleParameter::Clear();
  clear_has_sample_param();
}
inline const ::caffepro::SampleParameter& LayerParameter::sample_param() const {
  return sample_param_ != NULL ? *sample_param_ : *default_instance_->sample_param_;
}
inline ::caffepro::SampleParameter* LayerParameter::mutable_sample_param() {
  set_has_sample_param();
  if (sample_param_ == NULL) sample_param_ = new ::caffepro::SampleParameter;
  return sample_param_;
}
inline ::caffepro::SampleParameter* LayerParameter::release_sample_param() {
  clear_has_sample_param();
  ::caffepro::SampleParameter* temp = sample_param_;
  sample_param_ = NULL;
  return temp;
}

// optional string share_weights = 55;
inline bool LayerParameter::has_share_weights() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void LayerParameter::set_has_share_weights() {
  _has_bits_[1] |= 0x00000001u;
}
inline void LayerParameter::clear_has_share_weights() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void LayerParameter::clear_share_weights() {
  if (share_weights_ != &::google::protobuf::internal::kEmptyString) {
    share_weights_->clear();
  }
  clear_has_share_weights();
}
inline const ::std::string& LayerParameter::share_weights() const {
  return *share_weights_;
}
inline void LayerParameter::set_share_weights(const ::std::string& value) {
  set_has_share_weights();
  if (share_weights_ == &::google::protobuf::internal::kEmptyString) {
    share_weights_ = new ::std::string;
  }
  share_weights_->assign(value);
}
inline void LayerParameter::set_share_weights(const char* value) {
  set_has_share_weights();
  if (share_weights_ == &::google::protobuf::internal::kEmptyString) {
    share_weights_ = new ::std::string;
  }
  share_weights_->assign(value);
}
inline void LayerParameter::set_share_weights(const char* value, size_t size) {
  set_has_share_weights();
  if (share_weights_ == &::google::protobuf::internal::kEmptyString) {
    share_weights_ = new ::std::string;
  }
  share_weights_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LayerParameter::mutable_share_weights() {
  set_has_share_weights();
  if (share_weights_ == &::google::protobuf::internal::kEmptyString) {
    share_weights_ = new ::std::string;
  }
  return share_weights_;
}
inline ::std::string* LayerParameter::release_share_weights() {
  clear_has_share_weights();
  if (share_weights_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = share_weights_;
    share_weights_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .caffepro.ExpParameter exp_param = 56;
inline bool LayerParameter::has_exp_param() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void LayerParameter::set_has_exp_param() {
  _has_bits_[1] |= 0x00000002u;
}
inline void LayerParameter::clear_has_exp_param() {
  _has_bits_[1] &= ~0x00000002u;
}
inline void LayerParameter::clear_exp_param() {
  if (exp_param_ != NULL) exp_param_->::caffepro::ExpParameter::Clear();
  clear_has_exp_param();
}
inline const ::caffepro::ExpParameter& LayerParameter::exp_param() const {
  return exp_param_ != NULL ? *exp_param_ : *default_instance_->exp_param_;
}
inline ::caffepro::ExpParameter* LayerParameter::mutable_exp_param() {
  set_has_exp_param();
  if (exp_param_ == NULL) exp_param_ = new ::caffepro::ExpParameter;
  return exp_param_;
}
inline ::caffepro::ExpParameter* LayerParameter::release_exp_param() {
  clear_has_exp_param();
  ::caffepro::ExpParameter* temp = exp_param_;
  exp_param_ = NULL;
  return temp;
}

// optional .caffepro.BoundParameter bound_param = 57;
inline bool LayerParameter::has_bound_param() const {
  return (_has_bits_[1] & 0x00000004u) != 0;
}
inline void LayerParameter::set_has_bound_param() {
  _has_bits_[1] |= 0x00000004u;
}
inline void LayerParameter::clear_has_bound_param() {
  _has_bits_[1] &= ~0x00000004u;
}
inline void LayerParameter::clear_bound_param() {
  if (bound_param_ != NULL) bound_param_->::caffepro::BoundParameter::Clear();
  clear_has_bound_param();
}
inline const ::caffepro::BoundParameter& LayerParameter::bound_param() const {
  return bound_param_ != NULL ? *bound_param_ : *default_instance_->bound_param_;
}
inline ::caffepro::BoundParameter* LayerParameter::mutable_bound_param() {
  set_has_bound_param();
  if (bound_param_ == NULL) bound_param_ = new ::caffepro::BoundParameter;
  return bound_param_;
}
inline ::caffepro::BoundParameter* LayerParameter::release_bound_param() {
  clear_has_bound_param();
  ::caffepro::BoundParameter* temp = bound_param_;
  bound_param_ = NULL;
  return temp;
}

// optional .caffepro.ClusterParameter cluster_param = 58;
inline bool LayerParameter::has_cluster_param() const {
  return (_has_bits_[1] & 0x00000008u) != 0;
}
inline void LayerParameter::set_has_cluster_param() {
  _has_bits_[1] |= 0x00000008u;
}
inline void LayerParameter::clear_has_cluster_param() {
  _has_bits_[1] &= ~0x00000008u;
}
inline void LayerParameter::clear_cluster_param() {
  if (cluster_param_ != NULL) cluster_param_->::caffepro::ClusterParameter::Clear();
  clear_has_cluster_param();
}
inline const ::caffepro::ClusterParameter& LayerParameter::cluster_param() const {
  return cluster_param_ != NULL ? *cluster_param_ : *default_instance_->cluster_param_;
}
inline ::caffepro::ClusterParameter* LayerParameter::mutable_cluster_param() {
  set_has_cluster_param();
  if (cluster_param_ == NULL) cluster_param_ = new ::caffepro::ClusterParameter;
  return cluster_param_;
}
inline ::caffepro::ClusterParameter* LayerParameter::release_cluster_param() {
  clear_has_cluster_param();
  ::caffepro::ClusterParameter* temp = cluster_param_;
  cluster_param_ = NULL;
  return temp;
}

// optional .caffepro.OnlineKMeansParameter online_kmeans_param = 59;
inline bool LayerParameter::has_online_kmeans_param() const {
  return (_has_bits_[1] & 0x00000010u) != 0;
}
inline void LayerParameter::set_has_online_kmeans_param() {
  _has_bits_[1] |= 0x00000010u;
}
inline void LayerParameter::clear_has_online_kmeans_param() {
  _has_bits_[1] &= ~0x00000010u;
}
inline void LayerParameter::clear_online_kmeans_param() {
  if (online_kmeans_param_ != NULL) online_kmeans_param_->::caffepro::OnlineKMeansParameter::Clear();
  clear_has_online_kmeans_param();
}
inline const ::caffepro::OnlineKMeansParameter& LayerParameter::online_kmeans_param() const {
  return online_kmeans_param_ != NULL ? *online_kmeans_param_ : *default_instance_->online_kmeans_param_;
}
inline ::caffepro::OnlineKMeansParameter* LayerParameter::mutable_online_kmeans_param() {
  set_has_online_kmeans_param();
  if (online_kmeans_param_ == NULL) online_kmeans_param_ = new ::caffepro::OnlineKMeansParameter;
  return online_kmeans_param_;
}
inline ::caffepro::OnlineKMeansParameter* LayerParameter::release_online_kmeans_param() {
  clear_has_online_kmeans_param();
  ::caffepro::OnlineKMeansParameter* temp = online_kmeans_param_;
  online_kmeans_param_ = NULL;
  return temp;
}

// optional .caffepro.CorrelationParameter correlation_param = 60;
inline bool LayerParameter::has_correlation_param() const {
  return (_has_bits_[1] & 0x00000020u) != 0;
}
inline void LayerParameter::set_has_correlation_param() {
  _has_bits_[1] |= 0x00000020u;
}
inline void LayerParameter::clear_has_correlation_param() {
  _has_bits_[1] &= ~0x00000020u;
}
inline void LayerParameter::clear_correlation_param() {
  if (correlation_param_ != NULL) correlation_param_->::caffepro::CorrelationParameter::Clear();
  clear_has_correlation_param();
}
inline const ::caffepro::CorrelationParameter& LayerParameter::correlation_param() const {
  return correlation_param_ != NULL ? *correlation_param_ : *default_instance_->correlation_param_;
}
inline ::caffepro::CorrelationParameter* LayerParameter::mutable_correlation_param() {
  set_has_correlation_param();
  if (correlation_param_ == NULL) correlation_param_ = new ::caffepro::CorrelationParameter;
  return correlation_param_;
}
inline ::caffepro::CorrelationParameter* LayerParameter::release_correlation_param() {
  clear_has_correlation_param();
  ::caffepro::CorrelationParameter* temp = correlation_param_;
  correlation_param_ = NULL;
  return temp;
}

// optional .caffepro.WeightParameter weight_param = 61;
inline bool LayerParameter::has_weight_param() const {
  return (_has_bits_[1] & 0x00000040u) != 0;
}
inline void LayerParameter::set_has_weight_param() {
  _has_bits_[1] |= 0x00000040u;
}
inline void LayerParameter::clear_has_weight_param() {
  _has_bits_[1] &= ~0x00000040u;
}
inline void LayerParameter::clear_weight_param() {
  if (weight_param_ != NULL) weight_param_->::caffepro::WeightParameter::Clear();
  clear_has_weight_param();
}
inline const ::caffepro::WeightParameter& LayerParameter::weight_param() const {
  return weight_param_ != NULL ? *weight_param_ : *default_instance_->weight_param_;
}
inline ::caffepro::WeightParameter* LayerParameter::mutable_weight_param() {
  set_has_weight_param();
  if (weight_param_ == NULL) weight_param_ = new ::caffepro::WeightParameter;
  return weight_param_;
}
inline ::caffepro::WeightParameter* LayerParameter::release_weight_param() {
  clear_has_weight_param();
  ::caffepro::WeightParameter* temp = weight_param_;
  weight_param_ = NULL;
  return temp;
}

// optional .caffepro.ScaleBiasParameter scalebias_param = 62;
inline bool LayerParameter::has_scalebias_param() const {
  return (_has_bits_[1] & 0x00000080u) != 0;
}
inline void LayerParameter::set_has_scalebias_param() {
  _has_bits_[1] |= 0x00000080u;
}
inline void LayerParameter::clear_has_scalebias_param() {
  _has_bits_[1] &= ~0x00000080u;
}
inline void LayerParameter::clear_scalebias_param() {
  if (scalebias_param_ != NULL) scalebias_param_->::caffepro::ScaleBiasParameter::Clear();
  clear_has_scalebias_param();
}
inline const ::caffepro::ScaleBiasParameter& LayerParameter::scalebias_param() const {
  return scalebias_param_ != NULL ? *scalebias_param_ : *default_instance_->scalebias_param_;
}
inline ::caffepro::ScaleBiasParameter* LayerParameter::mutable_scalebias_param() {
  set_has_scalebias_param();
  if (scalebias_param_ == NULL) scalebias_param_ = new ::caffepro::ScaleBiasParameter;
  return scalebias_param_;
}
inline ::caffepro::ScaleBiasParameter* LayerParameter::release_scalebias_param() {
  clear_has_scalebias_param();
  ::caffepro::ScaleBiasParameter* temp = scalebias_param_;
  scalebias_param_ = NULL;
  return temp;
}

// optional .caffepro.CropParameter crop_param = 63;
inline bool LayerParameter::has_crop_param() const {
  return (_has_bits_[1] & 0x00000100u) != 0;
}
inline void LayerParameter::set_has_crop_param() {
  _has_bits_[1] |= 0x00000100u;
}
inline void LayerParameter::clear_has_crop_param() {
  _has_bits_[1] &= ~0x00000100u;
}
inline void LayerParameter::clear_crop_param() {
  if (crop_param_ != NULL) crop_param_->::caffepro::CropParameter::Clear();
  clear_has_crop_param();
}
inline const ::caffepro::CropParameter& LayerParameter::crop_param() const {
  return crop_param_ != NULL ? *crop_param_ : *default_instance_->crop_param_;
}
inline ::caffepro::CropParameter* LayerParameter::mutable_crop_param() {
  set_has_crop_param();
  if (crop_param_ == NULL) crop_param_ = new ::caffepro::CropParameter;
  return crop_param_;
}
inline ::caffepro::CropParameter* LayerParameter::release_crop_param() {
  clear_has_crop_param();
  ::caffepro::CropParameter* temp = crop_param_;
  crop_param_ = NULL;
  return temp;
}

// optional .caffepro.ReduceDimParameter reduce_dim_param = 64;
inline bool LayerParameter::has_reduce_dim_param() const {
  return (_has_bits_[1] & 0x00000200u) != 0;
}
inline void LayerParameter::set_has_reduce_dim_param() {
  _has_bits_[1] |= 0x00000200u;
}
inline void LayerParameter::clear_has_reduce_dim_param() {
  _has_bits_[1] &= ~0x00000200u;
}
inline void LayerParameter::clear_reduce_dim_param() {
  if (reduce_dim_param_ != NULL) reduce_dim_param_->::caffepro::ReduceDimParameter::Clear();
  clear_has_reduce_dim_param();
}
inline const ::caffepro::ReduceDimParameter& LayerParameter::reduce_dim_param() const {
  return reduce_dim_param_ != NULL ? *reduce_dim_param_ : *default_instance_->reduce_dim_param_;
}
inline ::caffepro::ReduceDimParameter* LayerParameter::mutable_reduce_dim_param() {
  set_has_reduce_dim_param();
  if (reduce_dim_param_ == NULL) reduce_dim_param_ = new ::caffepro::ReduceDimParameter;
  return reduce_dim_param_;
}
inline ::caffepro::ReduceDimParameter* LayerParameter::release_reduce_dim_param() {
  clear_has_reduce_dim_param();
  ::caffepro::ReduceDimParameter* temp = reduce_dim_param_;
  reduce_dim_param_ = NULL;
  return temp;
}

// optional .caffepro.FlipParameter flip_param = 65;
inline bool LayerParameter::has_flip_param() const {
  return (_has_bits_[1] & 0x00000400u) != 0;
}
inline void LayerParameter::set_has_flip_param() {
  _has_bits_[1] |= 0x00000400u;
}
inline void LayerParameter::clear_has_flip_param() {
  _has_bits_[1] &= ~0x00000400u;
}
inline void LayerParameter::clear_flip_param() {
  if (flip_param_ != NULL) flip_param_->::caffepro::FlipParameter::Clear();
  clear_has_flip_param();
}
inline const ::caffepro::FlipParameter& LayerParameter::flip_param() const {
  return flip_param_ != NULL ? *flip_param_ : *default_instance_->flip_param_;
}
inline ::caffepro::FlipParameter* LayerParameter::mutable_flip_param() {
  set_has_flip_param();
  if (flip_param_ == NULL) flip_param_ = new ::caffepro::FlipParameter;
  return flip_param_;
}
inline ::caffepro::FlipParameter* LayerParameter::release_flip_param() {
  clear_has_flip_param();
  ::caffepro::FlipParameter* temp = flip_param_;
  flip_param_ = NULL;
  return temp;
}

// optional .caffepro.StepGateParameter step_gate_param = 66;
inline bool LayerParameter::has_step_gate_param() const {
  return (_has_bits_[1] & 0x00000800u) != 0;
}
inline void LayerParameter::set_has_step_gate_param() {
  _has_bits_[1] |= 0x00000800u;
}
inline void LayerParameter::clear_has_step_gate_param() {
  _has_bits_[1] &= ~0x00000800u;
}
inline void LayerParameter::clear_step_gate_param() {
  if (step_gate_param_ != NULL) step_gate_param_->::caffepro::StepGateParameter::Clear();
  clear_has_step_gate_param();
}
inline const ::caffepro::StepGateParameter& LayerParameter::step_gate_param() const {
  return step_gate_param_ != NULL ? *step_gate_param_ : *default_instance_->step_gate_param_;
}
inline ::caffepro::StepGateParameter* LayerParameter::mutable_step_gate_param() {
  set_has_step_gate_param();
  if (step_gate_param_ == NULL) step_gate_param_ = new ::caffepro::StepGateParameter;
  return step_gate_param_;
}
inline ::caffepro::StepGateParameter* LayerParameter::release_step_gate_param() {
  clear_has_step_gate_param();
  ::caffepro::StepGateParameter* temp = step_gate_param_;
  step_gate_param_ = NULL;
  return temp;
}

// optional .caffepro.HouseholderParameter householder_param = 67;
inline bool LayerParameter::has_householder_param() const {
  return (_has_bits_[1] & 0x00001000u) != 0;
}
inline void LayerParameter::set_has_householder_param() {
  _has_bits_[1] |= 0x00001000u;
}
inline void LayerParameter::clear_has_householder_param() {
  _has_bits_[1] &= ~0x00001000u;
}
inline void LayerParameter::clear_householder_param() {
  if (householder_param_ != NULL) householder_param_->::caffepro::HouseholderParameter::Clear();
  clear_has_householder_param();
}
inline const ::caffepro::HouseholderParameter& LayerParameter::householder_param() const {
  return householder_param_ != NULL ? *householder_param_ : *default_instance_->householder_param_;
}
inline ::caffepro::HouseholderParameter* LayerParameter::mutable_householder_param() {
  set_has_householder_param();
  if (householder_param_ == NULL) householder_param_ = new ::caffepro::HouseholderParameter;
  return householder_param_;
}
inline ::caffepro::HouseholderParameter* LayerParameter::release_householder_param() {
  clear_has_householder_param();
  ::caffepro::HouseholderParameter* temp = householder_param_;
  householder_param_ = NULL;
  return temp;
}

// optional .caffepro.InstanceSampleParameter instance_sample_param = 68;
inline bool LayerParameter::has_instance_sample_param() const {
  return (_has_bits_[1] & 0x00002000u) != 0;
}
inline void LayerParameter::set_has_instance_sample_param() {
  _has_bits_[1] |= 0x00002000u;
}
inline void LayerParameter::clear_has_instance_sample_param() {
  _has_bits_[1] &= ~0x00002000u;
}
inline void LayerParameter::clear_instance_sample_param() {
  if (instance_sample_param_ != NULL) instance_sample_param_->::caffepro::InstanceSampleParameter::Clear();
  clear_has_instance_sample_param();
}
inline const ::caffepro::InstanceSampleParameter& LayerParameter::instance_sample_param() const {
  return instance_sample_param_ != NULL ? *instance_sample_param_ : *default_instance_->instance_sample_param_;
}
inline ::caffepro::InstanceSampleParameter* LayerParameter::mutable_instance_sample_param() {
  set_has_instance_sample_param();
  if (instance_sample_param_ == NULL) instance_sample_param_ = new ::caffepro::InstanceSampleParameter;
  return instance_sample_param_;
}
inline ::caffepro::InstanceSampleParameter* LayerParameter::release_instance_sample_param() {
  clear_has_instance_sample_param();
  ::caffepro::InstanceSampleParameter* temp = instance_sample_param_;
  instance_sample_param_ = NULL;
  return temp;
}

// optional .caffepro.MatrixMulParameter matrix_mul_param = 69;
inline bool LayerParameter::has_matrix_mul_param() const {
  return (_has_bits_[1] & 0x00004000u) != 0;
}
inline void LayerParameter::set_has_matrix_mul_param() {
  _has_bits_[1] |= 0x00004000u;
}
inline void LayerParameter::clear_has_matrix_mul_param() {
  _has_bits_[1] &= ~0x00004000u;
}
inline void LayerParameter::clear_matrix_mul_param() {
  if (matrix_mul_param_ != NULL) matrix_mul_param_->::caffepro::MatrixMulParameter::Clear();
  clear_has_matrix_mul_param();
}
inline const ::caffepro::MatrixMulParameter& LayerParameter::matrix_mul_param() const {
  return matrix_mul_param_ != NULL ? *matrix_mul_param_ : *default_instance_->matrix_mul_param_;
}
inline ::caffepro::MatrixMulParameter* LayerParameter::mutable_matrix_mul_param() {
  set_has_matrix_mul_param();
  if (matrix_mul_param_ == NULL) matrix_mul_param_ = new ::caffepro::MatrixMulParameter;
  return matrix_mul_param_;
}
inline ::caffepro::MatrixMulParameter* LayerParameter::release_matrix_mul_param() {
  clear_has_matrix_mul_param();
  ::caffepro::MatrixMulParameter* temp = matrix_mul_param_;
  matrix_mul_param_ = NULL;
  return temp;
}

// optional .caffepro.MatrixMulStackParameter matrix_mul_stack_param = 70;
inline bool LayerParameter::has_matrix_mul_stack_param() const {
  return (_has_bits_[1] & 0x00008000u) != 0;
}
inline void LayerParameter::set_has_matrix_mul_stack_param() {
  _has_bits_[1] |= 0x00008000u;
}
inline void LayerParameter::clear_has_matrix_mul_stack_param() {
  _has_bits_[1] &= ~0x00008000u;
}
inline void LayerParameter::clear_matrix_mul_stack_param() {
  if (matrix_mul_stack_param_ != NULL) matrix_mul_stack_param_->::caffepro::MatrixMulStackParameter::Clear();
  clear_has_matrix_mul_stack_param();
}
inline const ::caffepro::MatrixMulStackParameter& LayerParameter::matrix_mul_stack_param() const {
  return matrix_mul_stack_param_ != NULL ? *matrix_mul_stack_param_ : *default_instance_->matrix_mul_stack_param_;
}
inline ::caffepro::MatrixMulStackParameter* LayerParameter::mutable_matrix_mul_stack_param() {
  set_has_matrix_mul_stack_param();
  if (matrix_mul_stack_param_ == NULL) matrix_mul_stack_param_ = new ::caffepro::MatrixMulStackParameter;
  return matrix_mul_stack_param_;
}
inline ::caffepro::MatrixMulStackParameter* LayerParameter::release_matrix_mul_stack_param() {
  clear_has_matrix_mul_stack_param();
  ::caffepro::MatrixMulStackParameter* temp = matrix_mul_stack_param_;
  matrix_mul_stack_param_ = NULL;
  return temp;
}

// optional .caffepro.TransposeParameter transpose_param = 71;
inline bool LayerParameter::has_transpose_param() const {
  return (_has_bits_[1] & 0x00010000u) != 0;
}
inline void LayerParameter::set_has_transpose_param() {
  _has_bits_[1] |= 0x00010000u;
}
inline void LayerParameter::clear_has_transpose_param() {
  _has_bits_[1] &= ~0x00010000u;
}
inline void LayerParameter::clear_transpose_param() {
  if (transpose_param_ != NULL) transpose_param_->::caffepro::TransposeParameter::Clear();
  clear_has_transpose_param();
}
inline const ::caffepro::TransposeParameter& LayerParameter::transpose_param() const {
  return transpose_param_ != NULL ? *transpose_param_ : *default_instance_->transpose_param_;
}
inline ::caffepro::TransposeParameter* LayerParameter::mutable_transpose_param() {
  set_has_transpose_param();
  if (transpose_param_ == NULL) transpose_param_ = new ::caffepro::TransposeParameter;
  return transpose_param_;
}
inline ::caffepro::TransposeParameter* LayerParameter::release_transpose_param() {
  clear_has_transpose_param();
  ::caffepro::TransposeParameter* temp = transpose_param_;
  transpose_param_ = NULL;
  return temp;
}

// optional .caffepro.ReshapeParameter reshape_param = 72;
inline bool LayerParameter::has_reshape_param() const {
  return (_has_bits_[1] & 0x00020000u) != 0;
}
inline void LayerParameter::set_has_reshape_param() {
  _has_bits_[1] |= 0x00020000u;
}
inline void LayerParameter::clear_has_reshape_param() {
  _has_bits_[1] &= ~0x00020000u;
}
inline void LayerParameter::clear_reshape_param() {
  if (reshape_param_ != NULL) reshape_param_->::caffepro::ReshapeParameter::Clear();
  clear_has_reshape_param();
}
inline const ::caffepro::ReshapeParameter& LayerParameter::reshape_param() const {
  return reshape_param_ != NULL ? *reshape_param_ : *default_instance_->reshape_param_;
}
inline ::caffepro::ReshapeParameter* LayerParameter::mutable_reshape_param() {
  set_has_reshape_param();
  if (reshape_param_ == NULL) reshape_param_ = new ::caffepro::ReshapeParameter;
  return reshape_param_;
}
inline ::caffepro::ReshapeParameter* LayerParameter::release_reshape_param() {
  clear_has_reshape_param();
  ::caffepro::ReshapeParameter* temp = reshape_param_;
  reshape_param_ = NULL;
  return temp;
}

// optional .caffepro.LearnableDropoutParameter learnable_dropout_param = 73;
inline bool LayerParameter::has_learnable_dropout_param() const {
  return (_has_bits_[1] & 0x00040000u) != 0;
}
inline void LayerParameter::set_has_learnable_dropout_param() {
  _has_bits_[1] |= 0x00040000u;
}
inline void LayerParameter::clear_has_learnable_dropout_param() {
  _has_bits_[1] &= ~0x00040000u;
}
inline void LayerParameter::clear_learnable_dropout_param() {
  if (learnable_dropout_param_ != NULL) learnable_dropout_param_->::caffepro::LearnableDropoutParameter::Clear();
  clear_has_learnable_dropout_param();
}
inline const ::caffepro::LearnableDropoutParameter& LayerParameter::learnable_dropout_param() const {
  return learnable_dropout_param_ != NULL ? *learnable_dropout_param_ : *default_instance_->learnable_dropout_param_;
}
inline ::caffepro::LearnableDropoutParameter* LayerParameter::mutable_learnable_dropout_param() {
  set_has_learnable_dropout_param();
  if (learnable_dropout_param_ == NULL) learnable_dropout_param_ = new ::caffepro::LearnableDropoutParameter;
  return learnable_dropout_param_;
}
inline ::caffepro::LearnableDropoutParameter* LayerParameter::release_learnable_dropout_param() {
  clear_has_learnable_dropout_param();
  ::caffepro::LearnableDropoutParameter* temp = learnable_dropout_param_;
  learnable_dropout_param_ = NULL;
  return temp;
}

// optional .caffepro.DimInnerProductParameter dim_innerproduct_param = 74;
inline bool LayerParameter::has_dim_innerproduct_param() const {
  return (_has_bits_[1] & 0x00080000u) != 0;
}
inline void LayerParameter::set_has_dim_innerproduct_param() {
  _has_bits_[1] |= 0x00080000u;
}
inline void LayerParameter::clear_has_dim_innerproduct_param() {
  _has_bits_[1] &= ~0x00080000u;
}
inline void LayerParameter::clear_dim_innerproduct_param() {
  if (dim_innerproduct_param_ != NULL) dim_innerproduct_param_->::caffepro::DimInnerProductParameter::Clear();
  clear_has_dim_innerproduct_param();
}
inline const ::caffepro::DimInnerProductParameter& LayerParameter::dim_innerproduct_param() const {
  return dim_innerproduct_param_ != NULL ? *dim_innerproduct_param_ : *default_instance_->dim_innerproduct_param_;
}
inline ::caffepro::DimInnerProductParameter* LayerParameter::mutable_dim_innerproduct_param() {
  set_has_dim_innerproduct_param();
  if (dim_innerproduct_param_ == NULL) dim_innerproduct_param_ = new ::caffepro::DimInnerProductParameter;
  return dim_innerproduct_param_;
}
inline ::caffepro::DimInnerProductParameter* LayerParameter::release_dim_innerproduct_param() {
  clear_has_dim_innerproduct_param();
  ::caffepro::DimInnerProductParameter* temp = dim_innerproduct_param_;
  dim_innerproduct_param_ = NULL;
  return temp;
}

// optional .caffepro.SoftthrParameter softthr_param = 75;
inline bool LayerParameter::has_softthr_param() const {
  return (_has_bits_[1] & 0x00100000u) != 0;
}
inline void LayerParameter::set_has_softthr_param() {
  _has_bits_[1] |= 0x00100000u;
}
inline void LayerParameter::clear_has_softthr_param() {
  _has_bits_[1] &= ~0x00100000u;
}
inline void LayerParameter::clear_softthr_param() {
  if (softthr_param_ != NULL) softthr_param_->::caffepro::SoftthrParameter::Clear();
  clear_has_softthr_param();
}
inline const ::caffepro::SoftthrParameter& LayerParameter::softthr_param() const {
  return softthr_param_ != NULL ? *softthr_param_ : *default_instance_->softthr_param_;
}
inline ::caffepro::SoftthrParameter* LayerParameter::mutable_softthr_param() {
  set_has_softthr_param();
  if (softthr_param_ == NULL) softthr_param_ = new ::caffepro::SoftthrParameter;
  return softthr_param_;
}
inline ::caffepro::SoftthrParameter* LayerParameter::release_softthr_param() {
  clear_has_softthr_param();
  ::caffepro::SoftthrParameter* temp = softthr_param_;
  softthr_param_ = NULL;
  return temp;
}

// optional .caffepro.DropoutParameter dropoutsame_param = 76;
inline bool LayerParameter::has_dropoutsame_param() const {
  return (_has_bits_[1] & 0x00200000u) != 0;
}
inline void LayerParameter::set_has_dropoutsame_param() {
  _has_bits_[1] |= 0x00200000u;
}
inline void LayerParameter::clear_has_dropoutsame_param() {
  _has_bits_[1] &= ~0x00200000u;
}
inline void LayerParameter::clear_dropoutsame_param() {
  if (dropoutsame_param_ != NULL) dropoutsame_param_->::caffepro::DropoutParameter::Clear();
  clear_has_dropoutsame_param();
}
inline const ::caffepro::DropoutParameter& LayerParameter::dropoutsame_param() const {
  return dropoutsame_param_ != NULL ? *dropoutsame_param_ : *default_instance_->dropoutsame_param_;
}
inline ::caffepro::DropoutParameter* LayerParameter::mutable_dropoutsame_param() {
  set_has_dropoutsame_param();
  if (dropoutsame_param_ == NULL) dropoutsame_param_ = new ::caffepro::DropoutParameter;
  return dropoutsame_param_;
}
inline ::caffepro::DropoutParameter* LayerParameter::release_dropoutsame_param() {
  clear_has_dropoutsame_param();
  ::caffepro::DropoutParameter* temp = dropoutsame_param_;
  dropoutsame_param_ = NULL;
  return temp;
}

// optional .caffepro.SoftMaxLossOHEMParameter softmaxlossohem_param = 77;
inline bool LayerParameter::has_softmaxlossohem_param() const {
  return (_has_bits_[1] & 0x00400000u) != 0;
}
inline void LayerParameter::set_has_softmaxlossohem_param() {
  _has_bits_[1] |= 0x00400000u;
}
inline void LayerParameter::clear_has_softmaxlossohem_param() {
  _has_bits_[1] &= ~0x00400000u;
}
inline void LayerParameter::clear_softmaxlossohem_param() {
  if (softmaxlossohem_param_ != NULL) softmaxlossohem_param_->::caffepro::SoftMaxLossOHEMParameter::Clear();
  clear_has_softmaxlossohem_param();
}
inline const ::caffepro::SoftMaxLossOHEMParameter& LayerParameter::softmaxlossohem_param() const {
  return softmaxlossohem_param_ != NULL ? *softmaxlossohem_param_ : *default_instance_->softmaxlossohem_param_;
}
inline ::caffepro::SoftMaxLossOHEMParameter* LayerParameter::mutable_softmaxlossohem_param() {
  set_has_softmaxlossohem_param();
  if (softmaxlossohem_param_ == NULL) softmaxlossohem_param_ = new ::caffepro::SoftMaxLossOHEMParameter;
  return softmaxlossohem_param_;
}
inline ::caffepro::SoftMaxLossOHEMParameter* LayerParameter::release_softmaxlossohem_param() {
  clear_has_softmaxlossohem_param();
  ::caffepro::SoftMaxLossOHEMParameter* temp = softmaxlossohem_param_;
  softmaxlossohem_param_ = NULL;
  return temp;
}

// optional .caffepro.SoftMaxOHEMParameter softmaxohem_param = 78;
inline bool LayerParameter::has_softmaxohem_param() const {
  return (_has_bits_[1] & 0x00800000u) != 0;
}
inline void LayerParameter::set_has_softmaxohem_param() {
  _has_bits_[1] |= 0x00800000u;
}
inline void LayerParameter::clear_has_softmaxohem_param() {
  _has_bits_[1] &= ~0x00800000u;
}
inline void LayerParameter::clear_softmaxohem_param() {
  if (softmaxohem_param_ != NULL) softmaxohem_param_->::caffepro::SoftMaxOHEMParameter::Clear();
  clear_has_softmaxohem_param();
}
inline const ::caffepro::SoftMaxOHEMParameter& LayerParameter::softmaxohem_param() const {
  return softmaxohem_param_ != NULL ? *softmaxohem_param_ : *default_instance_->softmaxohem_param_;
}
inline ::caffepro::SoftMaxOHEMParameter* LayerParameter::mutable_softmaxohem_param() {
  set_has_softmaxohem_param();
  if (softmaxohem_param_ == NULL) softmaxohem_param_ = new ::caffepro::SoftMaxOHEMParameter;
  return softmaxohem_param_;
}
inline ::caffepro::SoftMaxOHEMParameter* LayerParameter::release_softmaxohem_param() {
  clear_has_softmaxohem_param();
  ::caffepro::SoftMaxOHEMParameter* temp = softmaxohem_param_;
  softmaxohem_param_ = NULL;
  return temp;
}

// optional .caffepro.SoftMaxOHEMSplitParameter softmaxohemsplit_param = 79;
inline bool LayerParameter::has_softmaxohemsplit_param() const {
  return (_has_bits_[1] & 0x01000000u) != 0;
}
inline void LayerParameter::set_has_softmaxohemsplit_param() {
  _has_bits_[1] |= 0x01000000u;
}
inline void LayerParameter::clear_has_softmaxohemsplit_param() {
  _has_bits_[1] &= ~0x01000000u;
}
inline void LayerParameter::clear_softmaxohemsplit_param() {
  if (softmaxohemsplit_param_ != NULL) softmaxohemsplit_param_->::caffepro::SoftMaxOHEMSplitParameter::Clear();
  clear_has_softmaxohemsplit_param();
}
inline const ::caffepro::SoftMaxOHEMSplitParameter& LayerParameter::softmaxohemsplit_param() const {
  return softmaxohemsplit_param_ != NULL ? *softmaxohemsplit_param_ : *default_instance_->softmaxohemsplit_param_;
}
inline ::caffepro::SoftMaxOHEMSplitParameter* LayerParameter::mutable_softmaxohemsplit_param() {
  set_has_softmaxohemsplit_param();
  if (softmaxohemsplit_param_ == NULL) softmaxohemsplit_param_ = new ::caffepro::SoftMaxOHEMSplitParameter;
  return softmaxohemsplit_param_;
}
inline ::caffepro::SoftMaxOHEMSplitParameter* LayerParameter::release_softmaxohemsplit_param() {
  clear_has_softmaxohemsplit_param();
  ::caffepro::SoftMaxOHEMSplitParameter* temp = softmaxohemsplit_param_;
  softmaxohemsplit_param_ = NULL;
  return temp;
}

// optional .caffepro.DiagOperationParameter diag_operation_param = 80;
inline bool LayerParameter::has_diag_operation_param() const {
  return (_has_bits_[1] & 0x02000000u) != 0;
}
inline void LayerParameter::set_has_diag_operation_param() {
  _has_bits_[1] |= 0x02000000u;
}
inline void LayerParameter::clear_has_diag_operation_param() {
  _has_bits_[1] &= ~0x02000000u;
}
inline void LayerParameter::clear_diag_operation_param() {
  if (diag_operation_param_ != NULL) diag_operation_param_->::caffepro::DiagOperationParameter::Clear();
  clear_has_diag_operation_param();
}
inline const ::caffepro::DiagOperationParameter& LayerParameter::diag_operation_param() const {
  return diag_operation_param_ != NULL ? *diag_operation_param_ : *default_instance_->diag_operation_param_;
}
inline ::caffepro::DiagOperationParameter* LayerParameter::mutable_diag_operation_param() {
  set_has_diag_operation_param();
  if (diag_operation_param_ == NULL) diag_operation_param_ = new ::caffepro::DiagOperationParameter;
  return diag_operation_param_;
}
inline ::caffepro::DiagOperationParameter* LayerParameter::release_diag_operation_param() {
  clear_has_diag_operation_param();
  ::caffepro::DiagOperationParameter* temp = diag_operation_param_;
  diag_operation_param_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// ClusterParameter

// required int32 num_centers = 1;
inline bool ClusterParameter::has_num_centers() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClusterParameter::set_has_num_centers() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClusterParameter::clear_has_num_centers() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClusterParameter::clear_num_centers() {
  num_centers_ = 0;
  clear_has_num_centers();
}
inline ::google::protobuf::int32 ClusterParameter::num_centers() const {
  return num_centers_;
}
inline void ClusterParameter::set_num_centers(::google::protobuf::int32 value) {
  set_has_num_centers();
  num_centers_ = value;
}

// optional .caffepro.FillerParameter weight_filler = 2;
inline bool ClusterParameter::has_weight_filler() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClusterParameter::set_has_weight_filler() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClusterParameter::clear_has_weight_filler() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClusterParameter::clear_weight_filler() {
  if (weight_filler_ != NULL) weight_filler_->::caffepro::FillerParameter::Clear();
  clear_has_weight_filler();
}
inline const ::caffepro::FillerParameter& ClusterParameter::weight_filler() const {
  return weight_filler_ != NULL ? *weight_filler_ : *default_instance_->weight_filler_;
}
inline ::caffepro::FillerParameter* ClusterParameter::mutable_weight_filler() {
  set_has_weight_filler();
  if (weight_filler_ == NULL) weight_filler_ = new ::caffepro::FillerParameter;
  return weight_filler_;
}
inline ::caffepro::FillerParameter* ClusterParameter::release_weight_filler() {
  clear_has_weight_filler();
  ::caffepro::FillerParameter* temp = weight_filler_;
  weight_filler_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// OnlineKMeansParameter

// required int32 update_interval = 1;
inline bool OnlineKMeansParameter::has_update_interval() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OnlineKMeansParameter::set_has_update_interval() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OnlineKMeansParameter::clear_has_update_interval() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OnlineKMeansParameter::clear_update_interval() {
  update_interval_ = 0;
  clear_has_update_interval();
}
inline ::google::protobuf::int32 OnlineKMeansParameter::update_interval() const {
  return update_interval_;
}
inline void OnlineKMeansParameter::set_update_interval(::google::protobuf::int32 value) {
  set_has_update_interval();
  update_interval_ = value;
}

// required int32 update_iters = 2;
inline bool OnlineKMeansParameter::has_update_iters() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OnlineKMeansParameter::set_has_update_iters() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OnlineKMeansParameter::clear_has_update_iters() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OnlineKMeansParameter::clear_update_iters() {
  update_iters_ = 0;
  clear_has_update_iters();
}
inline ::google::protobuf::int32 OnlineKMeansParameter::update_iters() const {
  return update_iters_;
}
inline void OnlineKMeansParameter::set_update_iters(::google::protobuf::int32 value) {
  set_has_update_iters();
  update_iters_ = value;
}

// -------------------------------------------------------------------

// EltwiseSumParameter

// repeated float coeff = 1;
inline int EltwiseSumParameter::coeff_size() const {
  return coeff_.size();
}
inline void EltwiseSumParameter::clear_coeff() {
  coeff_.Clear();
}
inline float EltwiseSumParameter::coeff(int index) const {
  return coeff_.Get(index);
}
inline void EltwiseSumParameter::set_coeff(int index, float value) {
  coeff_.Set(index, value);
}
inline void EltwiseSumParameter::add_coeff(float value) {
  coeff_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
EltwiseSumParameter::coeff() const {
  return coeff_;
}
inline ::google::protobuf::RepeatedField< float >*
EltwiseSumParameter::mutable_coeff() {
  return &coeff_;
}

// -------------------------------------------------------------------

// ReluParameter

// optional float relu_leak = 1 [default = 0];
inline bool ReluParameter::has_relu_leak() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReluParameter::set_has_relu_leak() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReluParameter::clear_has_relu_leak() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReluParameter::clear_relu_leak() {
  relu_leak_ = 0;
  clear_has_relu_leak();
}
inline float ReluParameter::relu_leak() const {
  return relu_leak_;
}
inline void ReluParameter::set_relu_leak(float value) {
  set_has_relu_leak();
  relu_leak_ = value;
}

// -------------------------------------------------------------------

// LearnableLeakReluParameter

// required .caffepro.FillerParameter relu_leak_param = 1;
inline bool LearnableLeakReluParameter::has_relu_leak_param() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LearnableLeakReluParameter::set_has_relu_leak_param() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LearnableLeakReluParameter::clear_has_relu_leak_param() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LearnableLeakReluParameter::clear_relu_leak_param() {
  if (relu_leak_param_ != NULL) relu_leak_param_->::caffepro::FillerParameter::Clear();
  clear_has_relu_leak_param();
}
inline const ::caffepro::FillerParameter& LearnableLeakReluParameter::relu_leak_param() const {
  return relu_leak_param_ != NULL ? *relu_leak_param_ : *default_instance_->relu_leak_param_;
}
inline ::caffepro::FillerParameter* LearnableLeakReluParameter::mutable_relu_leak_param() {
  set_has_relu_leak_param();
  if (relu_leak_param_ == NULL) relu_leak_param_ = new ::caffepro::FillerParameter;
  return relu_leak_param_;
}
inline ::caffepro::FillerParameter* LearnableLeakReluParameter::release_relu_leak_param() {
  clear_has_relu_leak_param();
  ::caffepro::FillerParameter* temp = relu_leak_param_;
  relu_leak_param_ = NULL;
  return temp;
}

// required .caffepro.LearnableLeakReluParameter.ShareParamMethod share_param = 2;
inline bool LearnableLeakReluParameter::has_share_param() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LearnableLeakReluParameter::set_has_share_param() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LearnableLeakReluParameter::clear_has_share_param() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LearnableLeakReluParameter::clear_share_param() {
  share_param_ = 0;
  clear_has_share_param();
}
inline ::caffepro::LearnableLeakReluParameter_ShareParamMethod LearnableLeakReluParameter::share_param() const {
  return static_cast< ::caffepro::LearnableLeakReluParameter_ShareParamMethod >(share_param_);
}
inline void LearnableLeakReluParameter::set_share_param(::caffepro::LearnableLeakReluParameter_ShareParamMethod value) {
  GOOGLE_DCHECK(::caffepro::LearnableLeakReluParameter_ShareParamMethod_IsValid(value));
  set_has_share_param();
  share_param_ = value;
}

// optional bool apply_bound = 3 [default = true];
inline bool LearnableLeakReluParameter::has_apply_bound() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LearnableLeakReluParameter::set_has_apply_bound() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LearnableLeakReluParameter::clear_has_apply_bound() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LearnableLeakReluParameter::clear_apply_bound() {
  apply_bound_ = true;
  clear_has_apply_bound();
}
inline bool LearnableLeakReluParameter::apply_bound() const {
  return apply_bound_;
}
inline void LearnableLeakReluParameter::set_apply_bound(bool value) {
  set_has_apply_bound();
  apply_bound_ = value;
}

// optional float bound_upper = 4 [default = 1];
inline bool LearnableLeakReluParameter::has_bound_upper() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LearnableLeakReluParameter::set_has_bound_upper() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LearnableLeakReluParameter::clear_has_bound_upper() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LearnableLeakReluParameter::clear_bound_upper() {
  bound_upper_ = 1;
  clear_has_bound_upper();
}
inline float LearnableLeakReluParameter::bound_upper() const {
  return bound_upper_;
}
inline void LearnableLeakReluParameter::set_bound_upper(float value) {
  set_has_bound_upper();
  bound_upper_ = value;
}

// optional float bound_lower = 5 [default = 0];
inline bool LearnableLeakReluParameter::has_bound_lower() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LearnableLeakReluParameter::set_has_bound_lower() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LearnableLeakReluParameter::clear_has_bound_lower() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LearnableLeakReluParameter::clear_bound_lower() {
  bound_lower_ = 0;
  clear_has_bound_lower();
}
inline float LearnableLeakReluParameter::bound_lower() const {
  return bound_lower_;
}
inline void LearnableLeakReluParameter::set_bound_lower(float value) {
  set_has_bound_lower();
  bound_lower_ = value;
}

// -------------------------------------------------------------------

// ExpParameter

// optional float slope = 1 [default = 1];
inline bool ExpParameter::has_slope() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ExpParameter::set_has_slope() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ExpParameter::clear_has_slope() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ExpParameter::clear_slope() {
  slope_ = 1;
  clear_has_slope();
}
inline float ExpParameter::slope() const {
  return slope_;
}
inline void ExpParameter::set_slope(float value) {
  set_has_slope();
  slope_ = value;
}

// -------------------------------------------------------------------

// BoundParameter

// required float max_value = 1;
inline bool BoundParameter::has_max_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BoundParameter::set_has_max_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BoundParameter::clear_has_max_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BoundParameter::clear_max_value() {
  max_value_ = 0;
  clear_has_max_value();
}
inline float BoundParameter::max_value() const {
  return max_value_;
}
inline void BoundParameter::set_max_value(float value) {
  set_has_max_value();
  max_value_ = value;
}

// required float min_value = 2;
inline bool BoundParameter::has_min_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BoundParameter::set_has_min_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BoundParameter::clear_has_min_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BoundParameter::clear_min_value() {
  min_value_ = 0;
  clear_has_min_value();
}
inline float BoundParameter::min_value() const {
  return min_value_;
}
inline void BoundParameter::set_min_value(float value) {
  set_has_min_value();
  min_value_ = value;
}

// -------------------------------------------------------------------

// BatchNormalizationParameter

// required .caffepro.FillerParameter scale_filler = 1;
inline bool BatchNormalizationParameter::has_scale_filler() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BatchNormalizationParameter::set_has_scale_filler() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BatchNormalizationParameter::clear_has_scale_filler() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BatchNormalizationParameter::clear_scale_filler() {
  if (scale_filler_ != NULL) scale_filler_->::caffepro::FillerParameter::Clear();
  clear_has_scale_filler();
}
inline const ::caffepro::FillerParameter& BatchNormalizationParameter::scale_filler() const {
  return scale_filler_ != NULL ? *scale_filler_ : *default_instance_->scale_filler_;
}
inline ::caffepro::FillerParameter* BatchNormalizationParameter::mutable_scale_filler() {
  set_has_scale_filler();
  if (scale_filler_ == NULL) scale_filler_ = new ::caffepro::FillerParameter;
  return scale_filler_;
}
inline ::caffepro::FillerParameter* BatchNormalizationParameter::release_scale_filler() {
  clear_has_scale_filler();
  ::caffepro::FillerParameter* temp = scale_filler_;
  scale_filler_ = NULL;
  return temp;
}

// required .caffepro.FillerParameter shift_filler = 2;
inline bool BatchNormalizationParameter::has_shift_filler() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BatchNormalizationParameter::set_has_shift_filler() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BatchNormalizationParameter::clear_has_shift_filler() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BatchNormalizationParameter::clear_shift_filler() {
  if (shift_filler_ != NULL) shift_filler_->::caffepro::FillerParameter::Clear();
  clear_has_shift_filler();
}
inline const ::caffepro::FillerParameter& BatchNormalizationParameter::shift_filler() const {
  return shift_filler_ != NULL ? *shift_filler_ : *default_instance_->shift_filler_;
}
inline ::caffepro::FillerParameter* BatchNormalizationParameter::mutable_shift_filler() {
  set_has_shift_filler();
  if (shift_filler_ == NULL) shift_filler_ = new ::caffepro::FillerParameter;
  return shift_filler_;
}
inline ::caffepro::FillerParameter* BatchNormalizationParameter::release_shift_filler() {
  clear_has_shift_filler();
  ::caffepro::FillerParameter* temp = shift_filler_;
  shift_filler_ = NULL;
  return temp;
}

// optional .caffepro.BatchNormalizationParameter.RecordOption record_option = 3 [default = NOT_RECORD];
inline bool BatchNormalizationParameter::has_record_option() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BatchNormalizationParameter::set_has_record_option() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BatchNormalizationParameter::clear_has_record_option() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BatchNormalizationParameter::clear_record_option() {
  record_option_ = 0;
  clear_has_record_option();
}
inline ::caffepro::BatchNormalizationParameter_RecordOption BatchNormalizationParameter::record_option() const {
  return static_cast< ::caffepro::BatchNormalizationParameter_RecordOption >(record_option_);
}
inline void BatchNormalizationParameter::set_record_option(::caffepro::BatchNormalizationParameter_RecordOption value) {
  GOOGLE_DCHECK(::caffepro::BatchNormalizationParameter_RecordOption_IsValid(value));
  set_has_record_option();
  record_option_ = value;
}

// optional float sliding_window_eval_coeff = 4 [default = -1];
inline bool BatchNormalizationParameter::has_sliding_window_eval_coeff() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BatchNormalizationParameter::set_has_sliding_window_eval_coeff() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BatchNormalizationParameter::clear_has_sliding_window_eval_coeff() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BatchNormalizationParameter::clear_sliding_window_eval_coeff() {
  sliding_window_eval_coeff_ = -1;
  clear_has_sliding_window_eval_coeff();
}
inline float BatchNormalizationParameter::sliding_window_eval_coeff() const {
  return sliding_window_eval_coeff_;
}
inline void BatchNormalizationParameter::set_sliding_window_eval_coeff(float value) {
  set_has_sliding_window_eval_coeff();
  sliding_window_eval_coeff_ = value;
}

// optional bool keep_mean = 5 [default = false];
inline bool BatchNormalizationParameter::has_keep_mean() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BatchNormalizationParameter::set_has_keep_mean() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BatchNormalizationParameter::clear_has_keep_mean() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BatchNormalizationParameter::clear_keep_mean() {
  keep_mean_ = false;
  clear_has_keep_mean();
}
inline bool BatchNormalizationParameter::keep_mean() const {
  return keep_mean_;
}
inline void BatchNormalizationParameter::set_keep_mean(bool value) {
  set_has_keep_mean();
  keep_mean_ = value;
}

// -------------------------------------------------------------------

// GPUSplitParameter

// repeated int32 split_minibatch = 1;
inline int GPUSplitParameter::split_minibatch_size() const {
  return split_minibatch_.size();
}
inline void GPUSplitParameter::clear_split_minibatch() {
  split_minibatch_.Clear();
}
inline ::google::protobuf::int32 GPUSplitParameter::split_minibatch(int index) const {
  return split_minibatch_.Get(index);
}
inline void GPUSplitParameter::set_split_minibatch(int index, ::google::protobuf::int32 value) {
  split_minibatch_.Set(index, value);
}
inline void GPUSplitParameter::add_split_minibatch(::google::protobuf::int32 value) {
  split_minibatch_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
GPUSplitParameter::split_minibatch() const {
  return split_minibatch_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
GPUSplitParameter::mutable_split_minibatch() {
  return &split_minibatch_;
}

// repeated int32 split_gpu_id = 2;
inline int GPUSplitParameter::split_gpu_id_size() const {
  return split_gpu_id_.size();
}
inline void GPUSplitParameter::clear_split_gpu_id() {
  split_gpu_id_.Clear();
}
inline ::google::protobuf::int32 GPUSplitParameter::split_gpu_id(int index) const {
  return split_gpu_id_.Get(index);
}
inline void GPUSplitParameter::set_split_gpu_id(int index, ::google::protobuf::int32 value) {
  split_gpu_id_.Set(index, value);
}
inline void GPUSplitParameter::add_split_gpu_id(::google::protobuf::int32 value) {
  split_gpu_id_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
GPUSplitParameter::split_gpu_id() const {
  return split_gpu_id_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
GPUSplitParameter::mutable_split_gpu_id() {
  return &split_gpu_id_;
}

// -------------------------------------------------------------------

// ConcatParameter

// optional uint32 concat_dim = 1 [default = 1];
inline bool ConcatParameter::has_concat_dim() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ConcatParameter::set_has_concat_dim() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ConcatParameter::clear_has_concat_dim() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ConcatParameter::clear_concat_dim() {
  concat_dim_ = 1u;
  clear_has_concat_dim();
}
inline ::google::protobuf::uint32 ConcatParameter::concat_dim() const {
  return concat_dim_;
}
inline void ConcatParameter::set_concat_dim(::google::protobuf::uint32 value) {
  set_has_concat_dim();
  concat_dim_ = value;
}

// -------------------------------------------------------------------

// GridGeneratorParameter

// required string method = 1;
inline bool GridGeneratorParameter::has_method() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GridGeneratorParameter::set_has_method() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GridGeneratorParameter::clear_has_method() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GridGeneratorParameter::clear_method() {
  if (method_ != &::google::protobuf::internal::kEmptyString) {
    method_->clear();
  }
  clear_has_method();
}
inline const ::std::string& GridGeneratorParameter::method() const {
  return *method_;
}
inline void GridGeneratorParameter::set_method(const ::std::string& value) {
  set_has_method();
  if (method_ == &::google::protobuf::internal::kEmptyString) {
    method_ = new ::std::string;
  }
  method_->assign(value);
}
inline void GridGeneratorParameter::set_method(const char* value) {
  set_has_method();
  if (method_ == &::google::protobuf::internal::kEmptyString) {
    method_ = new ::std::string;
  }
  method_->assign(value);
}
inline void GridGeneratorParameter::set_method(const char* value, size_t size) {
  set_has_method();
  if (method_ == &::google::protobuf::internal::kEmptyString) {
    method_ = new ::std::string;
  }
  method_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GridGeneratorParameter::mutable_method() {
  set_has_method();
  if (method_ == &::google::protobuf::internal::kEmptyString) {
    method_ = new ::std::string;
  }
  return method_;
}
inline ::std::string* GridGeneratorParameter::release_method() {
  clear_has_method();
  if (method_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = method_;
    method_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .caffepro.GridGeneratorParameter.GridSizeOption grid_size = 2 [default = RELATIVE];
inline bool GridGeneratorParameter::has_grid_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GridGeneratorParameter::set_has_grid_size() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GridGeneratorParameter::clear_has_grid_size() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GridGeneratorParameter::clear_grid_size() {
  grid_size_ = 0;
  clear_has_grid_size();
}
inline ::caffepro::GridGeneratorParameter_GridSizeOption GridGeneratorParameter::grid_size() const {
  return static_cast< ::caffepro::GridGeneratorParameter_GridSizeOption >(grid_size_);
}
inline void GridGeneratorParameter::set_grid_size(::caffepro::GridGeneratorParameter_GridSizeOption value) {
  GOOGLE_DCHECK(::caffepro::GridGeneratorParameter_GridSizeOption_IsValid(value));
  set_has_grid_size();
  grid_size_ = value;
}

// optional float scale_width = 3 [default = 1];
inline bool GridGeneratorParameter::has_scale_width() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GridGeneratorParameter::set_has_scale_width() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GridGeneratorParameter::clear_has_scale_width() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GridGeneratorParameter::clear_scale_width() {
  scale_width_ = 1;
  clear_has_scale_width();
}
inline float GridGeneratorParameter::scale_width() const {
  return scale_width_;
}
inline void GridGeneratorParameter::set_scale_width(float value) {
  set_has_scale_width();
  scale_width_ = value;
}

// optional float scale_height = 4 [default = 1];
inline bool GridGeneratorParameter::has_scale_height() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GridGeneratorParameter::set_has_scale_height() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GridGeneratorParameter::clear_has_scale_height() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GridGeneratorParameter::clear_scale_height() {
  scale_height_ = 1;
  clear_has_scale_height();
}
inline float GridGeneratorParameter::scale_height() const {
  return scale_height_;
}
inline void GridGeneratorParameter::set_scale_height(float value) {
  set_has_scale_height();
  scale_height_ = value;
}

// -------------------------------------------------------------------

// SampleParameter

// optional .caffepro.SampleParameter.ConcatOutputOption concat_output = 1 [default = CHANNEL];
inline bool SampleParameter::has_concat_output() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SampleParameter::set_has_concat_output() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SampleParameter::clear_has_concat_output() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SampleParameter::clear_concat_output() {
  concat_output_ = 0;
  clear_has_concat_output();
}
inline ::caffepro::SampleParameter_ConcatOutputOption SampleParameter::concat_output() const {
  return static_cast< ::caffepro::SampleParameter_ConcatOutputOption >(concat_output_);
}
inline void SampleParameter::set_concat_output(::caffepro::SampleParameter_ConcatOutputOption value) {
  GOOGLE_DCHECK(::caffepro::SampleParameter_ConcatOutputOption_IsValid(value));
  set_has_concat_output();
  concat_output_ = value;
}

// -------------------------------------------------------------------

// AnchorParameter

// required int32 spatial_width = 1;
inline bool AnchorParameter::has_spatial_width() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AnchorParameter::set_has_spatial_width() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AnchorParameter::clear_has_spatial_width() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AnchorParameter::clear_spatial_width() {
  spatial_width_ = 0;
  clear_has_spatial_width();
}
inline ::google::protobuf::int32 AnchorParameter::spatial_width() const {
  return spatial_width_;
}
inline void AnchorParameter::set_spatial_width(::google::protobuf::int32 value) {
  set_has_spatial_width();
  spatial_width_ = value;
}

// required int32 spatial_height = 2;
inline bool AnchorParameter::has_spatial_height() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AnchorParameter::set_has_spatial_height() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AnchorParameter::clear_has_spatial_height() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AnchorParameter::clear_spatial_height() {
  spatial_height_ = 0;
  clear_has_spatial_height();
}
inline ::google::protobuf::int32 AnchorParameter::spatial_height() const {
  return spatial_height_;
}
inline void AnchorParameter::set_spatial_height(::google::protobuf::int32 value) {
  set_has_spatial_height();
  spatial_height_ = value;
}

// repeated float central_scale = 3;
inline int AnchorParameter::central_scale_size() const {
  return central_scale_.size();
}
inline void AnchorParameter::clear_central_scale() {
  central_scale_.Clear();
}
inline float AnchorParameter::central_scale(int index) const {
  return central_scale_.Get(index);
}
inline void AnchorParameter::set_central_scale(int index, float value) {
  central_scale_.Set(index, value);
}
inline void AnchorParameter::add_central_scale(float value) {
  central_scale_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
AnchorParameter::central_scale() const {
  return central_scale_;
}
inline ::google::protobuf::RepeatedField< float >*
AnchorParameter::mutable_central_scale() {
  return &central_scale_;
}

// optional float spatial_start = 4;
inline bool AnchorParameter::has_spatial_start() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AnchorParameter::set_has_spatial_start() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AnchorParameter::clear_has_spatial_start() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AnchorParameter::clear_spatial_start() {
  spatial_start_ = 0;
  clear_has_spatial_start();
}
inline float AnchorParameter::spatial_start() const {
  return spatial_start_;
}
inline void AnchorParameter::set_spatial_start(float value) {
  set_has_spatial_start();
  spatial_start_ = value;
}

// optional float spatial_step = 5;
inline bool AnchorParameter::has_spatial_step() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AnchorParameter::set_has_spatial_step() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AnchorParameter::clear_has_spatial_step() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AnchorParameter::clear_spatial_step() {
  spatial_step_ = 0;
  clear_has_spatial_step();
}
inline float AnchorParameter::spatial_step() const {
  return spatial_step_;
}
inline void AnchorParameter::set_spatial_step(float value) {
  set_has_spatial_step();
  spatial_step_ = value;
}

// repeated float aspect_ratio = 6;
inline int AnchorParameter::aspect_ratio_size() const {
  return aspect_ratio_.size();
}
inline void AnchorParameter::clear_aspect_ratio() {
  aspect_ratio_.Clear();
}
inline float AnchorParameter::aspect_ratio(int index) const {
  return aspect_ratio_.Get(index);
}
inline void AnchorParameter::set_aspect_ratio(int index, float value) {
  aspect_ratio_.Set(index, value);
}
inline void AnchorParameter::add_aspect_ratio(float value) {
  aspect_ratio_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
AnchorParameter::aspect_ratio() const {
  return aspect_ratio_;
}
inline ::google::protobuf::RepeatedField< float >*
AnchorParameter::mutable_aspect_ratio() {
  return &aspect_ratio_;
}

// -------------------------------------------------------------------

// ConvolutionParameter

// optional uint32 num_output = 1;
inline bool ConvolutionParameter::has_num_output() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ConvolutionParameter::set_has_num_output() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ConvolutionParameter::clear_has_num_output() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ConvolutionParameter::clear_num_output() {
  num_output_ = 0u;
  clear_has_num_output();
}
inline ::google::protobuf::uint32 ConvolutionParameter::num_output() const {
  return num_output_;
}
inline void ConvolutionParameter::set_num_output(::google::protobuf::uint32 value) {
  set_has_num_output();
  num_output_ = value;
}

// optional bool bias_term = 2 [default = true];
inline bool ConvolutionParameter::has_bias_term() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ConvolutionParameter::set_has_bias_term() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ConvolutionParameter::clear_has_bias_term() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ConvolutionParameter::clear_bias_term() {
  bias_term_ = true;
  clear_has_bias_term();
}
inline bool ConvolutionParameter::bias_term() const {
  return bias_term_;
}
inline void ConvolutionParameter::set_bias_term(bool value) {
  set_has_bias_term();
  bias_term_ = value;
}

// optional int32 pad = 3 [default = 0];
inline bool ConvolutionParameter::has_pad() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ConvolutionParameter::set_has_pad() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ConvolutionParameter::clear_has_pad() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ConvolutionParameter::clear_pad() {
  pad_ = 0;
  clear_has_pad();
}
inline ::google::protobuf::int32 ConvolutionParameter::pad() const {
  return pad_;
}
inline void ConvolutionParameter::set_pad(::google::protobuf::int32 value) {
  set_has_pad();
  pad_ = value;
}

// optional uint32 kernel_size = 4;
inline bool ConvolutionParameter::has_kernel_size() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ConvolutionParameter::set_has_kernel_size() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ConvolutionParameter::clear_has_kernel_size() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ConvolutionParameter::clear_kernel_size() {
  kernel_size_ = 0u;
  clear_has_kernel_size();
}
inline ::google::protobuf::uint32 ConvolutionParameter::kernel_size() const {
  return kernel_size_;
}
inline void ConvolutionParameter::set_kernel_size(::google::protobuf::uint32 value) {
  set_has_kernel_size();
  kernel_size_ = value;
}

// optional uint32 group = 5 [default = 1];
inline bool ConvolutionParameter::has_group() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ConvolutionParameter::set_has_group() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ConvolutionParameter::clear_has_group() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ConvolutionParameter::clear_group() {
  group_ = 1u;
  clear_has_group();
}
inline ::google::protobuf::uint32 ConvolutionParameter::group() const {
  return group_;
}
inline void ConvolutionParameter::set_group(::google::protobuf::uint32 value) {
  set_has_group();
  group_ = value;
}

// optional uint32 stride = 6 [default = 1];
inline bool ConvolutionParameter::has_stride() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ConvolutionParameter::set_has_stride() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ConvolutionParameter::clear_has_stride() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ConvolutionParameter::clear_stride() {
  stride_ = 1u;
  clear_has_stride();
}
inline ::google::protobuf::uint32 ConvolutionParameter::stride() const {
  return stride_;
}
inline void ConvolutionParameter::set_stride(::google::protobuf::uint32 value) {
  set_has_stride();
  stride_ = value;
}

// optional .caffepro.FillerParameter weight_filler = 7;
inline bool ConvolutionParameter::has_weight_filler() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ConvolutionParameter::set_has_weight_filler() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ConvolutionParameter::clear_has_weight_filler() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ConvolutionParameter::clear_weight_filler() {
  if (weight_filler_ != NULL) weight_filler_->::caffepro::FillerParameter::Clear();
  clear_has_weight_filler();
}
inline const ::caffepro::FillerParameter& ConvolutionParameter::weight_filler() const {
  return weight_filler_ != NULL ? *weight_filler_ : *default_instance_->weight_filler_;
}
inline ::caffepro::FillerParameter* ConvolutionParameter::mutable_weight_filler() {
  set_has_weight_filler();
  if (weight_filler_ == NULL) weight_filler_ = new ::caffepro::FillerParameter;
  return weight_filler_;
}
inline ::caffepro::FillerParameter* ConvolutionParameter::release_weight_filler() {
  clear_has_weight_filler();
  ::caffepro::FillerParameter* temp = weight_filler_;
  weight_filler_ = NULL;
  return temp;
}

// optional .caffepro.FillerParameter bias_filler = 8;
inline bool ConvolutionParameter::has_bias_filler() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ConvolutionParameter::set_has_bias_filler() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ConvolutionParameter::clear_has_bias_filler() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ConvolutionParameter::clear_bias_filler() {
  if (bias_filler_ != NULL) bias_filler_->::caffepro::FillerParameter::Clear();
  clear_has_bias_filler();
}
inline const ::caffepro::FillerParameter& ConvolutionParameter::bias_filler() const {
  return bias_filler_ != NULL ? *bias_filler_ : *default_instance_->bias_filler_;
}
inline ::caffepro::FillerParameter* ConvolutionParameter::mutable_bias_filler() {
  set_has_bias_filler();
  if (bias_filler_ == NULL) bias_filler_ = new ::caffepro::FillerParameter;
  return bias_filler_;
}
inline ::caffepro::FillerParameter* ConvolutionParameter::release_bias_filler() {
  clear_has_bias_filler();
  ::caffepro::FillerParameter* temp = bias_filler_;
  bias_filler_ = NULL;
  return temp;
}

// optional bool size_floor = 9 [default = true];
inline bool ConvolutionParameter::has_size_floor() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ConvolutionParameter::set_has_size_floor() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ConvolutionParameter::clear_has_size_floor() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ConvolutionParameter::clear_size_floor() {
  size_floor_ = true;
  clear_has_size_floor();
}
inline bool ConvolutionParameter::size_floor() const {
  return size_floor_;
}
inline void ConvolutionParameter::set_size_floor(bool value) {
  set_has_size_floor();
  size_floor_ = value;
}

// repeated uint32 block_calc = 10;
inline int ConvolutionParameter::block_calc_size() const {
  return block_calc_.size();
}
inline void ConvolutionParameter::clear_block_calc() {
  block_calc_.Clear();
}
inline ::google::protobuf::uint32 ConvolutionParameter::block_calc(int index) const {
  return block_calc_.Get(index);
}
inline void ConvolutionParameter::set_block_calc(int index, ::google::protobuf::uint32 value) {
  block_calc_.Set(index, value);
}
inline void ConvolutionParameter::add_block_calc(::google::protobuf::uint32 value) {
  block_calc_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
ConvolutionParameter::block_calc() const {
  return block_calc_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
ConvolutionParameter::mutable_block_calc() {
  return &block_calc_;
}

// optional bool use_cudnn = 11 [default = false];
inline bool ConvolutionParameter::has_use_cudnn() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ConvolutionParameter::set_has_use_cudnn() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ConvolutionParameter::clear_has_use_cudnn() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ConvolutionParameter::clear_use_cudnn() {
  use_cudnn_ = false;
  clear_has_use_cudnn();
}
inline bool ConvolutionParameter::use_cudnn() const {
  return use_cudnn_;
}
inline void ConvolutionParameter::set_use_cudnn(bool value) {
  set_has_use_cudnn();
  use_cudnn_ = value;
}

// optional int32 out_width = 12 [default = 0];
inline bool ConvolutionParameter::has_out_width() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void ConvolutionParameter::set_has_out_width() {
  _has_bits_[0] |= 0x00000800u;
}
inline void ConvolutionParameter::clear_has_out_width() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void ConvolutionParameter::clear_out_width() {
  out_width_ = 0;
  clear_has_out_width();
}
inline ::google::protobuf::int32 ConvolutionParameter::out_width() const {
  return out_width_;
}
inline void ConvolutionParameter::set_out_width(::google::protobuf::int32 value) {
  set_has_out_width();
  out_width_ = value;
}

// optional int32 out_height = 13 [default = 0];
inline bool ConvolutionParameter::has_out_height() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void ConvolutionParameter::set_has_out_height() {
  _has_bits_[0] |= 0x00001000u;
}
inline void ConvolutionParameter::clear_has_out_height() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void ConvolutionParameter::clear_out_height() {
  out_height_ = 0;
  clear_has_out_height();
}
inline ::google::protobuf::int32 ConvolutionParameter::out_height() const {
  return out_height_;
}
inline void ConvolutionParameter::set_out_height(::google::protobuf::int32 value) {
  set_has_out_height();
  out_height_ = value;
}

// optional int32 pad_x = 14 [default = 0];
inline bool ConvolutionParameter::has_pad_x() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void ConvolutionParameter::set_has_pad_x() {
  _has_bits_[0] |= 0x00002000u;
}
inline void ConvolutionParameter::clear_has_pad_x() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void ConvolutionParameter::clear_pad_x() {
  pad_x_ = 0;
  clear_has_pad_x();
}
inline ::google::protobuf::int32 ConvolutionParameter::pad_x() const {
  return pad_x_;
}
inline void ConvolutionParameter::set_pad_x(::google::protobuf::int32 value) {
  set_has_pad_x();
  pad_x_ = value;
}

// optional int32 pad_y = 15 [default = 0];
inline bool ConvolutionParameter::has_pad_y() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void ConvolutionParameter::set_has_pad_y() {
  _has_bits_[0] |= 0x00004000u;
}
inline void ConvolutionParameter::clear_has_pad_y() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void ConvolutionParameter::clear_pad_y() {
  pad_y_ = 0;
  clear_has_pad_y();
}
inline ::google::protobuf::int32 ConvolutionParameter::pad_y() const {
  return pad_y_;
}
inline void ConvolutionParameter::set_pad_y(::google::protobuf::int32 value) {
  set_has_pad_y();
  pad_y_ = value;
}

// optional int32 kernel_size_x = 16 [default = 0];
inline bool ConvolutionParameter::has_kernel_size_x() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void ConvolutionParameter::set_has_kernel_size_x() {
  _has_bits_[0] |= 0x00008000u;
}
inline void ConvolutionParameter::clear_has_kernel_size_x() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void ConvolutionParameter::clear_kernel_size_x() {
  kernel_size_x_ = 0;
  clear_has_kernel_size_x();
}
inline ::google::protobuf::int32 ConvolutionParameter::kernel_size_x() const {
  return kernel_size_x_;
}
inline void ConvolutionParameter::set_kernel_size_x(::google::protobuf::int32 value) {
  set_has_kernel_size_x();
  kernel_size_x_ = value;
}

// optional int32 kernel_size_y = 17 [default = 0];
inline bool ConvolutionParameter::has_kernel_size_y() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void ConvolutionParameter::set_has_kernel_size_y() {
  _has_bits_[0] |= 0x00010000u;
}
inline void ConvolutionParameter::clear_has_kernel_size_y() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void ConvolutionParameter::clear_kernel_size_y() {
  kernel_size_y_ = 0;
  clear_has_kernel_size_y();
}
inline ::google::protobuf::int32 ConvolutionParameter::kernel_size_y() const {
  return kernel_size_y_;
}
inline void ConvolutionParameter::set_kernel_size_y(::google::protobuf::int32 value) {
  set_has_kernel_size_y();
  kernel_size_y_ = value;
}

// optional int32 stride_x = 18 [default = 1];
inline bool ConvolutionParameter::has_stride_x() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void ConvolutionParameter::set_has_stride_x() {
  _has_bits_[0] |= 0x00020000u;
}
inline void ConvolutionParameter::clear_has_stride_x() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void ConvolutionParameter::clear_stride_x() {
  stride_x_ = 1;
  clear_has_stride_x();
}
inline ::google::protobuf::int32 ConvolutionParameter::stride_x() const {
  return stride_x_;
}
inline void ConvolutionParameter::set_stride_x(::google::protobuf::int32 value) {
  set_has_stride_x();
  stride_x_ = value;
}

// optional int32 stride_y = 19 [default = 1];
inline bool ConvolutionParameter::has_stride_y() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void ConvolutionParameter::set_has_stride_y() {
  _has_bits_[0] |= 0x00040000u;
}
inline void ConvolutionParameter::clear_has_stride_y() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void ConvolutionParameter::clear_stride_y() {
  stride_y_ = 1;
  clear_has_stride_y();
}
inline ::google::protobuf::int32 ConvolutionParameter::stride_y() const {
  return stride_y_;
}
inline void ConvolutionParameter::set_stride_y(::google::protobuf::int32 value) {
  set_has_stride_y();
  stride_y_ = value;
}

// -------------------------------------------------------------------

// CorrelationParameter

// optional bool bias_term = 2 [default = true];
inline bool CorrelationParameter::has_bias_term() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CorrelationParameter::set_has_bias_term() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CorrelationParameter::clear_has_bias_term() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CorrelationParameter::clear_bias_term() {
  bias_term_ = true;
  clear_has_bias_term();
}
inline bool CorrelationParameter::bias_term() const {
  return bias_term_;
}
inline void CorrelationParameter::set_bias_term(bool value) {
  set_has_bias_term();
  bias_term_ = value;
}

// optional int32 pad = 3 [default = 0];
inline bool CorrelationParameter::has_pad() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CorrelationParameter::set_has_pad() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CorrelationParameter::clear_has_pad() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CorrelationParameter::clear_pad() {
  pad_ = 0;
  clear_has_pad();
}
inline ::google::protobuf::int32 CorrelationParameter::pad() const {
  return pad_;
}
inline void CorrelationParameter::set_pad(::google::protobuf::int32 value) {
  set_has_pad();
  pad_ = value;
}

// optional uint32 group = 5 [default = 1];
inline bool CorrelationParameter::has_group() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CorrelationParameter::set_has_group() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CorrelationParameter::clear_has_group() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CorrelationParameter::clear_group() {
  group_ = 1u;
  clear_has_group();
}
inline ::google::protobuf::uint32 CorrelationParameter::group() const {
  return group_;
}
inline void CorrelationParameter::set_group(::google::protobuf::uint32 value) {
  set_has_group();
  group_ = value;
}

// optional uint32 stride = 6 [default = 1];
inline bool CorrelationParameter::has_stride() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CorrelationParameter::set_has_stride() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CorrelationParameter::clear_has_stride() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CorrelationParameter::clear_stride() {
  stride_ = 1u;
  clear_has_stride();
}
inline ::google::protobuf::uint32 CorrelationParameter::stride() const {
  return stride_;
}
inline void CorrelationParameter::set_stride(::google::protobuf::uint32 value) {
  set_has_stride();
  stride_ = value;
}

// optional .caffepro.FillerParameter bias_filler = 8;
inline bool CorrelationParameter::has_bias_filler() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CorrelationParameter::set_has_bias_filler() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CorrelationParameter::clear_has_bias_filler() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CorrelationParameter::clear_bias_filler() {
  if (bias_filler_ != NULL) bias_filler_->::caffepro::FillerParameter::Clear();
  clear_has_bias_filler();
}
inline const ::caffepro::FillerParameter& CorrelationParameter::bias_filler() const {
  return bias_filler_ != NULL ? *bias_filler_ : *default_instance_->bias_filler_;
}
inline ::caffepro::FillerParameter* CorrelationParameter::mutable_bias_filler() {
  set_has_bias_filler();
  if (bias_filler_ == NULL) bias_filler_ = new ::caffepro::FillerParameter;
  return bias_filler_;
}
inline ::caffepro::FillerParameter* CorrelationParameter::release_bias_filler() {
  clear_has_bias_filler();
  ::caffepro::FillerParameter* temp = bias_filler_;
  bias_filler_ = NULL;
  return temp;
}

// optional bool size_floor = 9 [default = true];
inline bool CorrelationParameter::has_size_floor() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CorrelationParameter::set_has_size_floor() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CorrelationParameter::clear_has_size_floor() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CorrelationParameter::clear_size_floor() {
  size_floor_ = true;
  clear_has_size_floor();
}
inline bool CorrelationParameter::size_floor() const {
  return size_floor_;
}
inline void CorrelationParameter::set_size_floor(bool value) {
  set_has_size_floor();
  size_floor_ = value;
}

// repeated uint32 block_calc = 10;
inline int CorrelationParameter::block_calc_size() const {
  return block_calc_.size();
}
inline void CorrelationParameter::clear_block_calc() {
  block_calc_.Clear();
}
inline ::google::protobuf::uint32 CorrelationParameter::block_calc(int index) const {
  return block_calc_.Get(index);
}
inline void CorrelationParameter::set_block_calc(int index, ::google::protobuf::uint32 value) {
  block_calc_.Set(index, value);
}
inline void CorrelationParameter::add_block_calc(::google::protobuf::uint32 value) {
  block_calc_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
CorrelationParameter::block_calc() const {
  return block_calc_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
CorrelationParameter::mutable_block_calc() {
  return &block_calc_;
}

// optional int32 out_width = 12 [default = 0];
inline bool CorrelationParameter::has_out_width() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CorrelationParameter::set_has_out_width() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CorrelationParameter::clear_has_out_width() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CorrelationParameter::clear_out_width() {
  out_width_ = 0;
  clear_has_out_width();
}
inline ::google::protobuf::int32 CorrelationParameter::out_width() const {
  return out_width_;
}
inline void CorrelationParameter::set_out_width(::google::protobuf::int32 value) {
  set_has_out_width();
  out_width_ = value;
}

// optional int32 out_height = 13 [default = 0];
inline bool CorrelationParameter::has_out_height() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CorrelationParameter::set_has_out_height() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CorrelationParameter::clear_has_out_height() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CorrelationParameter::clear_out_height() {
  out_height_ = 0;
  clear_has_out_height();
}
inline ::google::protobuf::int32 CorrelationParameter::out_height() const {
  return out_height_;
}
inline void CorrelationParameter::set_out_height(::google::protobuf::int32 value) {
  set_has_out_height();
  out_height_ = value;
}

// optional int32 pad_x = 14 [default = 0];
inline bool CorrelationParameter::has_pad_x() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void CorrelationParameter::set_has_pad_x() {
  _has_bits_[0] |= 0x00000200u;
}
inline void CorrelationParameter::clear_has_pad_x() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void CorrelationParameter::clear_pad_x() {
  pad_x_ = 0;
  clear_has_pad_x();
}
inline ::google::protobuf::int32 CorrelationParameter::pad_x() const {
  return pad_x_;
}
inline void CorrelationParameter::set_pad_x(::google::protobuf::int32 value) {
  set_has_pad_x();
  pad_x_ = value;
}

// optional int32 pad_y = 15 [default = 0];
inline bool CorrelationParameter::has_pad_y() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void CorrelationParameter::set_has_pad_y() {
  _has_bits_[0] |= 0x00000400u;
}
inline void CorrelationParameter::clear_has_pad_y() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void CorrelationParameter::clear_pad_y() {
  pad_y_ = 0;
  clear_has_pad_y();
}
inline ::google::protobuf::int32 CorrelationParameter::pad_y() const {
  return pad_y_;
}
inline void CorrelationParameter::set_pad_y(::google::protobuf::int32 value) {
  set_has_pad_y();
  pad_y_ = value;
}

// optional int32 stride_x = 18 [default = 1];
inline bool CorrelationParameter::has_stride_x() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void CorrelationParameter::set_has_stride_x() {
  _has_bits_[0] |= 0x00000800u;
}
inline void CorrelationParameter::clear_has_stride_x() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void CorrelationParameter::clear_stride_x() {
  stride_x_ = 1;
  clear_has_stride_x();
}
inline ::google::protobuf::int32 CorrelationParameter::stride_x() const {
  return stride_x_;
}
inline void CorrelationParameter::set_stride_x(::google::protobuf::int32 value) {
  set_has_stride_x();
  stride_x_ = value;
}

// optional int32 stride_y = 19 [default = 1];
inline bool CorrelationParameter::has_stride_y() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void CorrelationParameter::set_has_stride_y() {
  _has_bits_[0] |= 0x00001000u;
}
inline void CorrelationParameter::clear_has_stride_y() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void CorrelationParameter::clear_stride_y() {
  stride_y_ = 1;
  clear_has_stride_y();
}
inline ::google::protobuf::int32 CorrelationParameter::stride_y() const {
  return stride_y_;
}
inline void CorrelationParameter::set_stride_y(::google::protobuf::int32 value) {
  set_has_stride_y();
  stride_y_ = value;
}

// -------------------------------------------------------------------

// WeightParameter

// repeated uint32 weight_dim = 1;
inline int WeightParameter::weight_dim_size() const {
  return weight_dim_.size();
}
inline void WeightParameter::clear_weight_dim() {
  weight_dim_.Clear();
}
inline ::google::protobuf::uint32 WeightParameter::weight_dim(int index) const {
  return weight_dim_.Get(index);
}
inline void WeightParameter::set_weight_dim(int index, ::google::protobuf::uint32 value) {
  weight_dim_.Set(index, value);
}
inline void WeightParameter::add_weight_dim(::google::protobuf::uint32 value) {
  weight_dim_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
WeightParameter::weight_dim() const {
  return weight_dim_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
WeightParameter::mutable_weight_dim() {
  return &weight_dim_;
}

// optional .caffepro.FillerParameter weight_filler = 2;
inline bool WeightParameter::has_weight_filler() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void WeightParameter::set_has_weight_filler() {
  _has_bits_[0] |= 0x00000002u;
}
inline void WeightParameter::clear_has_weight_filler() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void WeightParameter::clear_weight_filler() {
  if (weight_filler_ != NULL) weight_filler_->::caffepro::FillerParameter::Clear();
  clear_has_weight_filler();
}
inline const ::caffepro::FillerParameter& WeightParameter::weight_filler() const {
  return weight_filler_ != NULL ? *weight_filler_ : *default_instance_->weight_filler_;
}
inline ::caffepro::FillerParameter* WeightParameter::mutable_weight_filler() {
  set_has_weight_filler();
  if (weight_filler_ == NULL) weight_filler_ = new ::caffepro::FillerParameter;
  return weight_filler_;
}
inline ::caffepro::FillerParameter* WeightParameter::release_weight_filler() {
  clear_has_weight_filler();
  ::caffepro::FillerParameter* temp = weight_filler_;
  weight_filler_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// DataProcesser

// required string processer_type = 1;
inline bool DataProcesser::has_processer_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DataProcesser::set_has_processer_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DataProcesser::clear_has_processer_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DataProcesser::clear_processer_type() {
  if (processer_type_ != &::google::protobuf::internal::kEmptyString) {
    processer_type_->clear();
  }
  clear_has_processer_type();
}
inline const ::std::string& DataProcesser::processer_type() const {
  return *processer_type_;
}
inline void DataProcesser::set_processer_type(const ::std::string& value) {
  set_has_processer_type();
  if (processer_type_ == &::google::protobuf::internal::kEmptyString) {
    processer_type_ = new ::std::string;
  }
  processer_type_->assign(value);
}
inline void DataProcesser::set_processer_type(const char* value) {
  set_has_processer_type();
  if (processer_type_ == &::google::protobuf::internal::kEmptyString) {
    processer_type_ = new ::std::string;
  }
  processer_type_->assign(value);
}
inline void DataProcesser::set_processer_type(const char* value, size_t size) {
  set_has_processer_type();
  if (processer_type_ == &::google::protobuf::internal::kEmptyString) {
    processer_type_ = new ::std::string;
  }
  processer_type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DataProcesser::mutable_processer_type() {
  set_has_processer_type();
  if (processer_type_ == &::google::protobuf::internal::kEmptyString) {
    processer_type_ = new ::std::string;
  }
  return processer_type_;
}
inline ::std::string* DataProcesser::release_processer_type() {
  clear_has_processer_type();
  if (processer_type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = processer_type_;
    processer_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated int32 binding_output_index = 2;
inline int DataProcesser::binding_output_index_size() const {
  return binding_output_index_.size();
}
inline void DataProcesser::clear_binding_output_index() {
  binding_output_index_.Clear();
}
inline ::google::protobuf::int32 DataProcesser::binding_output_index(int index) const {
  return binding_output_index_.Get(index);
}
inline void DataProcesser::set_binding_output_index(int index, ::google::protobuf::int32 value) {
  binding_output_index_.Set(index, value);
}
inline void DataProcesser::add_binding_output_index(::google::protobuf::int32 value) {
  binding_output_index_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
DataProcesser::binding_output_index() const {
  return binding_output_index_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
DataProcesser::mutable_binding_output_index() {
  return &binding_output_index_;
}

// repeated float threshold = 3;
inline int DataProcesser::threshold_size() const {
  return threshold_.size();
}
inline void DataProcesser::clear_threshold() {
  threshold_.Clear();
}
inline float DataProcesser::threshold(int index) const {
  return threshold_.Get(index);
}
inline void DataProcesser::set_threshold(int index, float value) {
  threshold_.Set(index, value);
}
inline void DataProcesser::add_threshold(float value) {
  threshold_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
DataProcesser::threshold() const {
  return threshold_;
}
inline ::google::protobuf::RepeatedField< float >*
DataProcesser::mutable_threshold() {
  return &threshold_;
}

// repeated float alpha = 4;
inline int DataProcesser::alpha_size() const {
  return alpha_.size();
}
inline void DataProcesser::clear_alpha() {
  alpha_.Clear();
}
inline float DataProcesser::alpha(int index) const {
  return alpha_.Get(index);
}
inline void DataProcesser::set_alpha(int index, float value) {
  alpha_.Set(index, value);
}
inline void DataProcesser::add_alpha(float value) {
  alpha_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
DataProcesser::alpha() const {
  return alpha_;
}
inline ::google::protobuf::RepeatedField< float >*
DataProcesser::mutable_alpha() {
  return &alpha_;
}

// repeated float beta = 5;
inline int DataProcesser::beta_size() const {
  return beta_.size();
}
inline void DataProcesser::clear_beta() {
  beta_.Clear();
}
inline float DataProcesser::beta(int index) const {
  return beta_.Get(index);
}
inline void DataProcesser::set_beta(int index, float value) {
  beta_.Set(index, value);
}
inline void DataProcesser::add_beta(float value) {
  beta_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
DataProcesser::beta() const {
  return beta_;
}
inline ::google::protobuf::RepeatedField< float >*
DataProcesser::mutable_beta() {
  return &beta_;
}

// repeated string method = 6;
inline int DataProcesser::method_size() const {
  return method_.size();
}
inline void DataProcesser::clear_method() {
  method_.Clear();
}
inline const ::std::string& DataProcesser::method(int index) const {
  return method_.Get(index);
}
inline ::std::string* DataProcesser::mutable_method(int index) {
  return method_.Mutable(index);
}
inline void DataProcesser::set_method(int index, const ::std::string& value) {
  method_.Mutable(index)->assign(value);
}
inline void DataProcesser::set_method(int index, const char* value) {
  method_.Mutable(index)->assign(value);
}
inline void DataProcesser::set_method(int index, const char* value, size_t size) {
  method_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DataProcesser::add_method() {
  return method_.Add();
}
inline void DataProcesser::add_method(const ::std::string& value) {
  method_.Add()->assign(value);
}
inline void DataProcesser::add_method(const char* value) {
  method_.Add()->assign(value);
}
inline void DataProcesser::add_method(const char* value, size_t size) {
  method_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
DataProcesser::method() const {
  return method_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
DataProcesser::mutable_method() {
  return &method_;
}

// -------------------------------------------------------------------

// DataParameter_BigFile

// optional string source = 1;
inline bool DataParameter_BigFile::has_source() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DataParameter_BigFile::set_has_source() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DataParameter_BigFile::clear_has_source() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DataParameter_BigFile::clear_source() {
  if (source_ != &::google::protobuf::internal::kEmptyString) {
    source_->clear();
  }
  clear_has_source();
}
inline const ::std::string& DataParameter_BigFile::source() const {
  return *source_;
}
inline void DataParameter_BigFile::set_source(const ::std::string& value) {
  set_has_source();
  if (source_ == &::google::protobuf::internal::kEmptyString) {
    source_ = new ::std::string;
  }
  source_->assign(value);
}
inline void DataParameter_BigFile::set_source(const char* value) {
  set_has_source();
  if (source_ == &::google::protobuf::internal::kEmptyString) {
    source_ = new ::std::string;
  }
  source_->assign(value);
}
inline void DataParameter_BigFile::set_source(const char* value, size_t size) {
  set_has_source();
  if (source_ == &::google::protobuf::internal::kEmptyString) {
    source_ = new ::std::string;
  }
  source_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DataParameter_BigFile::mutable_source() {
  set_has_source();
  if (source_ == &::google::protobuf::internal::kEmptyString) {
    source_ = new ::std::string;
  }
  return source_;
}
inline ::std::string* DataParameter_BigFile::release_source() {
  clear_has_source();
  if (source_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = source_;
    source_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional float scale = 2 [default = 1];
inline bool DataParameter_BigFile::has_scale() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DataParameter_BigFile::set_has_scale() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DataParameter_BigFile::clear_has_scale() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DataParameter_BigFile::clear_scale() {
  scale_ = 1;
  clear_has_scale();
}
inline float DataParameter_BigFile::scale() const {
  return scale_;
}
inline void DataParameter_BigFile::set_scale(float value) {
  set_has_scale();
  scale_ = value;
}

// optional string mean_file = 3;
inline bool DataParameter_BigFile::has_mean_file() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DataParameter_BigFile::set_has_mean_file() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DataParameter_BigFile::clear_has_mean_file() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DataParameter_BigFile::clear_mean_file() {
  if (mean_file_ != &::google::protobuf::internal::kEmptyString) {
    mean_file_->clear();
  }
  clear_has_mean_file();
}
inline const ::std::string& DataParameter_BigFile::mean_file() const {
  return *mean_file_;
}
inline void DataParameter_BigFile::set_mean_file(const ::std::string& value) {
  set_has_mean_file();
  if (mean_file_ == &::google::protobuf::internal::kEmptyString) {
    mean_file_ = new ::std::string;
  }
  mean_file_->assign(value);
}
inline void DataParameter_BigFile::set_mean_file(const char* value) {
  set_has_mean_file();
  if (mean_file_ == &::google::protobuf::internal::kEmptyString) {
    mean_file_ = new ::std::string;
  }
  mean_file_->assign(value);
}
inline void DataParameter_BigFile::set_mean_file(const char* value, size_t size) {
  set_has_mean_file();
  if (mean_file_ == &::google::protobuf::internal::kEmptyString) {
    mean_file_ = new ::std::string;
  }
  mean_file_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DataParameter_BigFile::mutable_mean_file() {
  set_has_mean_file();
  if (mean_file_ == &::google::protobuf::internal::kEmptyString) {
    mean_file_ = new ::std::string;
  }
  return mean_file_;
}
inline ::std::string* DataParameter_BigFile::release_mean_file() {
  clear_has_mean_file();
  if (mean_file_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mean_file_;
    mean_file_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional uint32 batch_size = 4;
inline bool DataParameter_BigFile::has_batch_size() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DataParameter_BigFile::set_has_batch_size() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DataParameter_BigFile::clear_has_batch_size() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DataParameter_BigFile::clear_batch_size() {
  batch_size_ = 0u;
  clear_has_batch_size();
}
inline ::google::protobuf::uint32 DataParameter_BigFile::batch_size() const {
  return batch_size_;
}
inline void DataParameter_BigFile::set_batch_size(::google::protobuf::uint32 value) {
  set_has_batch_size();
  batch_size_ = value;
}

// optional uint32 batch_img_size = 5 [default = 0];
inline bool DataParameter_BigFile::has_batch_img_size() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DataParameter_BigFile::set_has_batch_img_size() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DataParameter_BigFile::clear_has_batch_img_size() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DataParameter_BigFile::clear_batch_img_size() {
  batch_img_size_ = 0u;
  clear_has_batch_img_size();
}
inline ::google::protobuf::uint32 DataParameter_BigFile::batch_img_size() const {
  return batch_img_size_;
}
inline void DataParameter_BigFile::set_batch_img_size(::google::protobuf::uint32 value) {
  set_has_batch_img_size();
  batch_img_size_ = value;
}

// repeated uint32 channel_num = 6;
inline int DataParameter_BigFile::channel_num_size() const {
  return channel_num_.size();
}
inline void DataParameter_BigFile::clear_channel_num() {
  channel_num_.Clear();
}
inline ::google::protobuf::uint32 DataParameter_BigFile::channel_num(int index) const {
  return channel_num_.Get(index);
}
inline void DataParameter_BigFile::set_channel_num(int index, ::google::protobuf::uint32 value) {
  channel_num_.Set(index, value);
}
inline void DataParameter_BigFile::add_channel_num(::google::protobuf::uint32 value) {
  channel_num_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
DataParameter_BigFile::channel_num() const {
  return channel_num_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
DataParameter_BigFile::mutable_channel_num() {
  return &channel_num_;
}

// optional uint32 crop_type = 7 [default = 0];
inline bool DataParameter_BigFile::has_crop_type() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void DataParameter_BigFile::set_has_crop_type() {
  _has_bits_[0] |= 0x00000040u;
}
inline void DataParameter_BigFile::clear_has_crop_type() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void DataParameter_BigFile::clear_crop_type() {
  crop_type_ = 0u;
  clear_has_crop_type();
}
inline ::google::protobuf::uint32 DataParameter_BigFile::crop_type() const {
  return crop_type_;
}
inline void DataParameter_BigFile::set_crop_type(::google::protobuf::uint32 value) {
  set_has_crop_type();
  crop_type_ = value;
}

// optional float crop_ratio = 8 [default = 1];
inline bool DataParameter_BigFile::has_crop_ratio() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void DataParameter_BigFile::set_has_crop_ratio() {
  _has_bits_[0] |= 0x00000080u;
}
inline void DataParameter_BigFile::clear_has_crop_ratio() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void DataParameter_BigFile::clear_crop_ratio() {
  crop_ratio_ = 1;
  clear_has_crop_ratio();
}
inline float DataParameter_BigFile::crop_ratio() const {
  return crop_ratio_;
}
inline void DataParameter_BigFile::set_crop_ratio(float value) {
  set_has_crop_ratio();
  crop_ratio_ = value;
}

// optional string color_kl_dir = 9;
inline bool DataParameter_BigFile::has_color_kl_dir() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void DataParameter_BigFile::set_has_color_kl_dir() {
  _has_bits_[0] |= 0x00000100u;
}
inline void DataParameter_BigFile::clear_has_color_kl_dir() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void DataParameter_BigFile::clear_color_kl_dir() {
  if (color_kl_dir_ != &::google::protobuf::internal::kEmptyString) {
    color_kl_dir_->clear();
  }
  clear_has_color_kl_dir();
}
inline const ::std::string& DataParameter_BigFile::color_kl_dir() const {
  return *color_kl_dir_;
}
inline void DataParameter_BigFile::set_color_kl_dir(const ::std::string& value) {
  set_has_color_kl_dir();
  if (color_kl_dir_ == &::google::protobuf::internal::kEmptyString) {
    color_kl_dir_ = new ::std::string;
  }
  color_kl_dir_->assign(value);
}
inline void DataParameter_BigFile::set_color_kl_dir(const char* value) {
  set_has_color_kl_dir();
  if (color_kl_dir_ == &::google::protobuf::internal::kEmptyString) {
    color_kl_dir_ = new ::std::string;
  }
  color_kl_dir_->assign(value);
}
inline void DataParameter_BigFile::set_color_kl_dir(const char* value, size_t size) {
  set_has_color_kl_dir();
  if (color_kl_dir_ == &::google::protobuf::internal::kEmptyString) {
    color_kl_dir_ = new ::std::string;
  }
  color_kl_dir_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DataParameter_BigFile::mutable_color_kl_dir() {
  set_has_color_kl_dir();
  if (color_kl_dir_ == &::google::protobuf::internal::kEmptyString) {
    color_kl_dir_ = new ::std::string;
  }
  return color_kl_dir_;
}
inline ::std::string* DataParameter_BigFile::release_color_kl_dir() {
  clear_has_color_kl_dir();
  if (color_kl_dir_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = color_kl_dir_;
    color_kl_dir_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bool random_shuffle = 11 [default = true];
inline bool DataParameter_BigFile::has_random_shuffle() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void DataParameter_BigFile::set_has_random_shuffle() {
  _has_bits_[0] |= 0x00000200u;
}
inline void DataParameter_BigFile::clear_has_random_shuffle() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void DataParameter_BigFile::clear_random_shuffle() {
  random_shuffle_ = true;
  clear_has_random_shuffle();
}
inline bool DataParameter_BigFile::random_shuffle() const {
  return random_shuffle_;
}
inline void DataParameter_BigFile::set_random_shuffle(bool value) {
  set_has_random_shuffle();
  random_shuffle_ = value;
}

// optional float overlap_thres = 12 [default = 0];
inline bool DataParameter_BigFile::has_overlap_thres() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void DataParameter_BigFile::set_has_overlap_thres() {
  _has_bits_[0] |= 0x00000400u;
}
inline void DataParameter_BigFile::clear_has_overlap_thres() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void DataParameter_BigFile::clear_overlap_thres() {
  overlap_thres_ = 0;
  clear_has_overlap_thres();
}
inline float DataParameter_BigFile::overlap_thres() const {
  return overlap_thres_;
}
inline void DataParameter_BigFile::set_overlap_thres(float value) {
  set_has_overlap_thres();
  overlap_thres_ = value;
}

// optional string object_windows_dir = 13;
inline bool DataParameter_BigFile::has_object_windows_dir() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void DataParameter_BigFile::set_has_object_windows_dir() {
  _has_bits_[0] |= 0x00000800u;
}
inline void DataParameter_BigFile::clear_has_object_windows_dir() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void DataParameter_BigFile::clear_object_windows_dir() {
  if (object_windows_dir_ != &::google::protobuf::internal::kEmptyString) {
    object_windows_dir_->clear();
  }
  clear_has_object_windows_dir();
}
inline const ::std::string& DataParameter_BigFile::object_windows_dir() const {
  return *object_windows_dir_;
}
inline void DataParameter_BigFile::set_object_windows_dir(const ::std::string& value) {
  set_has_object_windows_dir();
  if (object_windows_dir_ == &::google::protobuf::internal::kEmptyString) {
    object_windows_dir_ = new ::std::string;
  }
  object_windows_dir_->assign(value);
}
inline void DataParameter_BigFile::set_object_windows_dir(const char* value) {
  set_has_object_windows_dir();
  if (object_windows_dir_ == &::google::protobuf::internal::kEmptyString) {
    object_windows_dir_ = new ::std::string;
  }
  object_windows_dir_->assign(value);
}
inline void DataParameter_BigFile::set_object_windows_dir(const char* value, size_t size) {
  set_has_object_windows_dir();
  if (object_windows_dir_ == &::google::protobuf::internal::kEmptyString) {
    object_windows_dir_ = new ::std::string;
  }
  object_windows_dir_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DataParameter_BigFile::mutable_object_windows_dir() {
  set_has_object_windows_dir();
  if (object_windows_dir_ == &::google::protobuf::internal::kEmptyString) {
    object_windows_dir_ = new ::std::string;
  }
  return object_windows_dir_;
}
inline ::std::string* DataParameter_BigFile::release_object_windows_dir() {
  clear_has_object_windows_dir();
  if (object_windows_dir_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = object_windows_dir_;
    object_windows_dir_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional float crop_ratio_upperbound = 14 [default = -1];
inline bool DataParameter_BigFile::has_crop_ratio_upperbound() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void DataParameter_BigFile::set_has_crop_ratio_upperbound() {
  _has_bits_[0] |= 0x00001000u;
}
inline void DataParameter_BigFile::clear_has_crop_ratio_upperbound() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void DataParameter_BigFile::clear_crop_ratio_upperbound() {
  crop_ratio_upperbound_ = -1;
  clear_has_crop_ratio_upperbound();
}
inline float DataParameter_BigFile::crop_ratio_upperbound() const {
  return crop_ratio_upperbound_;
}
inline void DataParameter_BigFile::set_crop_ratio_upperbound(float value) {
  set_has_crop_ratio_upperbound();
  crop_ratio_upperbound_ = value;
}

// optional float crop_ratio_lowerbound = 15 [default = -1];
inline bool DataParameter_BigFile::has_crop_ratio_lowerbound() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void DataParameter_BigFile::set_has_crop_ratio_lowerbound() {
  _has_bits_[0] |= 0x00002000u;
}
inline void DataParameter_BigFile::clear_has_crop_ratio_lowerbound() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void DataParameter_BigFile::clear_crop_ratio_lowerbound() {
  crop_ratio_lowerbound_ = -1;
  clear_has_crop_ratio_lowerbound();
}
inline float DataParameter_BigFile::crop_ratio_lowerbound() const {
  return crop_ratio_lowerbound_;
}
inline void DataParameter_BigFile::set_crop_ratio_lowerbound(float value) {
  set_has_crop_ratio_lowerbound();
  crop_ratio_lowerbound_ = value;
}

// repeated .caffepro.DataParameter_BigFile.InterpolationType interpolation = 16;
inline int DataParameter_BigFile::interpolation_size() const {
  return interpolation_.size();
}
inline void DataParameter_BigFile::clear_interpolation() {
  interpolation_.Clear();
}
inline ::caffepro::DataParameter_BigFile_InterpolationType DataParameter_BigFile::interpolation(int index) const {
  return static_cast< ::caffepro::DataParameter_BigFile_InterpolationType >(interpolation_.Get(index));
}
inline void DataParameter_BigFile::set_interpolation(int index, ::caffepro::DataParameter_BigFile_InterpolationType value) {
  GOOGLE_DCHECK(::caffepro::DataParameter_BigFile_InterpolationType_IsValid(value));
  interpolation_.Set(index, value);
}
inline void DataParameter_BigFile::add_interpolation(::caffepro::DataParameter_BigFile_InterpolationType value) {
  GOOGLE_DCHECK(::caffepro::DataParameter_BigFile_InterpolationType_IsValid(value));
  interpolation_.Add(value);
}
inline const ::google::protobuf::RepeatedField<int>&
DataParameter_BigFile::interpolation() const {
  return interpolation_;
}
inline ::google::protobuf::RepeatedField<int>*
DataParameter_BigFile::mutable_interpolation() {
  return &interpolation_;
}

// optional float aspect_ratio_variation = 17 [default = 0];
inline bool DataParameter_BigFile::has_aspect_ratio_variation() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void DataParameter_BigFile::set_has_aspect_ratio_variation() {
  _has_bits_[0] |= 0x00008000u;
}
inline void DataParameter_BigFile::clear_has_aspect_ratio_variation() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void DataParameter_BigFile::clear_aspect_ratio_variation() {
  aspect_ratio_variation_ = 0;
  clear_has_aspect_ratio_variation();
}
inline float DataParameter_BigFile::aspect_ratio_variation() const {
  return aspect_ratio_variation_;
}
inline void DataParameter_BigFile::set_aspect_ratio_variation(float value) {
  set_has_aspect_ratio_variation();
  aspect_ratio_variation_ = value;
}

// optional .caffepro.DataParameter_BigFile.ScaleJitterType scale_jitter_type = 18 [default = UniRatio];
inline bool DataParameter_BigFile::has_scale_jitter_type() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void DataParameter_BigFile::set_has_scale_jitter_type() {
  _has_bits_[0] |= 0x00010000u;
}
inline void DataParameter_BigFile::clear_has_scale_jitter_type() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void DataParameter_BigFile::clear_scale_jitter_type() {
  scale_jitter_type_ = 0;
  clear_has_scale_jitter_type();
}
inline ::caffepro::DataParameter_BigFile_ScaleJitterType DataParameter_BigFile::scale_jitter_type() const {
  return static_cast< ::caffepro::DataParameter_BigFile_ScaleJitterType >(scale_jitter_type_);
}
inline void DataParameter_BigFile::set_scale_jitter_type(::caffepro::DataParameter_BigFile_ScaleJitterType value) {
  GOOGLE_DCHECK(::caffepro::DataParameter_BigFile_ScaleJitterType_IsValid(value));
  set_has_scale_jitter_type();
  scale_jitter_type_ = value;
}

// repeated .caffepro.DataProcesser additional_data_processer = 19;
inline int DataParameter_BigFile::additional_data_processer_size() const {
  return additional_data_processer_.size();
}
inline void DataParameter_BigFile::clear_additional_data_processer() {
  additional_data_processer_.Clear();
}
inline const ::caffepro::DataProcesser& DataParameter_BigFile::additional_data_processer(int index) const {
  return additional_data_processer_.Get(index);
}
inline ::caffepro::DataProcesser* DataParameter_BigFile::mutable_additional_data_processer(int index) {
  return additional_data_processer_.Mutable(index);
}
inline ::caffepro::DataProcesser* DataParameter_BigFile::add_additional_data_processer() {
  return additional_data_processer_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::caffepro::DataProcesser >&
DataParameter_BigFile::additional_data_processer() const {
  return additional_data_processer_;
}
inline ::google::protobuf::RepeatedPtrField< ::caffepro::DataProcesser >*
DataParameter_BigFile::mutable_additional_data_processer() {
  return &additional_data_processer_;
}

// optional bool cache_data = 20 [default = true];
inline bool DataParameter_BigFile::has_cache_data() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void DataParameter_BigFile::set_has_cache_data() {
  _has_bits_[0] |= 0x00040000u;
}
inline void DataParameter_BigFile::clear_has_cache_data() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void DataParameter_BigFile::clear_cache_data() {
  cache_data_ = true;
  clear_has_cache_data();
}
inline bool DataParameter_BigFile::cache_data() const {
  return cache_data_;
}
inline void DataParameter_BigFile::set_cache_data(bool value) {
  set_has_cache_data();
  cache_data_ = value;
}

// optional string multilabel_def_file = 21;
inline bool DataParameter_BigFile::has_multilabel_def_file() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void DataParameter_BigFile::set_has_multilabel_def_file() {
  _has_bits_[0] |= 0x00080000u;
}
inline void DataParameter_BigFile::clear_has_multilabel_def_file() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void DataParameter_BigFile::clear_multilabel_def_file() {
  if (multilabel_def_file_ != &::google::protobuf::internal::kEmptyString) {
    multilabel_def_file_->clear();
  }
  clear_has_multilabel_def_file();
}
inline const ::std::string& DataParameter_BigFile::multilabel_def_file() const {
  return *multilabel_def_file_;
}
inline void DataParameter_BigFile::set_multilabel_def_file(const ::std::string& value) {
  set_has_multilabel_def_file();
  if (multilabel_def_file_ == &::google::protobuf::internal::kEmptyString) {
    multilabel_def_file_ = new ::std::string;
  }
  multilabel_def_file_->assign(value);
}
inline void DataParameter_BigFile::set_multilabel_def_file(const char* value) {
  set_has_multilabel_def_file();
  if (multilabel_def_file_ == &::google::protobuf::internal::kEmptyString) {
    multilabel_def_file_ = new ::std::string;
  }
  multilabel_def_file_->assign(value);
}
inline void DataParameter_BigFile::set_multilabel_def_file(const char* value, size_t size) {
  set_has_multilabel_def_file();
  if (multilabel_def_file_ == &::google::protobuf::internal::kEmptyString) {
    multilabel_def_file_ = new ::std::string;
  }
  multilabel_def_file_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DataParameter_BigFile::mutable_multilabel_def_file() {
  set_has_multilabel_def_file();
  if (multilabel_def_file_ == &::google::protobuf::internal::kEmptyString) {
    multilabel_def_file_ = new ::std::string;
  }
  return multilabel_def_file_;
}
inline ::std::string* DataParameter_BigFile::release_multilabel_def_file() {
  clear_has_multilabel_def_file();
  if (multilabel_def_file_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = multilabel_def_file_;
    multilabel_def_file_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string metadata_file = 22;
inline bool DataParameter_BigFile::has_metadata_file() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void DataParameter_BigFile::set_has_metadata_file() {
  _has_bits_[0] |= 0x00100000u;
}
inline void DataParameter_BigFile::clear_has_metadata_file() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void DataParameter_BigFile::clear_metadata_file() {
  if (metadata_file_ != &::google::protobuf::internal::kEmptyString) {
    metadata_file_->clear();
  }
  clear_has_metadata_file();
}
inline const ::std::string& DataParameter_BigFile::metadata_file() const {
  return *metadata_file_;
}
inline void DataParameter_BigFile::set_metadata_file(const ::std::string& value) {
  set_has_metadata_file();
  if (metadata_file_ == &::google::protobuf::internal::kEmptyString) {
    metadata_file_ = new ::std::string;
  }
  metadata_file_->assign(value);
}
inline void DataParameter_BigFile::set_metadata_file(const char* value) {
  set_has_metadata_file();
  if (metadata_file_ == &::google::protobuf::internal::kEmptyString) {
    metadata_file_ = new ::std::string;
  }
  metadata_file_->assign(value);
}
inline void DataParameter_BigFile::set_metadata_file(const char* value, size_t size) {
  set_has_metadata_file();
  if (metadata_file_ == &::google::protobuf::internal::kEmptyString) {
    metadata_file_ = new ::std::string;
  }
  metadata_file_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DataParameter_BigFile::mutable_metadata_file() {
  set_has_metadata_file();
  if (metadata_file_ == &::google::protobuf::internal::kEmptyString) {
    metadata_file_ = new ::std::string;
  }
  return metadata_file_;
}
inline ::std::string* DataParameter_BigFile::release_metadata_file() {
  clear_has_metadata_file();
  if (metadata_file_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = metadata_file_;
    metadata_file_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional float random_crop_overlap_threshold = 23 [default = 0];
inline bool DataParameter_BigFile::has_random_crop_overlap_threshold() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void DataParameter_BigFile::set_has_random_crop_overlap_threshold() {
  _has_bits_[0] |= 0x00200000u;
}
inline void DataParameter_BigFile::clear_has_random_crop_overlap_threshold() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void DataParameter_BigFile::clear_random_crop_overlap_threshold() {
  random_crop_overlap_threshold_ = 0;
  clear_has_random_crop_overlap_threshold();
}
inline float DataParameter_BigFile::random_crop_overlap_threshold() const {
  return random_crop_overlap_threshold_;
}
inline void DataParameter_BigFile::set_random_crop_overlap_threshold(float value) {
  set_has_random_crop_overlap_threshold();
  random_crop_overlap_threshold_ = value;
}

// optional .caffepro.DataParameter_BigFile.CropPreference crop_preference = 24 [default = IoCThres];
inline bool DataParameter_BigFile::has_crop_preference() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void DataParameter_BigFile::set_has_crop_preference() {
  _has_bits_[0] |= 0x00400000u;
}
inline void DataParameter_BigFile::clear_has_crop_preference() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void DataParameter_BigFile::clear_crop_preference() {
  crop_preference_ = 0;
  clear_has_crop_preference();
}
inline ::caffepro::DataParameter_BigFile_CropPreference DataParameter_BigFile::crop_preference() const {
  return static_cast< ::caffepro::DataParameter_BigFile_CropPreference >(crop_preference_);
}
inline void DataParameter_BigFile::set_crop_preference(::caffepro::DataParameter_BigFile_CropPreference value) {
  GOOGLE_DCHECK(::caffepro::DataParameter_BigFile_CropPreference_IsValid(value));
  set_has_crop_preference();
  crop_preference_ = value;
}

// optional int32 crop_dim1_segs = 25;
inline bool DataParameter_BigFile::has_crop_dim1_segs() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void DataParameter_BigFile::set_has_crop_dim1_segs() {
  _has_bits_[0] |= 0x00800000u;
}
inline void DataParameter_BigFile::clear_has_crop_dim1_segs() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void DataParameter_BigFile::clear_crop_dim1_segs() {
  crop_dim1_segs_ = 0;
  clear_has_crop_dim1_segs();
}
inline ::google::protobuf::int32 DataParameter_BigFile::crop_dim1_segs() const {
  return crop_dim1_segs_;
}
inline void DataParameter_BigFile::set_crop_dim1_segs(::google::protobuf::int32 value) {
  set_has_crop_dim1_segs();
  crop_dim1_segs_ = value;
}

// optional int32 crop_dim2_segs = 26;
inline bool DataParameter_BigFile::has_crop_dim2_segs() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void DataParameter_BigFile::set_has_crop_dim2_segs() {
  _has_bits_[0] |= 0x01000000u;
}
inline void DataParameter_BigFile::clear_has_crop_dim2_segs() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void DataParameter_BigFile::clear_crop_dim2_segs() {
  crop_dim2_segs_ = 0;
  clear_has_crop_dim2_segs();
}
inline ::google::protobuf::int32 DataParameter_BigFile::crop_dim2_segs() const {
  return crop_dim2_segs_;
}
inline void DataParameter_BigFile::set_crop_dim2_segs(::google::protobuf::int32 value) {
  set_has_crop_dim2_segs();
  crop_dim2_segs_ = value;
}

// optional string crop_box_file = 27;
inline bool DataParameter_BigFile::has_crop_box_file() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void DataParameter_BigFile::set_has_crop_box_file() {
  _has_bits_[0] |= 0x02000000u;
}
inline void DataParameter_BigFile::clear_has_crop_box_file() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void DataParameter_BigFile::clear_crop_box_file() {
  if (crop_box_file_ != &::google::protobuf::internal::kEmptyString) {
    crop_box_file_->clear();
  }
  clear_has_crop_box_file();
}
inline const ::std::string& DataParameter_BigFile::crop_box_file() const {
  return *crop_box_file_;
}
inline void DataParameter_BigFile::set_crop_box_file(const ::std::string& value) {
  set_has_crop_box_file();
  if (crop_box_file_ == &::google::protobuf::internal::kEmptyString) {
    crop_box_file_ = new ::std::string;
  }
  crop_box_file_->assign(value);
}
inline void DataParameter_BigFile::set_crop_box_file(const char* value) {
  set_has_crop_box_file();
  if (crop_box_file_ == &::google::protobuf::internal::kEmptyString) {
    crop_box_file_ = new ::std::string;
  }
  crop_box_file_->assign(value);
}
inline void DataParameter_BigFile::set_crop_box_file(const char* value, size_t size) {
  set_has_crop_box_file();
  if (crop_box_file_ == &::google::protobuf::internal::kEmptyString) {
    crop_box_file_ = new ::std::string;
  }
  crop_box_file_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DataParameter_BigFile::mutable_crop_box_file() {
  set_has_crop_box_file();
  if (crop_box_file_ == &::google::protobuf::internal::kEmptyString) {
    crop_box_file_ = new ::std::string;
  }
  return crop_box_file_;
}
inline ::std::string* DataParameter_BigFile::release_crop_box_file() {
  clear_has_crop_box_file();
  if (crop_box_file_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = crop_box_file_;
    crop_box_file_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional float rcnn_pad = 28;
inline bool DataParameter_BigFile::has_rcnn_pad() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void DataParameter_BigFile::set_has_rcnn_pad() {
  _has_bits_[0] |= 0x04000000u;
}
inline void DataParameter_BigFile::clear_has_rcnn_pad() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void DataParameter_BigFile::clear_rcnn_pad() {
  rcnn_pad_ = 0;
  clear_has_rcnn_pad();
}
inline float DataParameter_BigFile::rcnn_pad() const {
  return rcnn_pad_;
}
inline void DataParameter_BigFile::set_rcnn_pad(float value) {
  set_has_rcnn_pad();
  rcnn_pad_ = value;
}

// -------------------------------------------------------------------

// DataEntryParameter

// required string entry_name = 1;
inline bool DataEntryParameter::has_entry_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DataEntryParameter::set_has_entry_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DataEntryParameter::clear_has_entry_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DataEntryParameter::clear_entry_name() {
  if (entry_name_ != &::google::protobuf::internal::kEmptyString) {
    entry_name_->clear();
  }
  clear_has_entry_name();
}
inline const ::std::string& DataEntryParameter::entry_name() const {
  return *entry_name_;
}
inline void DataEntryParameter::set_entry_name(const ::std::string& value) {
  set_has_entry_name();
  if (entry_name_ == &::google::protobuf::internal::kEmptyString) {
    entry_name_ = new ::std::string;
  }
  entry_name_->assign(value);
}
inline void DataEntryParameter::set_entry_name(const char* value) {
  set_has_entry_name();
  if (entry_name_ == &::google::protobuf::internal::kEmptyString) {
    entry_name_ = new ::std::string;
  }
  entry_name_->assign(value);
}
inline void DataEntryParameter::set_entry_name(const char* value, size_t size) {
  set_has_entry_name();
  if (entry_name_ == &::google::protobuf::internal::kEmptyString) {
    entry_name_ = new ::std::string;
  }
  entry_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DataEntryParameter::mutable_entry_name() {
  set_has_entry_name();
  if (entry_name_ == &::google::protobuf::internal::kEmptyString) {
    entry_name_ = new ::std::string;
  }
  return entry_name_;
}
inline ::std::string* DataEntryParameter::release_entry_name() {
  clear_has_entry_name();
  if (entry_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = entry_name_;
    entry_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 entry_index = 2 [default = 0];
inline bool DataEntryParameter::has_entry_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DataEntryParameter::set_has_entry_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DataEntryParameter::clear_has_entry_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DataEntryParameter::clear_entry_index() {
  entry_index_ = 0;
  clear_has_entry_index();
}
inline ::google::protobuf::int32 DataEntryParameter::entry_index() const {
  return entry_index_;
}
inline void DataEntryParameter::set_entry_index(::google::protobuf::int32 value) {
  set_has_entry_index();
  entry_index_ = value;
}

// -------------------------------------------------------------------

// DropoutParameter

// optional float dropout_ratio = 1 [default = 0.5];
inline bool DropoutParameter::has_dropout_ratio() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DropoutParameter::set_has_dropout_ratio() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DropoutParameter::clear_has_dropout_ratio() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DropoutParameter::clear_dropout_ratio() {
  dropout_ratio_ = 0.5f;
  clear_has_dropout_ratio();
}
inline float DropoutParameter::dropout_ratio() const {
  return dropout_ratio_;
}
inline void DropoutParameter::set_dropout_ratio(float value) {
  set_has_dropout_ratio();
  dropout_ratio_ = value;
}

// optional bool force_random = 2 [default = false];
inline bool DropoutParameter::has_force_random() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DropoutParameter::set_has_force_random() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DropoutParameter::clear_has_force_random() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DropoutParameter::clear_force_random() {
  force_random_ = false;
  clear_has_force_random();
}
inline bool DropoutParameter::force_random() const {
  return force_random_;
}
inline void DropoutParameter::set_force_random(bool value) {
  set_has_force_random();
  force_random_ = value;
}

// optional bool force_same = 3 [default = false];
inline bool DropoutParameter::has_force_same() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DropoutParameter::set_has_force_same() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DropoutParameter::clear_has_force_same() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DropoutParameter::clear_force_same() {
  force_same_ = false;
  clear_has_force_same();
}
inline bool DropoutParameter::force_same() const {
  return force_same_;
}
inline void DropoutParameter::set_force_same(bool value) {
  set_has_force_same();
  force_same_ = value;
}

// -------------------------------------------------------------------

// PaddingParameter

// optional uint32 pad = 1 [default = 0];
inline bool PaddingParameter::has_pad() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PaddingParameter::set_has_pad() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PaddingParameter::clear_has_pad() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PaddingParameter::clear_pad() {
  pad_ = 0u;
  clear_has_pad();
}
inline ::google::protobuf::uint32 PaddingParameter::pad() const {
  return pad_;
}
inline void PaddingParameter::set_pad(::google::protobuf::uint32 value) {
  set_has_pad();
  pad_ = value;
}

// -------------------------------------------------------------------

// InfogainLossParameter

// optional string source = 1;
inline bool InfogainLossParameter::has_source() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InfogainLossParameter::set_has_source() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InfogainLossParameter::clear_has_source() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InfogainLossParameter::clear_source() {
  if (source_ != &::google::protobuf::internal::kEmptyString) {
    source_->clear();
  }
  clear_has_source();
}
inline const ::std::string& InfogainLossParameter::source() const {
  return *source_;
}
inline void InfogainLossParameter::set_source(const ::std::string& value) {
  set_has_source();
  if (source_ == &::google::protobuf::internal::kEmptyString) {
    source_ = new ::std::string;
  }
  source_->assign(value);
}
inline void InfogainLossParameter::set_source(const char* value) {
  set_has_source();
  if (source_ == &::google::protobuf::internal::kEmptyString) {
    source_ = new ::std::string;
  }
  source_->assign(value);
}
inline void InfogainLossParameter::set_source(const char* value, size_t size) {
  set_has_source();
  if (source_ == &::google::protobuf::internal::kEmptyString) {
    source_ = new ::std::string;
  }
  source_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InfogainLossParameter::mutable_source() {
  set_has_source();
  if (source_ == &::google::protobuf::internal::kEmptyString) {
    source_ = new ::std::string;
  }
  return source_;
}
inline ::std::string* InfogainLossParameter::release_source() {
  clear_has_source();
  if (source_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = source_;
    source_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// LossParameter

// optional float coeff = 1 [default = 1];
inline bool LossParameter::has_coeff() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LossParameter::set_has_coeff() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LossParameter::clear_has_coeff() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LossParameter::clear_coeff() {
  coeff_ = 1;
  clear_has_coeff();
}
inline float LossParameter::coeff() const {
  return coeff_;
}
inline void LossParameter::set_coeff(float value) {
  set_has_coeff();
  coeff_ = value;
}

// optional bool display_result = 2 [default = true];
inline bool LossParameter::has_display_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LossParameter::set_has_display_result() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LossParameter::clear_has_display_result() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LossParameter::clear_display_result() {
  display_result_ = true;
  clear_has_display_result();
}
inline bool LossParameter::display_result() const {
  return display_result_;
}
inline void LossParameter::set_display_result(bool value) {
  set_has_display_result();
  display_result_ = value;
}

// -------------------------------------------------------------------

// ClsLocLossParameter

// optional float cls_coeff = 1 [default = 1];
inline bool ClsLocLossParameter::has_cls_coeff() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClsLocLossParameter::set_has_cls_coeff() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClsLocLossParameter::clear_has_cls_coeff() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClsLocLossParameter::clear_cls_coeff() {
  cls_coeff_ = 1;
  clear_has_cls_coeff();
}
inline float ClsLocLossParameter::cls_coeff() const {
  return cls_coeff_;
}
inline void ClsLocLossParameter::set_cls_coeff(float value) {
  set_has_cls_coeff();
  cls_coeff_ = value;
}

// optional float loc_coeff = 2 [default = 1];
inline bool ClsLocLossParameter::has_loc_coeff() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClsLocLossParameter::set_has_loc_coeff() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClsLocLossParameter::clear_has_loc_coeff() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClsLocLossParameter::clear_loc_coeff() {
  loc_coeff_ = 1;
  clear_has_loc_coeff();
}
inline float ClsLocLossParameter::loc_coeff() const {
  return loc_coeff_;
}
inline void ClsLocLossParameter::set_loc_coeff(float value) {
  set_has_loc_coeff();
  loc_coeff_ = value;
}

// optional .caffepro.ClsLocLossParameter.LocType loc_type = 3 [default = PCR];
inline bool ClsLocLossParameter::has_loc_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClsLocLossParameter::set_has_loc_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ClsLocLossParameter::clear_has_loc_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ClsLocLossParameter::clear_loc_type() {
  loc_type_ = 0;
  clear_has_loc_type();
}
inline ::caffepro::ClsLocLossParameter_LocType ClsLocLossParameter::loc_type() const {
  return static_cast< ::caffepro::ClsLocLossParameter_LocType >(loc_type_);
}
inline void ClsLocLossParameter::set_loc_type(::caffepro::ClsLocLossParameter_LocType value) {
  GOOGLE_DCHECK(::caffepro::ClsLocLossParameter_LocType_IsValid(value));
  set_has_loc_type();
  loc_type_ = value;
}

// optional string user_def_file = 4;
inline bool ClsLocLossParameter::has_user_def_file() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ClsLocLossParameter::set_has_user_def_file() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ClsLocLossParameter::clear_has_user_def_file() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ClsLocLossParameter::clear_user_def_file() {
  if (user_def_file_ != &::google::protobuf::internal::kEmptyString) {
    user_def_file_->clear();
  }
  clear_has_user_def_file();
}
inline const ::std::string& ClsLocLossParameter::user_def_file() const {
  return *user_def_file_;
}
inline void ClsLocLossParameter::set_user_def_file(const ::std::string& value) {
  set_has_user_def_file();
  if (user_def_file_ == &::google::protobuf::internal::kEmptyString) {
    user_def_file_ = new ::std::string;
  }
  user_def_file_->assign(value);
}
inline void ClsLocLossParameter::set_user_def_file(const char* value) {
  set_has_user_def_file();
  if (user_def_file_ == &::google::protobuf::internal::kEmptyString) {
    user_def_file_ = new ::std::string;
  }
  user_def_file_->assign(value);
}
inline void ClsLocLossParameter::set_user_def_file(const char* value, size_t size) {
  set_has_user_def_file();
  if (user_def_file_ == &::google::protobuf::internal::kEmptyString) {
    user_def_file_ = new ::std::string;
  }
  user_def_file_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClsLocLossParameter::mutable_user_def_file() {
  set_has_user_def_file();
  if (user_def_file_ == &::google::protobuf::internal::kEmptyString) {
    user_def_file_ = new ::std::string;
  }
  return user_def_file_;
}
inline ::std::string* ClsLocLossParameter::release_user_def_file() {
  clear_has_user_def_file();
  if (user_def_file_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user_def_file_;
    user_def_file_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .caffepro.ClsLocLossParameter.LossTransform loss_transform = 5 [default = LTRB];
inline bool ClsLocLossParameter::has_loss_transform() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ClsLocLossParameter::set_has_loss_transform() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ClsLocLossParameter::clear_has_loss_transform() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ClsLocLossParameter::clear_loss_transform() {
  loss_transform_ = 0;
  clear_has_loss_transform();
}
inline ::caffepro::ClsLocLossParameter_LossTransform ClsLocLossParameter::loss_transform() const {
  return static_cast< ::caffepro::ClsLocLossParameter_LossTransform >(loss_transform_);
}
inline void ClsLocLossParameter::set_loss_transform(::caffepro::ClsLocLossParameter_LossTransform value) {
  GOOGLE_DCHECK(::caffepro::ClsLocLossParameter_LossTransform_IsValid(value));
  set_has_loss_transform();
  loss_transform_ = value;
}

// optional float assign_reject_iou = 6 [default = 0.2];
inline bool ClsLocLossParameter::has_assign_reject_iou() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ClsLocLossParameter::set_has_assign_reject_iou() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ClsLocLossParameter::clear_has_assign_reject_iou() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ClsLocLossParameter::clear_assign_reject_iou() {
  assign_reject_iou_ = 0.2f;
  clear_has_assign_reject_iou();
}
inline float ClsLocLossParameter::assign_reject_iou() const {
  return assign_reject_iou_;
}
inline void ClsLocLossParameter::set_assign_reject_iou(float value) {
  set_has_assign_reject_iou();
  assign_reject_iou_ = value;
}

// optional float cls_pos_iou = 7 [default = 0.5];
inline bool ClsLocLossParameter::has_cls_pos_iou() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ClsLocLossParameter::set_has_cls_pos_iou() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ClsLocLossParameter::clear_has_cls_pos_iou() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ClsLocLossParameter::clear_cls_pos_iou() {
  cls_pos_iou_ = 0.5f;
  clear_has_cls_pos_iou();
}
inline float ClsLocLossParameter::cls_pos_iou() const {
  return cls_pos_iou_;
}
inline void ClsLocLossParameter::set_cls_pos_iou(float value) {
  set_has_cls_pos_iou();
  cls_pos_iou_ = value;
}

// optional float cls_neg_iou = 8 [default = 0.2];
inline bool ClsLocLossParameter::has_cls_neg_iou() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ClsLocLossParameter::set_has_cls_neg_iou() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ClsLocLossParameter::clear_has_cls_neg_iou() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ClsLocLossParameter::clear_cls_neg_iou() {
  cls_neg_iou_ = 0.2f;
  clear_has_cls_neg_iou();
}
inline float ClsLocLossParameter::cls_neg_iou() const {
  return cls_neg_iou_;
}
inline void ClsLocLossParameter::set_cls_neg_iou(float value) {
  set_has_cls_neg_iou();
  cls_neg_iou_ = value;
}

// optional bool prediction_box_classification = 9 [default = false];
inline bool ClsLocLossParameter::has_prediction_box_classification() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ClsLocLossParameter::set_has_prediction_box_classification() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ClsLocLossParameter::clear_has_prediction_box_classification() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ClsLocLossParameter::clear_prediction_box_classification() {
  prediction_box_classification_ = false;
  clear_has_prediction_box_classification();
}
inline bool ClsLocLossParameter::prediction_box_classification() const {
  return prediction_box_classification_;
}
inline void ClsLocLossParameter::set_prediction_box_classification(bool value) {
  set_has_prediction_box_classification();
  prediction_box_classification_ = value;
}

// optional bool auto_spatial_anchor = 10 [default = false];
inline bool ClsLocLossParameter::has_auto_spatial_anchor() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ClsLocLossParameter::set_has_auto_spatial_anchor() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ClsLocLossParameter::clear_has_auto_spatial_anchor() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ClsLocLossParameter::clear_auto_spatial_anchor() {
  auto_spatial_anchor_ = false;
  clear_has_auto_spatial_anchor();
}
inline bool ClsLocLossParameter::auto_spatial_anchor() const {
  return auto_spatial_anchor_;
}
inline void ClsLocLossParameter::set_auto_spatial_anchor(bool value) {
  set_has_auto_spatial_anchor();
  auto_spatial_anchor_ = value;
}

// optional int32 expected_pos_num = 11 [default = -1];
inline bool ClsLocLossParameter::has_expected_pos_num() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ClsLocLossParameter::set_has_expected_pos_num() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ClsLocLossParameter::clear_has_expected_pos_num() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ClsLocLossParameter::clear_expected_pos_num() {
  expected_pos_num_ = -1;
  clear_has_expected_pos_num();
}
inline ::google::protobuf::int32 ClsLocLossParameter::expected_pos_num() const {
  return expected_pos_num_;
}
inline void ClsLocLossParameter::set_expected_pos_num(::google::protobuf::int32 value) {
  set_has_expected_pos_num();
  expected_pos_num_ = value;
}

// optional int32 expected_neg_num = 12 [default = -1];
inline bool ClsLocLossParameter::has_expected_neg_num() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void ClsLocLossParameter::set_has_expected_neg_num() {
  _has_bits_[0] |= 0x00000800u;
}
inline void ClsLocLossParameter::clear_has_expected_neg_num() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void ClsLocLossParameter::clear_expected_neg_num() {
  expected_neg_num_ = -1;
  clear_has_expected_neg_num();
}
inline ::google::protobuf::int32 ClsLocLossParameter::expected_neg_num() const {
  return expected_neg_num_;
}
inline void ClsLocLossParameter::set_expected_neg_num(::google::protobuf::int32 value) {
  set_has_expected_neg_num();
  expected_neg_num_ = value;
}

// -------------------------------------------------------------------

// InnerProductParameter

// optional uint32 num_output = 1;
inline bool InnerProductParameter::has_num_output() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InnerProductParameter::set_has_num_output() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InnerProductParameter::clear_has_num_output() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InnerProductParameter::clear_num_output() {
  num_output_ = 0u;
  clear_has_num_output();
}
inline ::google::protobuf::uint32 InnerProductParameter::num_output() const {
  return num_output_;
}
inline void InnerProductParameter::set_num_output(::google::protobuf::uint32 value) {
  set_has_num_output();
  num_output_ = value;
}

// optional bool bias_term = 2 [default = true];
inline bool InnerProductParameter::has_bias_term() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InnerProductParameter::set_has_bias_term() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InnerProductParameter::clear_has_bias_term() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InnerProductParameter::clear_bias_term() {
  bias_term_ = true;
  clear_has_bias_term();
}
inline bool InnerProductParameter::bias_term() const {
  return bias_term_;
}
inline void InnerProductParameter::set_bias_term(bool value) {
  set_has_bias_term();
  bias_term_ = value;
}

// optional .caffepro.FillerParameter weight_filler = 3;
inline bool InnerProductParameter::has_weight_filler() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InnerProductParameter::set_has_weight_filler() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InnerProductParameter::clear_has_weight_filler() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InnerProductParameter::clear_weight_filler() {
  if (weight_filler_ != NULL) weight_filler_->::caffepro::FillerParameter::Clear();
  clear_has_weight_filler();
}
inline const ::caffepro::FillerParameter& InnerProductParameter::weight_filler() const {
  return weight_filler_ != NULL ? *weight_filler_ : *default_instance_->weight_filler_;
}
inline ::caffepro::FillerParameter* InnerProductParameter::mutable_weight_filler() {
  set_has_weight_filler();
  if (weight_filler_ == NULL) weight_filler_ = new ::caffepro::FillerParameter;
  return weight_filler_;
}
inline ::caffepro::FillerParameter* InnerProductParameter::release_weight_filler() {
  clear_has_weight_filler();
  ::caffepro::FillerParameter* temp = weight_filler_;
  weight_filler_ = NULL;
  return temp;
}

// optional .caffepro.FillerParameter bias_filler = 4;
inline bool InnerProductParameter::has_bias_filler() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void InnerProductParameter::set_has_bias_filler() {
  _has_bits_[0] |= 0x00000008u;
}
inline void InnerProductParameter::clear_has_bias_filler() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void InnerProductParameter::clear_bias_filler() {
  if (bias_filler_ != NULL) bias_filler_->::caffepro::FillerParameter::Clear();
  clear_has_bias_filler();
}
inline const ::caffepro::FillerParameter& InnerProductParameter::bias_filler() const {
  return bias_filler_ != NULL ? *bias_filler_ : *default_instance_->bias_filler_;
}
inline ::caffepro::FillerParameter* InnerProductParameter::mutable_bias_filler() {
  set_has_bias_filler();
  if (bias_filler_ == NULL) bias_filler_ = new ::caffepro::FillerParameter;
  return bias_filler_;
}
inline ::caffepro::FillerParameter* InnerProductParameter::release_bias_filler() {
  clear_has_bias_filler();
  ::caffepro::FillerParameter* temp = bias_filler_;
  bias_filler_ = NULL;
  return temp;
}

// optional bool update_inplace = 5 [default = false];
inline bool InnerProductParameter::has_update_inplace() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void InnerProductParameter::set_has_update_inplace() {
  _has_bits_[0] |= 0x00000010u;
}
inline void InnerProductParameter::clear_has_update_inplace() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void InnerProductParameter::clear_update_inplace() {
  update_inplace_ = false;
  clear_has_update_inplace();
}
inline bool InnerProductParameter::update_inplace() const {
  return update_inplace_;
}
inline void InnerProductParameter::set_update_inplace(bool value) {
  set_has_update_inplace();
  update_inplace_ = value;
}

// -------------------------------------------------------------------

// LRNParameter

// optional uint32 local_size = 1 [default = 5];
inline bool LRNParameter::has_local_size() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LRNParameter::set_has_local_size() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LRNParameter::clear_has_local_size() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LRNParameter::clear_local_size() {
  local_size_ = 5u;
  clear_has_local_size();
}
inline ::google::protobuf::uint32 LRNParameter::local_size() const {
  return local_size_;
}
inline void LRNParameter::set_local_size(::google::protobuf::uint32 value) {
  set_has_local_size();
  local_size_ = value;
}

// optional float alpha = 2 [default = 1];
inline bool LRNParameter::has_alpha() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LRNParameter::set_has_alpha() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LRNParameter::clear_has_alpha() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LRNParameter::clear_alpha() {
  alpha_ = 1;
  clear_has_alpha();
}
inline float LRNParameter::alpha() const {
  return alpha_;
}
inline void LRNParameter::set_alpha(float value) {
  set_has_alpha();
  alpha_ = value;
}

// optional float beta = 3 [default = 0.75];
inline bool LRNParameter::has_beta() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LRNParameter::set_has_beta() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LRNParameter::clear_has_beta() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LRNParameter::clear_beta() {
  beta_ = 0.75f;
  clear_has_beta();
}
inline float LRNParameter::beta() const {
  return beta_;
}
inline void LRNParameter::set_beta(float value) {
  set_has_beta();
  beta_ = value;
}

// optional .caffepro.LRNParameter.NormRegion norm_region = 4 [default = ACROSS_CHANNELS];
inline bool LRNParameter::has_norm_region() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LRNParameter::set_has_norm_region() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LRNParameter::clear_has_norm_region() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LRNParameter::clear_norm_region() {
  norm_region_ = 0;
  clear_has_norm_region();
}
inline ::caffepro::LRNParameter_NormRegion LRNParameter::norm_region() const {
  return static_cast< ::caffepro::LRNParameter_NormRegion >(norm_region_);
}
inline void LRNParameter::set_norm_region(::caffepro::LRNParameter_NormRegion value) {
  GOOGLE_DCHECK(::caffepro::LRNParameter_NormRegion_IsValid(value));
  set_has_norm_region();
  norm_region_ = value;
}

// -------------------------------------------------------------------

// PoolingParameter

// optional .caffepro.PoolingParameter.PoolMethod pool = 1 [default = MAX];
inline bool PoolingParameter::has_pool() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PoolingParameter::set_has_pool() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PoolingParameter::clear_has_pool() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PoolingParameter::clear_pool() {
  pool_ = 0;
  clear_has_pool();
}
inline ::caffepro::PoolingParameter_PoolMethod PoolingParameter::pool() const {
  return static_cast< ::caffepro::PoolingParameter_PoolMethod >(pool_);
}
inline void PoolingParameter::set_pool(::caffepro::PoolingParameter_PoolMethod value) {
  GOOGLE_DCHECK(::caffepro::PoolingParameter_PoolMethod_IsValid(value));
  set_has_pool();
  pool_ = value;
}

// optional uint32 kernel_size = 2;
inline bool PoolingParameter::has_kernel_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PoolingParameter::set_has_kernel_size() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PoolingParameter::clear_has_kernel_size() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PoolingParameter::clear_kernel_size() {
  kernel_size_ = 0u;
  clear_has_kernel_size();
}
inline ::google::protobuf::uint32 PoolingParameter::kernel_size() const {
  return kernel_size_;
}
inline void PoolingParameter::set_kernel_size(::google::protobuf::uint32 value) {
  set_has_kernel_size();
  kernel_size_ = value;
}

// optional uint32 stride = 3 [default = 1];
inline bool PoolingParameter::has_stride() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PoolingParameter::set_has_stride() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PoolingParameter::clear_has_stride() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PoolingParameter::clear_stride() {
  stride_ = 1u;
  clear_has_stride();
}
inline ::google::protobuf::uint32 PoolingParameter::stride() const {
  return stride_;
}
inline void PoolingParameter::set_stride(::google::protobuf::uint32 value) {
  set_has_stride();
  stride_ = value;
}

// optional bool size_floor = 4 [default = false];
inline bool PoolingParameter::has_size_floor() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PoolingParameter::set_has_size_floor() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PoolingParameter::clear_has_size_floor() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PoolingParameter::clear_size_floor() {
  size_floor_ = false;
  clear_has_size_floor();
}
inline bool PoolingParameter::size_floor() const {
  return size_floor_;
}
inline void PoolingParameter::set_size_floor(bool value) {
  set_has_size_floor();
  size_floor_ = value;
}

// optional int32 pad = 5 [default = 0];
inline bool PoolingParameter::has_pad() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PoolingParameter::set_has_pad() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PoolingParameter::clear_has_pad() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PoolingParameter::clear_pad() {
  pad_ = 0;
  clear_has_pad();
}
inline ::google::protobuf::int32 PoolingParameter::pad() const {
  return pad_;
}
inline void PoolingParameter::set_pad(::google::protobuf::int32 value) {
  set_has_pad();
  pad_ = value;
}

// optional int32 pad_x = 6 [default = 0];
inline bool PoolingParameter::has_pad_x() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PoolingParameter::set_has_pad_x() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PoolingParameter::clear_has_pad_x() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PoolingParameter::clear_pad_x() {
  pad_x_ = 0;
  clear_has_pad_x();
}
inline ::google::protobuf::int32 PoolingParameter::pad_x() const {
  return pad_x_;
}
inline void PoolingParameter::set_pad_x(::google::protobuf::int32 value) {
  set_has_pad_x();
  pad_x_ = value;
}

// optional int32 pad_y = 7 [default = 0];
inline bool PoolingParameter::has_pad_y() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PoolingParameter::set_has_pad_y() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PoolingParameter::clear_has_pad_y() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PoolingParameter::clear_pad_y() {
  pad_y_ = 0;
  clear_has_pad_y();
}
inline ::google::protobuf::int32 PoolingParameter::pad_y() const {
  return pad_y_;
}
inline void PoolingParameter::set_pad_y(::google::protobuf::int32 value) {
  set_has_pad_y();
  pad_y_ = value;
}

// optional int32 kernel_size_x = 8 [default = 0];
inline bool PoolingParameter::has_kernel_size_x() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void PoolingParameter::set_has_kernel_size_x() {
  _has_bits_[0] |= 0x00000080u;
}
inline void PoolingParameter::clear_has_kernel_size_x() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void PoolingParameter::clear_kernel_size_x() {
  kernel_size_x_ = 0;
  clear_has_kernel_size_x();
}
inline ::google::protobuf::int32 PoolingParameter::kernel_size_x() const {
  return kernel_size_x_;
}
inline void PoolingParameter::set_kernel_size_x(::google::protobuf::int32 value) {
  set_has_kernel_size_x();
  kernel_size_x_ = value;
}

// optional int32 kernel_size_y = 9 [default = 0];
inline bool PoolingParameter::has_kernel_size_y() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void PoolingParameter::set_has_kernel_size_y() {
  _has_bits_[0] |= 0x00000100u;
}
inline void PoolingParameter::clear_has_kernel_size_y() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void PoolingParameter::clear_kernel_size_y() {
  kernel_size_y_ = 0;
  clear_has_kernel_size_y();
}
inline ::google::protobuf::int32 PoolingParameter::kernel_size_y() const {
  return kernel_size_y_;
}
inline void PoolingParameter::set_kernel_size_y(::google::protobuf::int32 value) {
  set_has_kernel_size_y();
  kernel_size_y_ = value;
}

// optional int32 stride_x = 10 [default = 1];
inline bool PoolingParameter::has_stride_x() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void PoolingParameter::set_has_stride_x() {
  _has_bits_[0] |= 0x00000200u;
}
inline void PoolingParameter::clear_has_stride_x() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void PoolingParameter::clear_stride_x() {
  stride_x_ = 1;
  clear_has_stride_x();
}
inline ::google::protobuf::int32 PoolingParameter::stride_x() const {
  return stride_x_;
}
inline void PoolingParameter::set_stride_x(::google::protobuf::int32 value) {
  set_has_stride_x();
  stride_x_ = value;
}

// optional int32 stride_y = 11 [default = 1];
inline bool PoolingParameter::has_stride_y() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void PoolingParameter::set_has_stride_y() {
  _has_bits_[0] |= 0x00000400u;
}
inline void PoolingParameter::clear_has_stride_y() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void PoolingParameter::clear_stride_y() {
  stride_y_ = 1;
  clear_has_stride_y();
}
inline ::google::protobuf::int32 PoolingParameter::stride_y() const {
  return stride_y_;
}
inline void PoolingParameter::set_stride_y(::google::protobuf::int32 value) {
  set_has_stride_y();
  stride_y_ = value;
}

// -------------------------------------------------------------------

// SPMParameter

// optional .caffepro.SPMParameter.PoolMethod pool = 1 [default = MAX];
inline bool SPMParameter::has_pool() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SPMParameter::set_has_pool() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SPMParameter::clear_has_pool() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SPMParameter::clear_pool() {
  pool_ = 0;
  clear_has_pool();
}
inline ::caffepro::SPMParameter_PoolMethod SPMParameter::pool() const {
  return static_cast< ::caffepro::SPMParameter_PoolMethod >(pool_);
}
inline void SPMParameter::set_pool(::caffepro::SPMParameter_PoolMethod value) {
  GOOGLE_DCHECK(::caffepro::SPMParameter_PoolMethod_IsValid(value));
  set_has_pool();
  pool_ = value;
}

// optional uint32 cell_x = 2;
inline bool SPMParameter::has_cell_x() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SPMParameter::set_has_cell_x() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SPMParameter::clear_has_cell_x() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SPMParameter::clear_cell_x() {
  cell_x_ = 0u;
  clear_has_cell_x();
}
inline ::google::protobuf::uint32 SPMParameter::cell_x() const {
  return cell_x_;
}
inline void SPMParameter::set_cell_x(::google::protobuf::uint32 value) {
  set_has_cell_x();
  cell_x_ = value;
}

// optional uint32 cell_y = 3;
inline bool SPMParameter::has_cell_y() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SPMParameter::set_has_cell_y() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SPMParameter::clear_has_cell_y() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SPMParameter::clear_cell_y() {
  cell_y_ = 0u;
  clear_has_cell_y();
}
inline ::google::protobuf::uint32 SPMParameter::cell_y() const {
  return cell_y_;
}
inline void SPMParameter::set_cell_y(::google::protobuf::uint32 value) {
  set_has_cell_y();
  cell_y_ = value;
}

// -------------------------------------------------------------------

// PowerParameter

// optional float power = 1 [default = 1];
inline bool PowerParameter::has_power() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PowerParameter::set_has_power() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PowerParameter::clear_has_power() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PowerParameter::clear_power() {
  power_ = 1;
  clear_has_power();
}
inline float PowerParameter::power() const {
  return power_;
}
inline void PowerParameter::set_power(float value) {
  set_has_power();
  power_ = value;
}

// optional float scale = 2 [default = 1];
inline bool PowerParameter::has_scale() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PowerParameter::set_has_scale() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PowerParameter::clear_has_scale() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PowerParameter::clear_scale() {
  scale_ = 1;
  clear_has_scale();
}
inline float PowerParameter::scale() const {
  return scale_;
}
inline void PowerParameter::set_scale(float value) {
  set_has_scale();
  scale_ = value;
}

// optional float shift = 3 [default = 0];
inline bool PowerParameter::has_shift() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PowerParameter::set_has_shift() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PowerParameter::clear_has_shift() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PowerParameter::clear_shift() {
  shift_ = 0;
  clear_has_shift();
}
inline float PowerParameter::shift() const {
  return shift_;
}
inline void PowerParameter::set_shift(float value) {
  set_has_shift();
  shift_ = value;
}

// -------------------------------------------------------------------

// LayerConnection

// optional .caffepro.LayerParameter layer = 1;
inline bool LayerConnection::has_layer() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LayerConnection::set_has_layer() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LayerConnection::clear_has_layer() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LayerConnection::clear_layer() {
  if (layer_ != NULL) layer_->::caffepro::LayerParameter::Clear();
  clear_has_layer();
}
inline const ::caffepro::LayerParameter& LayerConnection::layer() const {
  return layer_ != NULL ? *layer_ : *default_instance_->layer_;
}
inline ::caffepro::LayerParameter* LayerConnection::mutable_layer() {
  set_has_layer();
  if (layer_ == NULL) layer_ = new ::caffepro::LayerParameter;
  return layer_;
}
inline ::caffepro::LayerParameter* LayerConnection::release_layer() {
  clear_has_layer();
  ::caffepro::LayerParameter* temp = layer_;
  layer_ = NULL;
  return temp;
}

// repeated string bottom = 2;
inline int LayerConnection::bottom_size() const {
  return bottom_.size();
}
inline void LayerConnection::clear_bottom() {
  bottom_.Clear();
}
inline const ::std::string& LayerConnection::bottom(int index) const {
  return bottom_.Get(index);
}
inline ::std::string* LayerConnection::mutable_bottom(int index) {
  return bottom_.Mutable(index);
}
inline void LayerConnection::set_bottom(int index, const ::std::string& value) {
  bottom_.Mutable(index)->assign(value);
}
inline void LayerConnection::set_bottom(int index, const char* value) {
  bottom_.Mutable(index)->assign(value);
}
inline void LayerConnection::set_bottom(int index, const char* value, size_t size) {
  bottom_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LayerConnection::add_bottom() {
  return bottom_.Add();
}
inline void LayerConnection::add_bottom(const ::std::string& value) {
  bottom_.Add()->assign(value);
}
inline void LayerConnection::add_bottom(const char* value) {
  bottom_.Add()->assign(value);
}
inline void LayerConnection::add_bottom(const char* value, size_t size) {
  bottom_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
LayerConnection::bottom() const {
  return bottom_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
LayerConnection::mutable_bottom() {
  return &bottom_;
}

// repeated string top = 3;
inline int LayerConnection::top_size() const {
  return top_.size();
}
inline void LayerConnection::clear_top() {
  top_.Clear();
}
inline const ::std::string& LayerConnection::top(int index) const {
  return top_.Get(index);
}
inline ::std::string* LayerConnection::mutable_top(int index) {
  return top_.Mutable(index);
}
inline void LayerConnection::set_top(int index, const ::std::string& value) {
  top_.Mutable(index)->assign(value);
}
inline void LayerConnection::set_top(int index, const char* value) {
  top_.Mutable(index)->assign(value);
}
inline void LayerConnection::set_top(int index, const char* value, size_t size) {
  top_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LayerConnection::add_top() {
  return top_.Add();
}
inline void LayerConnection::add_top(const ::std::string& value) {
  top_.Add()->assign(value);
}
inline void LayerConnection::add_top(const char* value) {
  top_.Add()->assign(value);
}
inline void LayerConnection::add_top(const char* value, size_t size) {
  top_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
LayerConnection::top() const {
  return top_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
LayerConnection::mutable_top() {
  return &top_;
}

// -------------------------------------------------------------------

// NetParameter

// optional string name = 1;
inline bool NetParameter::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NetParameter::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NetParameter::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NetParameter::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& NetParameter::name() const {
  return *name_;
}
inline void NetParameter::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void NetParameter::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void NetParameter::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NetParameter::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* NetParameter::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .caffepro.LayerConnection layers = 2;
inline int NetParameter::layers_size() const {
  return layers_.size();
}
inline void NetParameter::clear_layers() {
  layers_.Clear();
}
inline const ::caffepro::LayerConnection& NetParameter::layers(int index) const {
  return layers_.Get(index);
}
inline ::caffepro::LayerConnection* NetParameter::mutable_layers(int index) {
  return layers_.Mutable(index);
}
inline ::caffepro::LayerConnection* NetParameter::add_layers() {
  return layers_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::caffepro::LayerConnection >&
NetParameter::layers() const {
  return layers_;
}
inline ::google::protobuf::RepeatedPtrField< ::caffepro::LayerConnection >*
NetParameter::mutable_layers() {
  return &layers_;
}

// repeated string input = 3;
inline int NetParameter::input_size() const {
  return input_.size();
}
inline void NetParameter::clear_input() {
  input_.Clear();
}
inline const ::std::string& NetParameter::input(int index) const {
  return input_.Get(index);
}
inline ::std::string* NetParameter::mutable_input(int index) {
  return input_.Mutable(index);
}
inline void NetParameter::set_input(int index, const ::std::string& value) {
  input_.Mutable(index)->assign(value);
}
inline void NetParameter::set_input(int index, const char* value) {
  input_.Mutable(index)->assign(value);
}
inline void NetParameter::set_input(int index, const char* value, size_t size) {
  input_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NetParameter::add_input() {
  return input_.Add();
}
inline void NetParameter::add_input(const ::std::string& value) {
  input_.Add()->assign(value);
}
inline void NetParameter::add_input(const char* value) {
  input_.Add()->assign(value);
}
inline void NetParameter::add_input(const char* value, size_t size) {
  input_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
NetParameter::input() const {
  return input_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
NetParameter::mutable_input() {
  return &input_;
}

// repeated int32 input_dim = 4;
inline int NetParameter::input_dim_size() const {
  return input_dim_.size();
}
inline void NetParameter::clear_input_dim() {
  input_dim_.Clear();
}
inline ::google::protobuf::int32 NetParameter::input_dim(int index) const {
  return input_dim_.Get(index);
}
inline void NetParameter::set_input_dim(int index, ::google::protobuf::int32 value) {
  input_dim_.Set(index, value);
}
inline void NetParameter::add_input_dim(::google::protobuf::int32 value) {
  input_dim_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
NetParameter::input_dim() const {
  return input_dim_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
NetParameter::mutable_input_dim() {
  return &input_dim_;
}

// optional bool force_backward = 5 [default = false];
inline bool NetParameter::has_force_backward() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void NetParameter::set_has_force_backward() {
  _has_bits_[0] |= 0x00000010u;
}
inline void NetParameter::clear_has_force_backward() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void NetParameter::clear_force_backward() {
  force_backward_ = false;
  clear_has_force_backward();
}
inline bool NetParameter::force_backward() const {
  return force_backward_;
}
inline void NetParameter::set_force_backward(bool value) {
  set_has_force_backward();
  force_backward_ = value;
}

// optional string config_file = 6;
inline bool NetParameter::has_config_file() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void NetParameter::set_has_config_file() {
  _has_bits_[0] |= 0x00000020u;
}
inline void NetParameter::clear_has_config_file() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void NetParameter::clear_config_file() {
  if (config_file_ != &::google::protobuf::internal::kEmptyString) {
    config_file_->clear();
  }
  clear_has_config_file();
}
inline const ::std::string& NetParameter::config_file() const {
  return *config_file_;
}
inline void NetParameter::set_config_file(const ::std::string& value) {
  set_has_config_file();
  if (config_file_ == &::google::protobuf::internal::kEmptyString) {
    config_file_ = new ::std::string;
  }
  config_file_->assign(value);
}
inline void NetParameter::set_config_file(const char* value) {
  set_has_config_file();
  if (config_file_ == &::google::protobuf::internal::kEmptyString) {
    config_file_ = new ::std::string;
  }
  config_file_->assign(value);
}
inline void NetParameter::set_config_file(const char* value, size_t size) {
  set_has_config_file();
  if (config_file_ == &::google::protobuf::internal::kEmptyString) {
    config_file_ = new ::std::string;
  }
  config_file_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NetParameter::mutable_config_file() {
  set_has_config_file();
  if (config_file_ == &::google::protobuf::internal::kEmptyString) {
    config_file_ = new ::std::string;
  }
  return config_file_;
}
inline ::std::string* NetParameter::release_config_file() {
  clear_has_config_file();
  if (config_file_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = config_file_;
    config_file_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string data_provider_name = 7;
inline bool NetParameter::has_data_provider_name() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void NetParameter::set_has_data_provider_name() {
  _has_bits_[0] |= 0x00000040u;
}
inline void NetParameter::clear_has_data_provider_name() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void NetParameter::clear_data_provider_name() {
  if (data_provider_name_ != &::google::protobuf::internal::kEmptyString) {
    data_provider_name_->clear();
  }
  clear_has_data_provider_name();
}
inline const ::std::string& NetParameter::data_provider_name() const {
  return *data_provider_name_;
}
inline void NetParameter::set_data_provider_name(const ::std::string& value) {
  set_has_data_provider_name();
  if (data_provider_name_ == &::google::protobuf::internal::kEmptyString) {
    data_provider_name_ = new ::std::string;
  }
  data_provider_name_->assign(value);
}
inline void NetParameter::set_data_provider_name(const char* value) {
  set_has_data_provider_name();
  if (data_provider_name_ == &::google::protobuf::internal::kEmptyString) {
    data_provider_name_ = new ::std::string;
  }
  data_provider_name_->assign(value);
}
inline void NetParameter::set_data_provider_name(const char* value, size_t size) {
  set_has_data_provider_name();
  if (data_provider_name_ == &::google::protobuf::internal::kEmptyString) {
    data_provider_name_ = new ::std::string;
  }
  data_provider_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NetParameter::mutable_data_provider_name() {
  set_has_data_provider_name();
  if (data_provider_name_ == &::google::protobuf::internal::kEmptyString) {
    data_provider_name_ = new ::std::string;
  }
  return data_provider_name_;
}
inline ::std::string* NetParameter::release_data_provider_name() {
  clear_has_data_provider_name();
  if (data_provider_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = data_provider_name_;
    data_provider_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// SolverParameter

// optional string train_net = 1;
inline bool SolverParameter::has_train_net() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SolverParameter::set_has_train_net() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SolverParameter::clear_has_train_net() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SolverParameter::clear_train_net() {
  if (train_net_ != &::google::protobuf::internal::kEmptyString) {
    train_net_->clear();
  }
  clear_has_train_net();
}
inline const ::std::string& SolverParameter::train_net() const {
  return *train_net_;
}
inline void SolverParameter::set_train_net(const ::std::string& value) {
  set_has_train_net();
  if (train_net_ == &::google::protobuf::internal::kEmptyString) {
    train_net_ = new ::std::string;
  }
  train_net_->assign(value);
}
inline void SolverParameter::set_train_net(const char* value) {
  set_has_train_net();
  if (train_net_ == &::google::protobuf::internal::kEmptyString) {
    train_net_ = new ::std::string;
  }
  train_net_->assign(value);
}
inline void SolverParameter::set_train_net(const char* value, size_t size) {
  set_has_train_net();
  if (train_net_ == &::google::protobuf::internal::kEmptyString) {
    train_net_ = new ::std::string;
  }
  train_net_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SolverParameter::mutable_train_net() {
  set_has_train_net();
  if (train_net_ == &::google::protobuf::internal::kEmptyString) {
    train_net_ = new ::std::string;
  }
  return train_net_;
}
inline ::std::string* SolverParameter::release_train_net() {
  clear_has_train_net();
  if (train_net_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = train_net_;
    train_net_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string test_net = 2;
inline bool SolverParameter::has_test_net() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SolverParameter::set_has_test_net() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SolverParameter::clear_has_test_net() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SolverParameter::clear_test_net() {
  if (test_net_ != &::google::protobuf::internal::kEmptyString) {
    test_net_->clear();
  }
  clear_has_test_net();
}
inline const ::std::string& SolverParameter::test_net() const {
  return *test_net_;
}
inline void SolverParameter::set_test_net(const ::std::string& value) {
  set_has_test_net();
  if (test_net_ == &::google::protobuf::internal::kEmptyString) {
    test_net_ = new ::std::string;
  }
  test_net_->assign(value);
}
inline void SolverParameter::set_test_net(const char* value) {
  set_has_test_net();
  if (test_net_ == &::google::protobuf::internal::kEmptyString) {
    test_net_ = new ::std::string;
  }
  test_net_->assign(value);
}
inline void SolverParameter::set_test_net(const char* value, size_t size) {
  set_has_test_net();
  if (test_net_ == &::google::protobuf::internal::kEmptyString) {
    test_net_ = new ::std::string;
  }
  test_net_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SolverParameter::mutable_test_net() {
  set_has_test_net();
  if (test_net_ == &::google::protobuf::internal::kEmptyString) {
    test_net_ = new ::std::string;
  }
  return test_net_;
}
inline ::std::string* SolverParameter::release_test_net() {
  clear_has_test_net();
  if (test_net_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = test_net_;
    test_net_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 test_iter = 3 [default = 0];
inline bool SolverParameter::has_test_iter() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SolverParameter::set_has_test_iter() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SolverParameter::clear_has_test_iter() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SolverParameter::clear_test_iter() {
  test_iter_ = 0;
  clear_has_test_iter();
}
inline ::google::protobuf::int32 SolverParameter::test_iter() const {
  return test_iter_;
}
inline void SolverParameter::set_test_iter(::google::protobuf::int32 value) {
  set_has_test_iter();
  test_iter_ = value;
}

// optional int32 test_interval = 4 [default = 0];
inline bool SolverParameter::has_test_interval() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SolverParameter::set_has_test_interval() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SolverParameter::clear_has_test_interval() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SolverParameter::clear_test_interval() {
  test_interval_ = 0;
  clear_has_test_interval();
}
inline ::google::protobuf::int32 SolverParameter::test_interval() const {
  return test_interval_;
}
inline void SolverParameter::set_test_interval(::google::protobuf::int32 value) {
  set_has_test_interval();
  test_interval_ = value;
}

// optional float base_lr = 5;
inline bool SolverParameter::has_base_lr() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SolverParameter::set_has_base_lr() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SolverParameter::clear_has_base_lr() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SolverParameter::clear_base_lr() {
  base_lr_ = 0;
  clear_has_base_lr();
}
inline float SolverParameter::base_lr() const {
  return base_lr_;
}
inline void SolverParameter::set_base_lr(float value) {
  set_has_base_lr();
  base_lr_ = value;
}

// optional int32 display = 6;
inline bool SolverParameter::has_display() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SolverParameter::set_has_display() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SolverParameter::clear_has_display() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SolverParameter::clear_display() {
  display_ = 0;
  clear_has_display();
}
inline ::google::protobuf::int32 SolverParameter::display() const {
  return display_;
}
inline void SolverParameter::set_display(::google::protobuf::int32 value) {
  set_has_display();
  display_ = value;
}

// optional int32 max_iter = 7;
inline bool SolverParameter::has_max_iter() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SolverParameter::set_has_max_iter() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SolverParameter::clear_has_max_iter() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SolverParameter::clear_max_iter() {
  max_iter_ = 0;
  clear_has_max_iter();
}
inline ::google::protobuf::int32 SolverParameter::max_iter() const {
  return max_iter_;
}
inline void SolverParameter::set_max_iter(::google::protobuf::int32 value) {
  set_has_max_iter();
  max_iter_ = value;
}

// optional string lr_policy = 8;
inline bool SolverParameter::has_lr_policy() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SolverParameter::set_has_lr_policy() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SolverParameter::clear_has_lr_policy() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SolverParameter::clear_lr_policy() {
  if (lr_policy_ != &::google::protobuf::internal::kEmptyString) {
    lr_policy_->clear();
  }
  clear_has_lr_policy();
}
inline const ::std::string& SolverParameter::lr_policy() const {
  return *lr_policy_;
}
inline void SolverParameter::set_lr_policy(const ::std::string& value) {
  set_has_lr_policy();
  if (lr_policy_ == &::google::protobuf::internal::kEmptyString) {
    lr_policy_ = new ::std::string;
  }
  lr_policy_->assign(value);
}
inline void SolverParameter::set_lr_policy(const char* value) {
  set_has_lr_policy();
  if (lr_policy_ == &::google::protobuf::internal::kEmptyString) {
    lr_policy_ = new ::std::string;
  }
  lr_policy_->assign(value);
}
inline void SolverParameter::set_lr_policy(const char* value, size_t size) {
  set_has_lr_policy();
  if (lr_policy_ == &::google::protobuf::internal::kEmptyString) {
    lr_policy_ = new ::std::string;
  }
  lr_policy_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SolverParameter::mutable_lr_policy() {
  set_has_lr_policy();
  if (lr_policy_ == &::google::protobuf::internal::kEmptyString) {
    lr_policy_ = new ::std::string;
  }
  return lr_policy_;
}
inline ::std::string* SolverParameter::release_lr_policy() {
  clear_has_lr_policy();
  if (lr_policy_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = lr_policy_;
    lr_policy_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional float gamma = 9;
inline bool SolverParameter::has_gamma() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void SolverParameter::set_has_gamma() {
  _has_bits_[0] |= 0x00000100u;
}
inline void SolverParameter::clear_has_gamma() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void SolverParameter::clear_gamma() {
  gamma_ = 0;
  clear_has_gamma();
}
inline float SolverParameter::gamma() const {
  return gamma_;
}
inline void SolverParameter::set_gamma(float value) {
  set_has_gamma();
  gamma_ = value;
}

// optional float power = 10;
inline bool SolverParameter::has_power() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void SolverParameter::set_has_power() {
  _has_bits_[0] |= 0x00000200u;
}
inline void SolverParameter::clear_has_power() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void SolverParameter::clear_power() {
  power_ = 0;
  clear_has_power();
}
inline float SolverParameter::power() const {
  return power_;
}
inline void SolverParameter::set_power(float value) {
  set_has_power();
  power_ = value;
}

// optional float momentum = 11;
inline bool SolverParameter::has_momentum() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void SolverParameter::set_has_momentum() {
  _has_bits_[0] |= 0x00000400u;
}
inline void SolverParameter::clear_has_momentum() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void SolverParameter::clear_momentum() {
  momentum_ = 0;
  clear_has_momentum();
}
inline float SolverParameter::momentum() const {
  return momentum_;
}
inline void SolverParameter::set_momentum(float value) {
  set_has_momentum();
  momentum_ = value;
}

// optional float weight_decay = 12;
inline bool SolverParameter::has_weight_decay() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void SolverParameter::set_has_weight_decay() {
  _has_bits_[0] |= 0x00000800u;
}
inline void SolverParameter::clear_has_weight_decay() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void SolverParameter::clear_weight_decay() {
  weight_decay_ = 0;
  clear_has_weight_decay();
}
inline float SolverParameter::weight_decay() const {
  return weight_decay_;
}
inline void SolverParameter::set_weight_decay(float value) {
  set_has_weight_decay();
  weight_decay_ = value;
}

// optional int32 stepsize = 13;
inline bool SolverParameter::has_stepsize() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void SolverParameter::set_has_stepsize() {
  _has_bits_[0] |= 0x00001000u;
}
inline void SolverParameter::clear_has_stepsize() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void SolverParameter::clear_stepsize() {
  stepsize_ = 0;
  clear_has_stepsize();
}
inline ::google::protobuf::int32 SolverParameter::stepsize() const {
  return stepsize_;
}
inline void SolverParameter::set_stepsize(::google::protobuf::int32 value) {
  set_has_stepsize();
  stepsize_ = value;
}

// optional int32 snapshot = 14 [default = 0];
inline bool SolverParameter::has_snapshot() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void SolverParameter::set_has_snapshot() {
  _has_bits_[0] |= 0x00002000u;
}
inline void SolverParameter::clear_has_snapshot() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void SolverParameter::clear_snapshot() {
  snapshot_ = 0;
  clear_has_snapshot();
}
inline ::google::protobuf::int32 SolverParameter::snapshot() const {
  return snapshot_;
}
inline void SolverParameter::set_snapshot(::google::protobuf::int32 value) {
  set_has_snapshot();
  snapshot_ = value;
}

// optional string snapshot_prefix = 15;
inline bool SolverParameter::has_snapshot_prefix() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void SolverParameter::set_has_snapshot_prefix() {
  _has_bits_[0] |= 0x00004000u;
}
inline void SolverParameter::clear_has_snapshot_prefix() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void SolverParameter::clear_snapshot_prefix() {
  if (snapshot_prefix_ != &::google::protobuf::internal::kEmptyString) {
    snapshot_prefix_->clear();
  }
  clear_has_snapshot_prefix();
}
inline const ::std::string& SolverParameter::snapshot_prefix() const {
  return *snapshot_prefix_;
}
inline void SolverParameter::set_snapshot_prefix(const ::std::string& value) {
  set_has_snapshot_prefix();
  if (snapshot_prefix_ == &::google::protobuf::internal::kEmptyString) {
    snapshot_prefix_ = new ::std::string;
  }
  snapshot_prefix_->assign(value);
}
inline void SolverParameter::set_snapshot_prefix(const char* value) {
  set_has_snapshot_prefix();
  if (snapshot_prefix_ == &::google::protobuf::internal::kEmptyString) {
    snapshot_prefix_ = new ::std::string;
  }
  snapshot_prefix_->assign(value);
}
inline void SolverParameter::set_snapshot_prefix(const char* value, size_t size) {
  set_has_snapshot_prefix();
  if (snapshot_prefix_ == &::google::protobuf::internal::kEmptyString) {
    snapshot_prefix_ = new ::std::string;
  }
  snapshot_prefix_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SolverParameter::mutable_snapshot_prefix() {
  set_has_snapshot_prefix();
  if (snapshot_prefix_ == &::google::protobuf::internal::kEmptyString) {
    snapshot_prefix_ = new ::std::string;
  }
  return snapshot_prefix_;
}
inline ::std::string* SolverParameter::release_snapshot_prefix() {
  clear_has_snapshot_prefix();
  if (snapshot_prefix_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = snapshot_prefix_;
    snapshot_prefix_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bool snapshot_diff = 16 [default = false];
inline bool SolverParameter::has_snapshot_diff() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void SolverParameter::set_has_snapshot_diff() {
  _has_bits_[0] |= 0x00008000u;
}
inline void SolverParameter::clear_has_snapshot_diff() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void SolverParameter::clear_snapshot_diff() {
  snapshot_diff_ = false;
  clear_has_snapshot_diff();
}
inline bool SolverParameter::snapshot_diff() const {
  return snapshot_diff_;
}
inline void SolverParameter::set_snapshot_diff(bool value) {
  set_has_snapshot_diff();
  snapshot_diff_ = value;
}

// optional int32 solver_mode = 17 [default = 1];
inline bool SolverParameter::has_solver_mode() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void SolverParameter::set_has_solver_mode() {
  _has_bits_[0] |= 0x00010000u;
}
inline void SolverParameter::clear_has_solver_mode() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void SolverParameter::clear_solver_mode() {
  solver_mode_ = 1;
  clear_has_solver_mode();
}
inline ::google::protobuf::int32 SolverParameter::solver_mode() const {
  return solver_mode_;
}
inline void SolverParameter::set_solver_mode(::google::protobuf::int32 value) {
  set_has_solver_mode();
  solver_mode_ = value;
}

// optional int32 device_id = 18 [default = 0];
inline bool SolverParameter::has_device_id() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void SolverParameter::set_has_device_id() {
  _has_bits_[0] |= 0x00020000u;
}
inline void SolverParameter::clear_has_device_id() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void SolverParameter::clear_device_id() {
  device_id_ = 0;
  clear_has_device_id();
}
inline ::google::protobuf::int32 SolverParameter::device_id() const {
  return device_id_;
}
inline void SolverParameter::set_device_id(::google::protobuf::int32 value) {
  set_has_device_id();
  device_id_ = value;
}

// repeated float vstep_lr = 19;
inline int SolverParameter::vstep_lr_size() const {
  return vstep_lr_.size();
}
inline void SolverParameter::clear_vstep_lr() {
  vstep_lr_.Clear();
}
inline float SolverParameter::vstep_lr(int index) const {
  return vstep_lr_.Get(index);
}
inline void SolverParameter::set_vstep_lr(int index, float value) {
  vstep_lr_.Set(index, value);
}
inline void SolverParameter::add_vstep_lr(float value) {
  vstep_lr_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
SolverParameter::vstep_lr() const {
  return vstep_lr_;
}
inline ::google::protobuf::RepeatedField< float >*
SolverParameter::mutable_vstep_lr() {
  return &vstep_lr_;
}

// repeated int32 vstep_size = 20;
inline int SolverParameter::vstep_size_size() const {
  return vstep_size_.size();
}
inline void SolverParameter::clear_vstep_size() {
  vstep_size_.Clear();
}
inline ::google::protobuf::int32 SolverParameter::vstep_size(int index) const {
  return vstep_size_.Get(index);
}
inline void SolverParameter::set_vstep_size(int index, ::google::protobuf::int32 value) {
  vstep_size_.Set(index, value);
}
inline void SolverParameter::add_vstep_size(::google::protobuf::int32 value) {
  vstep_size_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
SolverParameter::vstep_size() const {
  return vstep_size_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
SolverParameter::mutable_vstep_size() {
  return &vstep_size_;
}

// optional int32 num_threads = 21 [default = 0];
inline bool SolverParameter::has_num_threads() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void SolverParameter::set_has_num_threads() {
  _has_bits_[0] |= 0x00100000u;
}
inline void SolverParameter::clear_has_num_threads() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void SolverParameter::clear_num_threads() {
  num_threads_ = 0;
  clear_has_num_threads();
}
inline ::google::protobuf::int32 SolverParameter::num_threads() const {
  return num_threads_;
}
inline void SolverParameter::set_num_threads(::google::protobuf::int32 value) {
  set_has_num_threads();
  num_threads_ = value;
}

// optional int32 train_primary_output_index = 22 [default = 0];
inline bool SolverParameter::has_train_primary_output_index() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void SolverParameter::set_has_train_primary_output_index() {
  _has_bits_[0] |= 0x00200000u;
}
inline void SolverParameter::clear_has_train_primary_output_index() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void SolverParameter::clear_train_primary_output_index() {
  train_primary_output_index_ = 0;
  clear_has_train_primary_output_index();
}
inline ::google::protobuf::int32 SolverParameter::train_primary_output_index() const {
  return train_primary_output_index_;
}
inline void SolverParameter::set_train_primary_output_index(::google::protobuf::int32 value) {
  set_has_train_primary_output_index();
  train_primary_output_index_ = value;
}

// optional int32 test_primary_output_index = 23 [default = 0];
inline bool SolverParameter::has_test_primary_output_index() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void SolverParameter::set_has_test_primary_output_index() {
  _has_bits_[0] |= 0x00400000u;
}
inline void SolverParameter::clear_has_test_primary_output_index() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void SolverParameter::clear_test_primary_output_index() {
  test_primary_output_index_ = 0;
  clear_has_test_primary_output_index();
}
inline ::google::protobuf::int32 SolverParameter::test_primary_output_index() const {
  return test_primary_output_index_;
}
inline void SolverParameter::set_test_primary_output_index(::google::protobuf::int32 value) {
  set_has_test_primary_output_index();
  test_primary_output_index_ = value;
}

// optional int32 update_interval = 24 [default = 1];
inline bool SolverParameter::has_update_interval() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void SolverParameter::set_has_update_interval() {
  _has_bits_[0] |= 0x00800000u;
}
inline void SolverParameter::clear_has_update_interval() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void SolverParameter::clear_update_interval() {
  update_interval_ = 1;
  clear_has_update_interval();
}
inline ::google::protobuf::int32 SolverParameter::update_interval() const {
  return update_interval_;
}
inline void SolverParameter::set_update_interval(::google::protobuf::int32 value) {
  set_has_update_interval();
  update_interval_ = value;
}

// optional string ohem_net = 25;
inline bool SolverParameter::has_ohem_net() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void SolverParameter::set_has_ohem_net() {
  _has_bits_[0] |= 0x01000000u;
}
inline void SolverParameter::clear_has_ohem_net() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void SolverParameter::clear_ohem_net() {
  if (ohem_net_ != &::google::protobuf::internal::kEmptyString) {
    ohem_net_->clear();
  }
  clear_has_ohem_net();
}
inline const ::std::string& SolverParameter::ohem_net() const {
  return *ohem_net_;
}
inline void SolverParameter::set_ohem_net(const ::std::string& value) {
  set_has_ohem_net();
  if (ohem_net_ == &::google::protobuf::internal::kEmptyString) {
    ohem_net_ = new ::std::string;
  }
  ohem_net_->assign(value);
}
inline void SolverParameter::set_ohem_net(const char* value) {
  set_has_ohem_net();
  if (ohem_net_ == &::google::protobuf::internal::kEmptyString) {
    ohem_net_ = new ::std::string;
  }
  ohem_net_->assign(value);
}
inline void SolverParameter::set_ohem_net(const char* value, size_t size) {
  set_has_ohem_net();
  if (ohem_net_ == &::google::protobuf::internal::kEmptyString) {
    ohem_net_ = new ::std::string;
  }
  ohem_net_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SolverParameter::mutable_ohem_net() {
  set_has_ohem_net();
  if (ohem_net_ == &::google::protobuf::internal::kEmptyString) {
    ohem_net_ = new ::std::string;
  }
  return ohem_net_;
}
inline ::std::string* SolverParameter::release_ohem_net() {
  clear_has_ohem_net();
  if (ohem_net_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ohem_net_;
    ohem_net_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 dump_interval = 26 [default = 0];
inline bool SolverParameter::has_dump_interval() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void SolverParameter::set_has_dump_interval() {
  _has_bits_[0] |= 0x02000000u;
}
inline void SolverParameter::clear_has_dump_interval() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void SolverParameter::clear_dump_interval() {
  dump_interval_ = 0;
  clear_has_dump_interval();
}
inline ::google::protobuf::int32 SolverParameter::dump_interval() const {
  return dump_interval_;
}
inline void SolverParameter::set_dump_interval(::google::protobuf::int32 value) {
  set_has_dump_interval();
  dump_interval_ = value;
}

// optional int32 sim_update_interval = 27 [default = 1];
inline bool SolverParameter::has_sim_update_interval() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void SolverParameter::set_has_sim_update_interval() {
  _has_bits_[0] |= 0x04000000u;
}
inline void SolverParameter::clear_has_sim_update_interval() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void SolverParameter::clear_sim_update_interval() {
  sim_update_interval_ = 1;
  clear_has_sim_update_interval();
}
inline ::google::protobuf::int32 SolverParameter::sim_update_interval() const {
  return sim_update_interval_;
}
inline void SolverParameter::set_sim_update_interval(::google::protobuf::int32 value) {
  set_has_sim_update_interval();
  sim_update_interval_ = value;
}

// optional bool data_split = 28 [default = false];
inline bool SolverParameter::has_data_split() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void SolverParameter::set_has_data_split() {
  _has_bits_[0] |= 0x08000000u;
}
inline void SolverParameter::clear_has_data_split() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void SolverParameter::clear_data_split() {
  data_split_ = false;
  clear_has_data_split();
}
inline bool SolverParameter::data_split() const {
  return data_split_;
}
inline void SolverParameter::set_data_split(bool value) {
  set_has_data_split();
  data_split_ = value;
}

// optional string bmuf_method = 29;
inline bool SolverParameter::has_bmuf_method() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void SolverParameter::set_has_bmuf_method() {
  _has_bits_[0] |= 0x10000000u;
}
inline void SolverParameter::clear_has_bmuf_method() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void SolverParameter::clear_bmuf_method() {
  if (bmuf_method_ != &::google::protobuf::internal::kEmptyString) {
    bmuf_method_->clear();
  }
  clear_has_bmuf_method();
}
inline const ::std::string& SolverParameter::bmuf_method() const {
  return *bmuf_method_;
}
inline void SolverParameter::set_bmuf_method(const ::std::string& value) {
  set_has_bmuf_method();
  if (bmuf_method_ == &::google::protobuf::internal::kEmptyString) {
    bmuf_method_ = new ::std::string;
  }
  bmuf_method_->assign(value);
}
inline void SolverParameter::set_bmuf_method(const char* value) {
  set_has_bmuf_method();
  if (bmuf_method_ == &::google::protobuf::internal::kEmptyString) {
    bmuf_method_ = new ::std::string;
  }
  bmuf_method_->assign(value);
}
inline void SolverParameter::set_bmuf_method(const char* value, size_t size) {
  set_has_bmuf_method();
  if (bmuf_method_ == &::google::protobuf::internal::kEmptyString) {
    bmuf_method_ = new ::std::string;
  }
  bmuf_method_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SolverParameter::mutable_bmuf_method() {
  set_has_bmuf_method();
  if (bmuf_method_ == &::google::protobuf::internal::kEmptyString) {
    bmuf_method_ = new ::std::string;
  }
  return bmuf_method_;
}
inline ::std::string* SolverParameter::release_bmuf_method() {
  clear_has_bmuf_method();
  if (bmuf_method_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bmuf_method_;
    bmuf_method_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional float bmuf_lr = 30 [default = 1];
inline bool SolverParameter::has_bmuf_lr() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void SolverParameter::set_has_bmuf_lr() {
  _has_bits_[0] |= 0x20000000u;
}
inline void SolverParameter::clear_has_bmuf_lr() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void SolverParameter::clear_bmuf_lr() {
  bmuf_lr_ = 1;
  clear_has_bmuf_lr();
}
inline float SolverParameter::bmuf_lr() const {
  return bmuf_lr_;
}
inline void SolverParameter::set_bmuf_lr(float value) {
  set_has_bmuf_lr();
  bmuf_lr_ = value;
}

// optional float bmuf_momentum = 31 [default = 0];
inline bool SolverParameter::has_bmuf_momentum() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void SolverParameter::set_has_bmuf_momentum() {
  _has_bits_[0] |= 0x40000000u;
}
inline void SolverParameter::clear_has_bmuf_momentum() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void SolverParameter::clear_bmuf_momentum() {
  bmuf_momentum_ = 0;
  clear_has_bmuf_momentum();
}
inline float SolverParameter::bmuf_momentum() const {
  return bmuf_momentum_;
}
inline void SolverParameter::set_bmuf_momentum(float value) {
  set_has_bmuf_momentum();
  bmuf_momentum_ = value;
}

// optional int32 bmuf_interval = 32 [default = 1];
inline bool SolverParameter::has_bmuf_interval() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void SolverParameter::set_has_bmuf_interval() {
  _has_bits_[0] |= 0x80000000u;
}
inline void SolverParameter::clear_has_bmuf_interval() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void SolverParameter::clear_bmuf_interval() {
  bmuf_interval_ = 1;
  clear_has_bmuf_interval();
}
inline ::google::protobuf::int32 SolverParameter::bmuf_interval() const {
  return bmuf_interval_;
}
inline void SolverParameter::set_bmuf_interval(::google::protobuf::int32 value) {
  set_has_bmuf_interval();
  bmuf_interval_ = value;
}

// -------------------------------------------------------------------

// SolverState

// optional int32 iter = 1;
inline bool SolverState::has_iter() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SolverState::set_has_iter() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SolverState::clear_has_iter() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SolverState::clear_iter() {
  iter_ = 0;
  clear_has_iter();
}
inline ::google::protobuf::int32 SolverState::iter() const {
  return iter_;
}
inline void SolverState::set_iter(::google::protobuf::int32 value) {
  set_has_iter();
  iter_ = value;
}

// optional string learned_net = 2;
inline bool SolverState::has_learned_net() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SolverState::set_has_learned_net() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SolverState::clear_has_learned_net() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SolverState::clear_learned_net() {
  if (learned_net_ != &::google::protobuf::internal::kEmptyString) {
    learned_net_->clear();
  }
  clear_has_learned_net();
}
inline const ::std::string& SolverState::learned_net() const {
  return *learned_net_;
}
inline void SolverState::set_learned_net(const ::std::string& value) {
  set_has_learned_net();
  if (learned_net_ == &::google::protobuf::internal::kEmptyString) {
    learned_net_ = new ::std::string;
  }
  learned_net_->assign(value);
}
inline void SolverState::set_learned_net(const char* value) {
  set_has_learned_net();
  if (learned_net_ == &::google::protobuf::internal::kEmptyString) {
    learned_net_ = new ::std::string;
  }
  learned_net_->assign(value);
}
inline void SolverState::set_learned_net(const char* value, size_t size) {
  set_has_learned_net();
  if (learned_net_ == &::google::protobuf::internal::kEmptyString) {
    learned_net_ = new ::std::string;
  }
  learned_net_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SolverState::mutable_learned_net() {
  set_has_learned_net();
  if (learned_net_ == &::google::protobuf::internal::kEmptyString) {
    learned_net_ = new ::std::string;
  }
  return learned_net_;
}
inline ::std::string* SolverState::release_learned_net() {
  clear_has_learned_net();
  if (learned_net_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = learned_net_;
    learned_net_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .caffepro.BlobProto history = 3;
inline int SolverState::history_size() const {
  return history_.size();
}
inline void SolverState::clear_history() {
  history_.Clear();
}
inline const ::caffepro::BlobProto& SolverState::history(int index) const {
  return history_.Get(index);
}
inline ::caffepro::BlobProto* SolverState::mutable_history(int index) {
  return history_.Mutable(index);
}
inline ::caffepro::BlobProto* SolverState::add_history() {
  return history_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::caffepro::BlobProto >&
SolverState::history() const {
  return history_;
}
inline ::google::protobuf::RepeatedPtrField< ::caffepro::BlobProto >*
SolverState::mutable_history() {
  return &history_;
}

// -------------------------------------------------------------------

// ScaleBiasParameter

// optional .caffepro.FillerParameter weight_filler = 1;
inline bool ScaleBiasParameter::has_weight_filler() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ScaleBiasParameter::set_has_weight_filler() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ScaleBiasParameter::clear_has_weight_filler() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ScaleBiasParameter::clear_weight_filler() {
  if (weight_filler_ != NULL) weight_filler_->::caffepro::FillerParameter::Clear();
  clear_has_weight_filler();
}
inline const ::caffepro::FillerParameter& ScaleBiasParameter::weight_filler() const {
  return weight_filler_ != NULL ? *weight_filler_ : *default_instance_->weight_filler_;
}
inline ::caffepro::FillerParameter* ScaleBiasParameter::mutable_weight_filler() {
  set_has_weight_filler();
  if (weight_filler_ == NULL) weight_filler_ = new ::caffepro::FillerParameter;
  return weight_filler_;
}
inline ::caffepro::FillerParameter* ScaleBiasParameter::release_weight_filler() {
  clear_has_weight_filler();
  ::caffepro::FillerParameter* temp = weight_filler_;
  weight_filler_ = NULL;
  return temp;
}

// optional .caffepro.FillerParameter bias_filler = 2;
inline bool ScaleBiasParameter::has_bias_filler() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ScaleBiasParameter::set_has_bias_filler() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ScaleBiasParameter::clear_has_bias_filler() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ScaleBiasParameter::clear_bias_filler() {
  if (bias_filler_ != NULL) bias_filler_->::caffepro::FillerParameter::Clear();
  clear_has_bias_filler();
}
inline const ::caffepro::FillerParameter& ScaleBiasParameter::bias_filler() const {
  return bias_filler_ != NULL ? *bias_filler_ : *default_instance_->bias_filler_;
}
inline ::caffepro::FillerParameter* ScaleBiasParameter::mutable_bias_filler() {
  set_has_bias_filler();
  if (bias_filler_ == NULL) bias_filler_ = new ::caffepro::FillerParameter;
  return bias_filler_;
}
inline ::caffepro::FillerParameter* ScaleBiasParameter::release_bias_filler() {
  clear_has_bias_filler();
  ::caffepro::FillerParameter* temp = bias_filler_;
  bias_filler_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// CropParameter

// required .caffepro.CropParameter.CropType crop_type = 1;
inline bool CropParameter::has_crop_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CropParameter::set_has_crop_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CropParameter::clear_has_crop_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CropParameter::clear_crop_type() {
  crop_type_ = 0;
  clear_has_crop_type();
}
inline ::caffepro::CropParameter_CropType CropParameter::crop_type() const {
  return static_cast< ::caffepro::CropParameter_CropType >(crop_type_);
}
inline void CropParameter::set_crop_type(::caffepro::CropParameter_CropType value) {
  GOOGLE_DCHECK(::caffepro::CropParameter_CropType_IsValid(value));
  set_has_crop_type();
  crop_type_ = value;
}

// optional uint32 stride = 2 [default = 1];
inline bool CropParameter::has_stride() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CropParameter::set_has_stride() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CropParameter::clear_has_stride() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CropParameter::clear_stride() {
  stride_ = 1u;
  clear_has_stride();
}
inline ::google::protobuf::uint32 CropParameter::stride() const {
  return stride_;
}
inline void CropParameter::set_stride(::google::protobuf::uint32 value) {
  set_has_stride();
  stride_ = value;
}

// required uint32 crop_width = 3;
inline bool CropParameter::has_crop_width() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CropParameter::set_has_crop_width() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CropParameter::clear_has_crop_width() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CropParameter::clear_crop_width() {
  crop_width_ = 0u;
  clear_has_crop_width();
}
inline ::google::protobuf::uint32 CropParameter::crop_width() const {
  return crop_width_;
}
inline void CropParameter::set_crop_width(::google::protobuf::uint32 value) {
  set_has_crop_width();
  crop_width_ = value;
}

// required uint32 crop_height = 4;
inline bool CropParameter::has_crop_height() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CropParameter::set_has_crop_height() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CropParameter::clear_has_crop_height() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CropParameter::clear_crop_height() {
  crop_height_ = 0u;
  clear_has_crop_height();
}
inline ::google::protobuf::uint32 CropParameter::crop_height() const {
  return crop_height_;
}
inline void CropParameter::set_crop_height(::google::protobuf::uint32 value) {
  set_has_crop_height();
  crop_height_ = value;
}

// -------------------------------------------------------------------

// ReduceDimParameter

// required uint32 dim = 1;
inline bool ReduceDimParameter::has_dim() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReduceDimParameter::set_has_dim() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReduceDimParameter::clear_has_dim() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReduceDimParameter::clear_dim() {
  dim_ = 0u;
  clear_has_dim();
}
inline ::google::protobuf::uint32 ReduceDimParameter::dim() const {
  return dim_;
}
inline void ReduceDimParameter::set_dim(::google::protobuf::uint32 value) {
  set_has_dim();
  dim_ = value;
}

// optional uint32 group = 2 [default = 1];
inline bool ReduceDimParameter::has_group() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReduceDimParameter::set_has_group() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReduceDimParameter::clear_has_group() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReduceDimParameter::clear_group() {
  group_ = 1u;
  clear_has_group();
}
inline ::google::protobuf::uint32 ReduceDimParameter::group() const {
  return group_;
}
inline void ReduceDimParameter::set_group(::google::protobuf::uint32 value) {
  set_has_group();
  group_ = value;
}

// required .caffepro.ReduceDimParameter.ReduceType reduce_type = 3 [default = AVE];
inline bool ReduceDimParameter::has_reduce_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ReduceDimParameter::set_has_reduce_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ReduceDimParameter::clear_has_reduce_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ReduceDimParameter::clear_reduce_type() {
  reduce_type_ = 0;
  clear_has_reduce_type();
}
inline ::caffepro::ReduceDimParameter_ReduceType ReduceDimParameter::reduce_type() const {
  return static_cast< ::caffepro::ReduceDimParameter_ReduceType >(reduce_type_);
}
inline void ReduceDimParameter::set_reduce_type(::caffepro::ReduceDimParameter_ReduceType value) {
  GOOGLE_DCHECK(::caffepro::ReduceDimParameter_ReduceType_IsValid(value));
  set_has_reduce_type();
  reduce_type_ = value;
}

// -------------------------------------------------------------------

// FlipParameter

// optional bool keep_original = 1 [default = true];
inline bool FlipParameter::has_keep_original() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FlipParameter::set_has_keep_original() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FlipParameter::clear_has_keep_original() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FlipParameter::clear_keep_original() {
  keep_original_ = true;
  clear_has_keep_original();
}
inline bool FlipParameter::keep_original() const {
  return keep_original_;
}
inline void FlipParameter::set_keep_original(bool value) {
  set_has_keep_original();
  keep_original_ = value;
}

// -------------------------------------------------------------------

// StepGateParameter

// required float init_value = 1;
inline bool StepGateParameter::has_init_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StepGateParameter::set_has_init_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StepGateParameter::clear_has_init_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StepGateParameter::clear_init_value() {
  init_value_ = 0;
  clear_has_init_value();
}
inline float StepGateParameter::init_value() const {
  return init_value_;
}
inline void StepGateParameter::set_init_value(float value) {
  set_has_init_value();
  init_value_ = value;
}

// required float step_value = 2;
inline bool StepGateParameter::has_step_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StepGateParameter::set_has_step_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StepGateParameter::clear_has_step_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StepGateParameter::clear_step_value() {
  step_value_ = 0;
  clear_has_step_value();
}
inline float StepGateParameter::step_value() const {
  return step_value_;
}
inline void StepGateParameter::set_step_value(float value) {
  set_has_step_value();
  step_value_ = value;
}

// required float max_value = 3;
inline bool StepGateParameter::has_max_value() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void StepGateParameter::set_has_max_value() {
  _has_bits_[0] |= 0x00000004u;
}
inline void StepGateParameter::clear_has_max_value() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void StepGateParameter::clear_max_value() {
  max_value_ = 0;
  clear_has_max_value();
}
inline float StepGateParameter::max_value() const {
  return max_value_;
}
inline void StepGateParameter::set_max_value(float value) {
  set_has_max_value();
  max_value_ = value;
}

// optional bool keep_backward = 4 [default = false];
inline bool StepGateParameter::has_keep_backward() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void StepGateParameter::set_has_keep_backward() {
  _has_bits_[0] |= 0x00000008u;
}
inline void StepGateParameter::clear_has_keep_backward() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void StepGateParameter::clear_keep_backward() {
  keep_backward_ = false;
  clear_has_keep_backward();
}
inline bool StepGateParameter::keep_backward() const {
  return keep_backward_;
}
inline void StepGateParameter::set_keep_backward(bool value) {
  set_has_keep_backward();
  keep_backward_ = value;
}

// optional bool keep_forward = 5 [default = false];
inline bool StepGateParameter::has_keep_forward() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void StepGateParameter::set_has_keep_forward() {
  _has_bits_[0] |= 0x00000010u;
}
inline void StepGateParameter::clear_has_keep_forward() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void StepGateParameter::clear_keep_forward() {
  keep_forward_ = false;
  clear_has_keep_forward();
}
inline bool StepGateParameter::keep_forward() const {
  return keep_forward_;
}
inline void StepGateParameter::set_keep_forward(bool value) {
  set_has_keep_forward();
  keep_forward_ = value;
}

// optional uint32 start_iter = 6;
inline bool StepGateParameter::has_start_iter() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void StepGateParameter::set_has_start_iter() {
  _has_bits_[0] |= 0x00000020u;
}
inline void StepGateParameter::clear_has_start_iter() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void StepGateParameter::clear_start_iter() {
  start_iter_ = 0u;
  clear_has_start_iter();
}
inline ::google::protobuf::uint32 StepGateParameter::start_iter() const {
  return start_iter_;
}
inline void StepGateParameter::set_start_iter(::google::protobuf::uint32 value) {
  set_has_start_iter();
  start_iter_ = value;
}

// -------------------------------------------------------------------

// HouseholderParameter

// optional uint32 source = 1 [default = 0];
inline bool HouseholderParameter::has_source() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HouseholderParameter::set_has_source() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HouseholderParameter::clear_has_source() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HouseholderParameter::clear_source() {
  source_ = 0u;
  clear_has_source();
}
inline ::google::protobuf::uint32 HouseholderParameter::source() const {
  return source_;
}
inline void HouseholderParameter::set_source(::google::protobuf::uint32 value) {
  set_has_source();
  source_ = value;
}

// -------------------------------------------------------------------

// InstanceSampleParameter

// optional .caffepro.InstanceSampleParameter.SampleMethod sample_method = 1 [default = SEQ];
inline bool InstanceSampleParameter::has_sample_method() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InstanceSampleParameter::set_has_sample_method() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InstanceSampleParameter::clear_has_sample_method() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InstanceSampleParameter::clear_sample_method() {
  sample_method_ = 0;
  clear_has_sample_method();
}
inline ::caffepro::InstanceSampleParameter_SampleMethod InstanceSampleParameter::sample_method() const {
  return static_cast< ::caffepro::InstanceSampleParameter_SampleMethod >(sample_method_);
}
inline void InstanceSampleParameter::set_sample_method(::caffepro::InstanceSampleParameter_SampleMethod value) {
  GOOGLE_DCHECK(::caffepro::InstanceSampleParameter_SampleMethod_IsValid(value));
  set_has_sample_method();
  sample_method_ = value;
}

// required uint32 num = 2;
inline bool InstanceSampleParameter::has_num() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InstanceSampleParameter::set_has_num() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InstanceSampleParameter::clear_has_num() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InstanceSampleParameter::clear_num() {
  num_ = 0u;
  clear_has_num();
}
inline ::google::protobuf::uint32 InstanceSampleParameter::num() const {
  return num_;
}
inline void InstanceSampleParameter::set_num(::google::protobuf::uint32 value) {
  set_has_num();
  num_ = value;
}

// -------------------------------------------------------------------

// MatrixMulParameter

// optional bool trans_A = 1 [default = false];
inline bool MatrixMulParameter::has_trans_a() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MatrixMulParameter::set_has_trans_a() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MatrixMulParameter::clear_has_trans_a() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MatrixMulParameter::clear_trans_a() {
  trans_a_ = false;
  clear_has_trans_a();
}
inline bool MatrixMulParameter::trans_a() const {
  return trans_a_;
}
inline void MatrixMulParameter::set_trans_a(bool value) {
  set_has_trans_a();
  trans_a_ = value;
}

// optional bool trans_B = 2 [default = true];
inline bool MatrixMulParameter::has_trans_b() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MatrixMulParameter::set_has_trans_b() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MatrixMulParameter::clear_has_trans_b() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MatrixMulParameter::clear_trans_b() {
  trans_b_ = true;
  clear_has_trans_b();
}
inline bool MatrixMulParameter::trans_b() const {
  return trans_b_;
}
inline void MatrixMulParameter::set_trans_b(bool value) {
  set_has_trans_b();
  trans_b_ = value;
}

// -------------------------------------------------------------------

// MatrixMulStackParameter

// required uint32 num = 1;
inline bool MatrixMulStackParameter::has_num() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MatrixMulStackParameter::set_has_num() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MatrixMulStackParameter::clear_has_num() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MatrixMulStackParameter::clear_num() {
  num_ = 0u;
  clear_has_num();
}
inline ::google::protobuf::uint32 MatrixMulStackParameter::num() const {
  return num_;
}
inline void MatrixMulStackParameter::set_num(::google::protobuf::uint32 value) {
  set_has_num();
  num_ = value;
}

// optional bool trans_odd = 2 [default = false];
inline bool MatrixMulStackParameter::has_trans_odd() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MatrixMulStackParameter::set_has_trans_odd() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MatrixMulStackParameter::clear_has_trans_odd() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MatrixMulStackParameter::clear_trans_odd() {
  trans_odd_ = false;
  clear_has_trans_odd();
}
inline bool MatrixMulStackParameter::trans_odd() const {
  return trans_odd_;
}
inline void MatrixMulStackParameter::set_trans_odd(bool value) {
  set_has_trans_odd();
  trans_odd_ = value;
}

// optional bool trans_even = 3 [default = true];
inline bool MatrixMulStackParameter::has_trans_even() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MatrixMulStackParameter::set_has_trans_even() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MatrixMulStackParameter::clear_has_trans_even() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MatrixMulStackParameter::clear_trans_even() {
  trans_even_ = true;
  clear_has_trans_even();
}
inline bool MatrixMulStackParameter::trans_even() const {
  return trans_even_;
}
inline void MatrixMulStackParameter::set_trans_even(bool value) {
  set_has_trans_even();
  trans_even_ = value;
}

// -------------------------------------------------------------------

// TransposeParameter

// required uint32 lead_dim = 1;
inline bool TransposeParameter::has_lead_dim() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TransposeParameter::set_has_lead_dim() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TransposeParameter::clear_has_lead_dim() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TransposeParameter::clear_lead_dim() {
  lead_dim_ = 0u;
  clear_has_lead_dim();
}
inline ::google::protobuf::uint32 TransposeParameter::lead_dim() const {
  return lead_dim_;
}
inline void TransposeParameter::set_lead_dim(::google::protobuf::uint32 value) {
  set_has_lead_dim();
  lead_dim_ = value;
}

// repeated int32 output_dims = 2;
inline int TransposeParameter::output_dims_size() const {
  return output_dims_.size();
}
inline void TransposeParameter::clear_output_dims() {
  output_dims_.Clear();
}
inline ::google::protobuf::int32 TransposeParameter::output_dims(int index) const {
  return output_dims_.Get(index);
}
inline void TransposeParameter::set_output_dims(int index, ::google::protobuf::int32 value) {
  output_dims_.Set(index, value);
}
inline void TransposeParameter::add_output_dims(::google::protobuf::int32 value) {
  output_dims_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
TransposeParameter::output_dims() const {
  return output_dims_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
TransposeParameter::mutable_output_dims() {
  return &output_dims_;
}

// -------------------------------------------------------------------

// ReshapeParameter

// repeated int32 dims = 1;
inline int ReshapeParameter::dims_size() const {
  return dims_.size();
}
inline void ReshapeParameter::clear_dims() {
  dims_.Clear();
}
inline ::google::protobuf::int32 ReshapeParameter::dims(int index) const {
  return dims_.Get(index);
}
inline void ReshapeParameter::set_dims(int index, ::google::protobuf::int32 value) {
  dims_.Set(index, value);
}
inline void ReshapeParameter::add_dims(::google::protobuf::int32 value) {
  dims_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
ReshapeParameter::dims() const {
  return dims_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
ReshapeParameter::mutable_dims() {
  return &dims_;
}

// -------------------------------------------------------------------

// LearnableDropoutParameter

// optional float init_value = 1 [default = 0];
inline bool LearnableDropoutParameter::has_init_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LearnableDropoutParameter::set_has_init_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LearnableDropoutParameter::clear_has_init_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LearnableDropoutParameter::clear_init_value() {
  init_value_ = 0;
  clear_has_init_value();
}
inline float LearnableDropoutParameter::init_value() const {
  return init_value_;
}
inline void LearnableDropoutParameter::set_init_value(float value) {
  set_has_init_value();
  init_value_ = value;
}

// -------------------------------------------------------------------

// DimInnerProductParameter

// required uint32 dim = 1;
inline bool DimInnerProductParameter::has_dim() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DimInnerProductParameter::set_has_dim() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DimInnerProductParameter::clear_has_dim() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DimInnerProductParameter::clear_dim() {
  dim_ = 0u;
  clear_has_dim();
}
inline ::google::protobuf::uint32 DimInnerProductParameter::dim() const {
  return dim_;
}
inline void DimInnerProductParameter::set_dim(::google::protobuf::uint32 value) {
  set_has_dim();
  dim_ = value;
}

// -------------------------------------------------------------------

// SoftthrParameter

// optional float softthr_thr = 1 [default = 0.1];
inline bool SoftthrParameter::has_softthr_thr() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SoftthrParameter::set_has_softthr_thr() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SoftthrParameter::clear_has_softthr_thr() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SoftthrParameter::clear_softthr_thr() {
  softthr_thr_ = 0.1f;
  clear_has_softthr_thr();
}
inline float SoftthrParameter::softthr_thr() const {
  return softthr_thr_;
}
inline void SoftthrParameter::set_softthr_thr(float value) {
  set_has_softthr_thr();
  softthr_thr_ = value;
}

// -------------------------------------------------------------------

// DropoutsameParameter

// optional float dropout_ratio = 1 [default = 0.5];
inline bool DropoutsameParameter::has_dropout_ratio() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DropoutsameParameter::set_has_dropout_ratio() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DropoutsameParameter::clear_has_dropout_ratio() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DropoutsameParameter::clear_dropout_ratio() {
  dropout_ratio_ = 0.5f;
  clear_has_dropout_ratio();
}
inline float DropoutsameParameter::dropout_ratio() const {
  return dropout_ratio_;
}
inline void DropoutsameParameter::set_dropout_ratio(float value) {
  set_has_dropout_ratio();
  dropout_ratio_ = value;
}

// optional bool force_random = 2 [default = false];
inline bool DropoutsameParameter::has_force_random() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DropoutsameParameter::set_has_force_random() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DropoutsameParameter::clear_has_force_random() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DropoutsameParameter::clear_force_random() {
  force_random_ = false;
  clear_has_force_random();
}
inline bool DropoutsameParameter::force_random() const {
  return force_random_;
}
inline void DropoutsameParameter::set_force_random(bool value) {
  set_has_force_random();
  force_random_ = value;
}

// -------------------------------------------------------------------

// DiagOperationParameter

// optional float scale = 1 [default = 1];
inline bool DiagOperationParameter::has_scale() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DiagOperationParameter::set_has_scale() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DiagOperationParameter::clear_has_scale() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DiagOperationParameter::clear_scale() {
  scale_ = 1;
  clear_has_scale();
}
inline float DiagOperationParameter::scale() const {
  return scale_;
}
inline void DiagOperationParameter::set_scale(float value) {
  set_has_scale();
  scale_ = value;
}

// optional float shift = 2 [default = 0];
inline bool DiagOperationParameter::has_shift() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DiagOperationParameter::set_has_shift() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DiagOperationParameter::clear_has_shift() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DiagOperationParameter::clear_shift() {
  shift_ = 0;
  clear_has_shift();
}
inline float DiagOperationParameter::shift() const {
  return shift_;
}
inline void DiagOperationParameter::set_shift(float value) {
  set_has_shift();
  shift_ = value;
}

// -------------------------------------------------------------------

// SoftMaxLossOHEMParameter

// optional int32 ohem_size = 1 [default = 64];
inline bool SoftMaxLossOHEMParameter::has_ohem_size() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SoftMaxLossOHEMParameter::set_has_ohem_size() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SoftMaxLossOHEMParameter::clear_has_ohem_size() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SoftMaxLossOHEMParameter::clear_ohem_size() {
  ohem_size_ = 64;
  clear_has_ohem_size();
}
inline ::google::protobuf::int32 SoftMaxLossOHEMParameter::ohem_size() const {
  return ohem_size_;
}
inline void SoftMaxLossOHEMParameter::set_ohem_size(::google::protobuf::int32 value) {
  set_has_ohem_size();
  ohem_size_ = value;
}

// optional bool force_random = 2 [default = false];
inline bool SoftMaxLossOHEMParameter::has_force_random() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SoftMaxLossOHEMParameter::set_has_force_random() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SoftMaxLossOHEMParameter::clear_has_force_random() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SoftMaxLossOHEMParameter::clear_force_random() {
  force_random_ = false;
  clear_has_force_random();
}
inline bool SoftMaxLossOHEMParameter::force_random() const {
  return force_random_;
}
inline void SoftMaxLossOHEMParameter::set_force_random(bool value) {
  set_has_force_random();
  force_random_ = value;
}

// -------------------------------------------------------------------

// SoftMaxOHEMParameter

// optional int32 ohem_size = 1 [default = 64];
inline bool SoftMaxOHEMParameter::has_ohem_size() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SoftMaxOHEMParameter::set_has_ohem_size() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SoftMaxOHEMParameter::clear_has_ohem_size() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SoftMaxOHEMParameter::clear_ohem_size() {
  ohem_size_ = 64;
  clear_has_ohem_size();
}
inline ::google::protobuf::int32 SoftMaxOHEMParameter::ohem_size() const {
  return ohem_size_;
}
inline void SoftMaxOHEMParameter::set_ohem_size(::google::protobuf::int32 value) {
  set_has_ohem_size();
  ohem_size_ = value;
}

// optional bool force_random = 2 [default = false];
inline bool SoftMaxOHEMParameter::has_force_random() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SoftMaxOHEMParameter::set_has_force_random() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SoftMaxOHEMParameter::clear_has_force_random() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SoftMaxOHEMParameter::clear_force_random() {
  force_random_ = false;
  clear_has_force_random();
}
inline bool SoftMaxOHEMParameter::force_random() const {
  return force_random_;
}
inline void SoftMaxOHEMParameter::set_force_random(bool value) {
  set_has_force_random();
  force_random_ = value;
}

// optional bool use_max_loss = 3 [default = false];
inline bool SoftMaxOHEMParameter::has_use_max_loss() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SoftMaxOHEMParameter::set_has_use_max_loss() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SoftMaxOHEMParameter::clear_has_use_max_loss() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SoftMaxOHEMParameter::clear_use_max_loss() {
  use_max_loss_ = false;
  clear_has_use_max_loss();
}
inline bool SoftMaxOHEMParameter::use_max_loss() const {
  return use_max_loss_;
}
inline void SoftMaxOHEMParameter::set_use_max_loss(bool value) {
  set_has_use_max_loss();
  use_max_loss_ = value;
}

// -------------------------------------------------------------------

// SoftMaxOHEMSplitParameter

// optional int32 ohem_size = 1 [default = 64];
inline bool SoftMaxOHEMSplitParameter::has_ohem_size() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SoftMaxOHEMSplitParameter::set_has_ohem_size() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SoftMaxOHEMSplitParameter::clear_has_ohem_size() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SoftMaxOHEMSplitParameter::clear_ohem_size() {
  ohem_size_ = 64;
  clear_has_ohem_size();
}
inline ::google::protobuf::int32 SoftMaxOHEMSplitParameter::ohem_size() const {
  return ohem_size_;
}
inline void SoftMaxOHEMSplitParameter::set_ohem_size(::google::protobuf::int32 value) {
  set_has_ohem_size();
  ohem_size_ = value;
}

// optional bool force_random = 2 [default = false];
inline bool SoftMaxOHEMSplitParameter::has_force_random() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SoftMaxOHEMSplitParameter::set_has_force_random() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SoftMaxOHEMSplitParameter::clear_has_force_random() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SoftMaxOHEMSplitParameter::clear_force_random() {
  force_random_ = false;
  clear_has_force_random();
}
inline bool SoftMaxOHEMSplitParameter::force_random() const {
  return force_random_;
}
inline void SoftMaxOHEMSplitParameter::set_force_random(bool value) {
  set_has_force_random();
  force_random_ = value;
}

// optional bool use_max_loss = 3 [default = false];
inline bool SoftMaxOHEMSplitParameter::has_use_max_loss() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SoftMaxOHEMSplitParameter::set_has_use_max_loss() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SoftMaxOHEMSplitParameter::clear_has_use_max_loss() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SoftMaxOHEMSplitParameter::clear_use_max_loss() {
  use_max_loss_ = false;
  clear_has_use_max_loss();
}
inline bool SoftMaxOHEMSplitParameter::use_max_loss() const {
  return use_max_loss_;
}
inline void SoftMaxOHEMSplitParameter::set_use_max_loss(bool value) {
  set_has_use_max_loss();
  use_max_loss_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace caffepro

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::caffepro::LayerParameter_UpdateMethod>() {
  return ::caffepro::LayerParameter_UpdateMethod_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::caffepro::LearnableLeakReluParameter_ShareParamMethod>() {
  return ::caffepro::LearnableLeakReluParameter_ShareParamMethod_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::caffepro::BatchNormalizationParameter_RecordOption>() {
  return ::caffepro::BatchNormalizationParameter_RecordOption_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::caffepro::GridGeneratorParameter_GridSizeOption>() {
  return ::caffepro::GridGeneratorParameter_GridSizeOption_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::caffepro::SampleParameter_ConcatOutputOption>() {
  return ::caffepro::SampleParameter_ConcatOutputOption_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::caffepro::DataParameter_BigFile_InterpolationType>() {
  return ::caffepro::DataParameter_BigFile_InterpolationType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::caffepro::DataParameter_BigFile_ScaleJitterType>() {
  return ::caffepro::DataParameter_BigFile_ScaleJitterType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::caffepro::DataParameter_BigFile_CropPreference>() {
  return ::caffepro::DataParameter_BigFile_CropPreference_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::caffepro::ClsLocLossParameter_LocType>() {
  return ::caffepro::ClsLocLossParameter_LocType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::caffepro::ClsLocLossParameter_LossTransform>() {
  return ::caffepro::ClsLocLossParameter_LossTransform_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::caffepro::LRNParameter_NormRegion>() {
  return ::caffepro::LRNParameter_NormRegion_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::caffepro::PoolingParameter_PoolMethod>() {
  return ::caffepro::PoolingParameter_PoolMethod_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::caffepro::SPMParameter_PoolMethod>() {
  return ::caffepro::SPMParameter_PoolMethod_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::caffepro::CropParameter_CropType>() {
  return ::caffepro::CropParameter_CropType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::caffepro::ReduceDimParameter_ReduceType>() {
  return ::caffepro::ReduceDimParameter_ReduceType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::caffepro::InstanceSampleParameter_SampleMethod>() {
  return ::caffepro::InstanceSampleParameter_SampleMethod_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#ifdef _MSC_VER
#  pragma warning(pop)
#endif

#endif  // PROTOBUF_caffe_2eproto__INCLUDED
